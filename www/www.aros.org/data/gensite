#!/usr/bin/env python

'''Generate the AROS WWW site.'''

import glob, os, os.path, sys

# Make sure that all files generated by this script are world-readable
os.umask (022)

# Fix nameclash between Image and HTMLgen.Image
try: #Following switcheroo ensures that if PIL is installed it's used instead
    # of the HTMLgen-bundled copies.
    import Image
    _Image = Image
    del Image
except ImportError:
    import ImageH
    _Image = ImageH
    del ImageH
import GifImagePluginH, JpegImagePluginH, PngImagePluginH

# Import HTML generator
from HTMLcolors import *
from HTMLgen import *

_varprog = None

# Copy of os.path.expandvars
def expandvars (path, dict=os.environ):
    """Expand shell variables of form $var and ${var}.  Unknown variables
are left unchanged"""
    global _varprog
    if '$' not in path:
        return path
    if not _varprog:
        import re
        _varprog = re.compile(r'\$(\w+|\{[^}]*\})')
    i = 0
    while 1:
        m = _varprog.search(path, i)
        if not m:
            break
        i, j = m.span(0)
        name = m.group(1)
        if name[:1] == '{' and name[-1:] == '}':
            name = name[1:-1]
        if dict.has_key(name):
            tail = path[j:]
            path = path[:i] + dict[name]
            i = len(path)
            path = path + tail
        else:
            i = j
    return path

# Import global config (mostly paths)
import config

def expandpath (path):
    return os.path.expanduser (expandvars (expandvars (path, config.__dict__)))

# Copy the "interesting" items of the config into local variables.
htmldir = expandpath (config.HTMLDIR)
ftpdir = expandpath (config.FTPDIR)
convert = config.__dict__.get ('CONVERT', None)

# Allow to read in python modules from AROS
arosdir = expandpath (config.AROSDIR)
path = os.path.join (arosdir, 'docs', 'src')
sys.path.append (path)

# The relative URL for the screenshots dir.
screenshoturl = 'pics/screenshots'

# This is a list of links which is used to generate the linkbox
# at the beginning of every page. The format is as follows:
#
#  ( 
#    ( main-page, sub-page-1, sub-page-2, ... ),
#    ( next-main-page, ... ),
#    ( ... ),
#  )
#
# All items in the lists must be objects of the class Href.
#
# Whenever a page is generated, you must pass the title of the main
# page (second parameter to Href()) to Page() in the parameter
# linkBoxItem. This will then "open" this item (ie. the subitems
# will be shown).
# FIXME Most pages are much bigger then the link box, therefore, we
# could always open all items. That would allow the user to navigate
# much more quickly.
mainLinks = (
    ( Href ('/index.html', 'NEWS'),
	Href ('/status.html', 'Status'),
	Href ('/credits.html', 'Credits'),
	Href ('/oldnews.html', 'Old News'),
    ),
    ( Href ('/documentation.html', 'Documentation'),
	Href ('/autodocs/index.html', 'AutoDocs'),
    ),
    ( Href ('/screenshots.html', 'Screenshots'),
	Href ('/screenshots.html#Pictures around AROS', 'Pictures'),
	Href ('/screenshots.html#Screenshots', 'Screenshots'),
    ),
    ( Href ('/download.html', 'Download'),
	Href ('ftp://ftp.aros.org/pub/aros/', 'FTP Server'),
	Href ('/snapshots.html', 'Snapshots'),
    ),
    ( Href ('/links.html', 'Links'),
	Href ('/links.html#More Related', 'More Related'),
	Href ('/links.html#Articles', 'Articles'),
	Href ('/links.html#Homepages', 'Homepages'),
	Href ('/links.html#Less Related', 'Less Related'),
    ),
)

def relpath(path1, path2):
    """Return the relative path from directory 'path1' to directory 'path2'

    Both arguments are assumed to be directory names as there is no
    way to really distinguish a file from a directory by names
    alone. To loosen this restriction one can either assume that both
    arguments represent files or directories currently extant so that
    they can be tested, or add extra arguments to flag the path types
    (file or directory).

    I chose to impose this restriction because I will use this function
    in places where the pathnames are for files yet to be created.
    """
    #print 'relpath', path1, path2
    common = os.path.commonprefix([path1, path2])
    sliceoff = len(common)
    path1 = path1[sliceoff:]
    path2 = path2[sliceoff:]

    dirs1 = string.split(path1, os.sep) # list of directory components below
                                        # the common path
    dirs1 = filter(lambda x: x, dirs1)  # filter out empty elements
    rel = (os.pardir+os.sep)*len(dirs1) # construct the relative path to the
                                        # common point
    rel = os.curdir + os.sep + rel
    
    result = os.path.normpath (rel+path2)
    #print result

    return result

class Page (SeriesDocument):
    def __init__ (self, rcFile='aros.rc', linkBoxItem='', **kw):
	'''Base class to generate a page. linkBoxItem must be the
	Title of the main page in the linkbox (see the list mainLinks
	above).

	The "meat" of the page goes into self.meat. To add something
	to the page, use this code:

	    page = Page (...)
	    page.meat = page.meat + [item]
	
	Note that you must add a list (not a tuple or a single element)
	to page.meat.
	'''
	apply (SeriesDocument.__init__, (self, rcFile,), kw)

	# Create the header of every page.
	table = TableLite ()
	self.banner = table
	row = TR ()
	table.append (row)
	td = TD (valign='TOP')
	logo = Href ('/', Image (
		('/pics/logo.gif', 300, 123),
		alt='AROS',
		#absolute=os.path.abspath (os.path.join (htmldir, 'pics')),
	    )
	)
	td = td + [logo]
	row = row + [td, TD (Text ('Amiga Research OS'))]

	# Create another table for the page content. 
	table = TableLite ()
	self.append (table)
	row = TR ()
	table.append (row)
	td = TD (valign='TOP')
	row = row + [td,]
	table2 = TableLite ()
	td = td + [table2,]
	row2 = TR ()
	table2.append (row2)
	td2 = TD (bgcolor='#40FF80', valign='TOP')
	row2 = row2 + [td2]
	self.linkbox = Font (size='-2')
	td2 = td2 + [self.linkbox]

	# The content will go here
	self.meat = TD (valign='TOP')
	row = row + [self.meat]

	# Link to the main page
	self.gohome = '/'

	if linkBoxItem:
	    list = []
	    for links in mainLinks:
		if links[0].text == linkBoxItem:
		    list.append (links)
		else:
		    list.append ((links[0],))

	    for links in list:
		self.linkbox = self.linkbox + [links[0], BR ()]
		for link in links[1:]:
		    self.linkbox = self.linkbox + [
			RawText ('&nbsp;&nbsp;&nbsp;'),
			link, BR ()]

    def relurl (self, path1, path2):
	#print self.relurl, path1, path2
	if not path2:
	    return None
	
	if string.find (path2, '://'):
	    return path2
	
	if path1[0] != '/':
	    path1 = os.path.abspath (os.path.join (htmldir, path1))
	if path2[0] != '/':
	    path2 = os.path.abspath (os.path.join (htmldir, path2))

	return relpath (path1, path2)

    def write (self, filename):
	# Create relative paths to other pages
	for links in mainLinks:
	    prev = next = top = None
	    for i in range (len (links)):
		url = links[i].url
		pos = string.find (url, '#')
		if pos != -1:
		    url = url[:pos]
		if url == filename:
		    if i > 0:
			prev = links[i-1].url
		    if i+1 < len (links):
			next = links[i+1].url
		    top = links[0].url
		    break
	    if top:
		break
	
	path = os.path.abspath (os.path.join (htmldir, os.path.dirname (filename)))
	self.goprev = self.relurl (path, prev)
	self.gonext = self.relurl (path, next)
	self.gotop = self.relurl (path, top)

	# Convert myself into HTML
	SeriesDocument.write (self, os.path.join (htmldir, filename))

parSep = re.compile ('\n\n+', re.MULTILINE)

class MyRawText (RawText):
    def __init__ (self, text):
	RawText.__init__ (self, parSep.sub ('<P>\n\n', text))

def genNews ():
    '''Create the news page (index.html, oldnews.html).'''

    def genPage (items, filename):
	'''Convert a list of news items into an HTML page and save
	it in filename. items must be a list of files with newsitems.
	The filenames must be dates in the form YYYYMMDD.'''

	def prepareNewsItem (filename):
	    '''Convert a single news item into HTML.'''

	    row = TR ()
	    td = TD (bgcolor='#80C0F0', valign='TOP')
	    row = row + [td]
	    str = os.path.basename (filename)
	    date = '%d.%d.%d' % (
		int (str[6:8]),
		int (str[4:6]),
		int (str[0:4]),
	    )
	    td = td + [Name (str), date]

	    td = TD (valign='TOP')
	    row = row + [td]

	    fh = open (filename, 'r')
	    body = fh.read ()
	    fh.close ()

	    td = td + [MyRawText (body)]
	    
	    return row
	    
	page = Page (linkBoxItem='NEWS')
	table = TableLite ()
	page.meat = page.meat + [table,]

	for file in items:
	    item = prepareNewsItem (file)
	    table.append (item)

	if filename == 'index.html':
	    p = Paragraph ()
	    p.append (Href ('oldnews.html', 'Older News'))
	    page.meat = page.meat + [p]

	page.write (filename)

    # Search all known news items, and sort them in reverse order
    list = glob.glob ('news/*')
    list.remove ('news/CVS')
    list.sort ()
    list.reverse ()
    
    # Create a main page with the Top 5 news items and another page
    # with the rest.
    genPage (list[:5], 'index.html')
    genPage (list[5:], 'oldnews.html')

import barchart
class MyDataList (barchart.DataList):
    def sum_totals (self):
	# Totals are passed in
	pass

    def load_tuple (self, t):
	label, total, rest = t[0], t[1], t[2:]
	barchart.DataList.load_tuple (self, [label]+list (rest))
	self[-1]['total'] = total

class MyStackedBarChart (barchart.StackedBarChart):
    def initialize (self):
	barchart.StackedBarChart.initialize (self)
	self.colors = ('red', 'yellow', 'green')

def genStatus ():
    '''Create the status page. This page contains two images (jpg&png)
    with graphs of the sizes of repositories.'''

    import jobs, time

    page = Page (linkBoxItem='NEWS')
    body = []
    body.append (Heading (2, 'Status'))
    body.append (Paragraph (
	'This status was generated %s' % time.strftime ('%d. %B %Y',
	    time.localtime (time.time ()))
    ))

    keys = jobs.jobs.keys ()
    keys.sort ()
    data = []
    for key in keys:
	lib = jobs.jobs[key]
	data.append ((lib.longName,
	    lib.jobsTotal,
	    lib.status[0], lib.status[1], lib.status[2])
	)

    dataList = MyDataList ()
    dataList.segment_names = ('Todo', 'In Work', 'Done')
    dataList.load_tuples (data)
    dataList.sort ()
    chart = MyStackedBarChart (dataList)
    chart.label_shade = AQUA
    chart.title = 'AROS Status'
    
    body.append (chart)
    body.append (Heading (2, 'Size of AROS sources'))
    body.append (Paragraph (Image ('aros_size.png')))
    body.append (Paragraph (Href ('aros_size.jpg', 'Also as JPEG')))
    body.append (Heading (2, 'Size of contributed sources'))
    body.append (Paragraph (Image ('contrib_size.png')))
    body.append (Paragraph (Href ('contrib_size.jpg', 'Also as JPEG')))
    page.meat = page.meat + body
    page.write ('status.html')

    #from docs.src.credits import credits
    from credits import credits
    page = Page (linkBoxItem='NEWS')
    body = []
    body.append (Heading (2, 'Credits'))
    for area, names in credits:
	body.append (Heading (3, area))
	body.append (Paragraph (string.join (names, ', ')))
    page.meat = page.meat + body
    page.write ('credits.html')

def genDocumentation ():

    page = Page (linkBoxItem='Documentation')
    # Put the old docs here
    page.meat = page.meat + [Text ('FIXME')]
    page.write ('documentation.html')

autodocdir = os.path.join (htmldir, 'autodocs')
includedir = os.path.join (htmldir, 'includes')
sourcedir = os.path.join (htmldir, 'sources')

class AutoDocPage (Page):
    def __init__ (self, lib, func):
	Page.__init__ (self)
	
	self.filename = os.path.join (autodocdir,
	    '%s_%s.html' % (
		string.lower (lib.name),
		string.lower (func.name),
	    )
	)
	self.absname = os.path.abspath (autodocdir)

    def relurl (self, dest):
	absdest = os.path.abspath (dest)
	url = relpath (self.absname, absdest)
	return url

    def write (self):
	self.gotop = self.relurl (os.path.join (autodocdir, 'index.html'))

	SeriesDocument.write (self, self.filename)

class Dummy:
    def __init__ (self, list):
	self.list = list

    def __str__ (self):
	text = ''
	for item in self.list:
	    text = text + str (item)
	
	return text

class Nbsp:
    def __str__ (self):
	return '&nbsp;'

class AutoDocItem:
    def __init__ (self, contents):
	self.contents = contents

    def __str__ (self):
	if type (self.contents) == type ([]):
	    text = ''
	    for item in self.contents:
		text = text + str (item)
	elif type (self.contents) == type (''):
	    text = str (MyRawText (string.strip (self.contents)))
	else:
	    text = str (self.contents)
	
	text = text + '\n<P>\n'
	return text

class MyCode (Pre):
    pass

includePattern = re.compile (r'\s*#\s*include\s*<([^>]+)>')

def genAutodocs ():
    if not os.path.exists (autodocdir):
	os.makedirs (autodocdir)

    def genPage (db, lib, func):
	try:
	    page = AutoDocPage (lib, func)

	    page.title = 'AROS - %s/%s' % (lib.longName, func.name)

	    dl = DefinitionList ()
	    page.meat = page.meat + [dl]

	    list = []
	    hasIncludes = 0
	    for isLocal, line in func.header:
		#print isLocal, line
		if isLocal:
		    continue
		
		match = includePattern.match (line)
		if match:
		    include = match.group (1)
		    list.append (Text ('#include <'))
		    list.append (Href (
			page.relurl (
			    os.path.join (htmldir, 'include', include)),
			    include,
			)
		    )
		    list.append (Text ('>'))
		    list.append (BR ())
		    hasIncludes = 1
	    
	    if hasIncludes:
		list.append (BR ())
	    
	    list.append (TT ('%s %s ()' % (func.result.type, func.name)))
	    list.append (BR ())
	    #list.append (Nbsp ())

	    dl.append (('NAME', AutoDocItem (list)))

	    list = []
	    for parameter in func.parameters:
		list.append (TT ('%s ' % parameter.type))
		list.append (Href ('#%s' % parameter.name, parameter.name))
		list.append (BR ())

	    dl.append (('SYNOPSIS', AutoDocItem (list)))

	    #print `func.section['FUNCTION']`
	    dl.append (('FUNCTION', AutoDocItem (func.section['FUNCTION'])))
	    parList = DefinitionList ()
	    for parameter in func.parameters:
		parList.append ((Dummy ([
			Name (parameter.name),
			parameter.name,
		    ]), parameter.explanation))
	    dl.append (('INPUTS', AutoDocItem (parList)))
	    dl.append (('RESULT', AutoDocItem (func.section['RESULT'])))
	    dl.append (('NOTES', AutoDocItem (func.section['NOTES'])))
	    dl.append (('EXAMPLE', AutoDocItem (MyCode (func.section['EXAMPLE']))))
	    dl.append (('BUGS', AutoDocItem (func.section['BUGS'])))

	    # Render SEE ALSO. The first item in the list is always
	    # the library
	    list = []
	    list.append (Href (
		page.relurl (os.path.join (autodocdir,
		    'index.html#%s' % lib.longName)),
		lib.longName
	    ))
	    dl.append (('SEE ALSO', AutoDocItem (list)))
	    
	    dl.append (('INTERNALS', AutoDocItem (func.section['INTERNALS'])))
	    dl.append (('HISTORY', AutoDocItem (func.section['HISTORY'])))

	    func.url = page.filename
	    page.write ()
	except:
	    print 'Error in %s/%s' % (lib.name, func.name)
	    raise
	
    import archtool

    archives = archtool.findArchives (
	    os.path.join (arosdir, 'rom'),
	    os.path.join (arosdir, 'workbench'),
	    os.path.join (arosdir, 'contrib'),
    )

    adocs = archtool.Archive (archives,
	postFunctionCB=genPage,
    )

    page = Page (linkBoxItem='Documentation')

    meat = []
    meat.append (Heading (2, 'Libraries sorted by Name'))

    list = []
    libs = adocs.libs.values ()
    libs.sort ()
    libAnchors = {}
    for lib in libs:
	key = string.upper (lib.longName[0])
	if not libAnchors.has_key (key):
	    libAnchors[key] = Href ('#%s' % lib.longName, 
		Font (key, size="-1")
	    )

    keys = libAnchors.keys ()
    keys.sort ()
    keylist = []
    for key in keys:
	keylist.append (libAnchors[key])
	keylist.append (Text (' '))
    meat.append (apply (Paragraph, keylist))

    meat.append (Name ('Functions sorted by Library'))
    meat.append (Heading (2, 'Functions sorted by Library'))

    for lib in libs:
	list.append (Font (
	    Href ('#%s' % lib.longName, lib.longName),
	    size="-1",
	))

    meat.append (NonBulletList (list))

    def makecell (page, func, absolute=os.path.abspath(autodocdir)):
	return TD (
	    Font (
		Href (relpath (absolute, os.path.abspath (func.url)),
		    func.name),
		size="-1",
	    ),
	    width="33%",
	    align="LEFT",
	)

    for lib in libs:
	meat.append (Name (lib.longName))
	meat.append (Heading (2, lib.longName))

	funcs = lib.functions.values ()
	funcs.sort ()
	
	table = TableLite (
	    width="100%",
	    border="0",
	    cellspacing="0",
	    cellpadding="0",
	)
	meat.append (table)
	
	i, n = 0, len (funcs)
	while i < n:
	
	    left = funcs[i]
	    middle = right = None
	    if i+1 < n:
		middle = funcs[i+1]
	    if i+2 < n:
		right = funcs[i+2]
	    i = i + 3
	    
	    list = [makecell (page, left)]
	    if middle:
		list.append (makecell (page, middle))
	    if right:
		list.append (makecell (page, right))

	    row = TR ()
	    row = row + list
	    table.append (row)
	    
    meat.append (Heading (2, 'Functions sorted by Name'))

    page.meat = page.meat + meat
    # Path here is relative to htmldir
    page.write (os.path.join ('autodocs', 'index.html'))

class ThumbnailTable (TableLite):
    '''Helper class to create a table with thumbnails.'''

    def __init__ (self, *pics):
	if len (pics) == 1:
	    width = "40%"
	    itemwidth = 'width="40%"'
	else:
	    width = "80%"
	    itemwidth = 'width="40%"'

	TableLite.__init__ (self,
	    border="0",
	    width=width,
	    align="center",
	    bgcolor="#000066",
	    cellpadding=0,
	)
	row = TR ()
	self.append (row)
	td = TD ()
	row = row + [td]
	table2 = TableLite (
	    border="0",
	    bgcolor="#CCCCCC",
	    cellspacing="2",
	    cellpadding="5",
	)
	td = td + [table2]

	if (len (pics) & 1) == 1:
	    pics = list (pics) + [None]
	i, n = 0, len (pics)
	while i < n:
	    row = TR ()
	    left, right = pics[i], pics[i+1]
	    i = i + 2
	    left = left.toHtml ()
	    #print left[1]
	    left[1].attr_dict['width'] = itemwidth
	    #print dir (left[1])
	    #print left[1].attr_dict
	    if not right:
		if n == 2:
		    right = []
		else:
		    td = TD (colspan="2")
		    td = td + [Nbsp ()]
		    right = [td]
	    else:
		right = right.toHtml ()
		right[1].attr_dict['width'] = itemwidth
	    row = row + left + right
	    
	    table2.append (row)

def genScreenshots ():
    '''Create a page with screenshots.'''

    page = Page (linkBoxItem='Screenshots')

    # First, the pictures of AROS developers, etc.
    page.meat = page.meat + [
	Name ('Pictures around AROS'),
	Heading (2, 'Pictures around AROS'),
	Paragraph ('If you ever wanted to know what Aaron "Optimizer" Digulla'
	    ' looks like, here are two pictures:'),
	ThumbnailTable (
	    Thumbnail ('pics/developers/Digulla-2.jpg'),
	    Thumbnail ('pics/developers/Digulla-1.jpg'),
	),
	Paragraph ('Picture of Nils Henrik Lorentzen:'),
	ThumbnailTable (
	    Thumbnail ('pics/developers/nlorentz.jpg'),
	),
	Paragraph ('Hopefully, more pictures of AROS developers will'
	    ' show up here :-)'),
	Name ('Screenshots'),
	Heading (2, 'Screenshots'),
    ]

    def processDir (dir):
	'''Read a directory and put all pictures in it into ThumbnailTables.
	The name of the directory must be YYYYMMDD.'''
	str = os.path.basename (dir)
	date = '%d.%d.%d' % (
	    int (str[6:8]),
	    int (str[4:6]),
	    int (str[0:4]),
	)
	fh = open (os.path.join (dir, 'README'), 'r')
	text = fh.read ()
	fh.close ()
	
	list = [
	    Paragraph (RawText ('%s - %s' % (date, text))),
	]
	files = glob.glob (os.path.join (dir, "*.*"))
	files.sort ()
	pics = []
	for file in files:
	    if file[-4:] == '.txt' or string.find (file, '_mini.') != -1:
		continue

	    pics.append (Thumbnail (os.path.join (screenshoturl, str,
		os.path.basename (file))))
	
	list.append (apply (ThumbnailTable, pics))
	return list
	    
    # Read all screenshots and sort them by date.
    dirs = glob.glob (os.path.join (htmldir, screenshoturl, '[0-9]*'))
    dirs.sort ()
    dirs.reverse ()
    for dir in dirs:
	page.meat = page.meat + processDir (dir)

    page.write ('screenshots.html')

def genDownload ():
    page = Page (linkBoxItem='Download')
    # Create the page for downloads
    page.meat = page.meat + [Text ('FIXME')]
    page.write ('download.html')

class FileInfo:
    '''Helper class which stores some useful information about a file,
    namely it's size (nicely formatted), the filename and the path
    to the file.
    
    self.filename - Name of the file (last element in the path)
    self.path - Full path to the file (might be relative)
    self.size - Nicely formatted size
    '''

    def __init__ (self, path):
	filename = os.path.basename (path)
	self.filename, self.path = filename, path

	size = os.path.getsize (path)

	if size > 1024:
	    size = ((size+1023) / 1024)
	    self.size = '%dKB' % size
	    if size > 1024:
		size = ((size+1023) / 1024)
		self.size = '%dMB' % size

class Snapshot (FileInfo):
    '''Helper class to store information about a snapshot. This is derived
    from the FileInfo class and contains this additional info:

    self.ext - Extension of the file
    self.date - Creation date (derived from the filename)
    self.title - Middle part of the filename
    self.log - FileInfo object about the logfile which belongs to
	    this snapshot or None.
    '''
    
    def __init__ (self, path):
	'''path must be a snapshot (Format:
	AROS-%(title)s-%(date)s.%(ext)s).'''
	FileInfo.__init__ (self, path)

	filename = self.filename
	self.ext = filename[-3:]
	filename = filename[:-4]
	self.date = filename[-8:]
	filename = filename[:-8]
	self.title = filename[5:-1]
	
	logfile = path[:-3] + 'log'
	if os.path.exists (logfile):
	    self.log = FileInfo (logfile)
	else:
	    self.log = None
	#print self.__dict__

class Thumbnail (FileInfo):
    '''Helper class for thumbnails. Pass it the name of a picture and
    it will contain FileInfo plus:

    self.width, self.height - Size of the picture
    self.format - Format of the file (GIF, JPEG, PNG, ...)
    self.thumbnailURL - URL of the thumbnail picture

    The thumbnail of the picture is created with ImageMagick if it
    doesn't exist or if it is outdated (the picture is newer).'''
    def __init__ (self, url):
	path = os.path.join (htmldir, url)
	FileInfo.__init__ (self, path)

	self.url = url
	pic = _Image.open (path)
	self.width, self.height = pic.size
	self.format = pic.format

	pos = string.rfind (url, '.')
	self.thumbnailURL = url[:pos] + '_mini.jpg'
	pos = string.rfind (path, '.')
	thumbnailPath = path[:pos] + '_mini.jpg'
	picMTime = os.path.getmtime (path)
	if os.path.exists (thumbnailPath):
	    tnMTime = os.path.getmtime (thumbnailPath)
	else:
	    tnMTime = 0
	if tnMTime < picMTime:
	    #tn = pic.convert ('RGB')
	    # Unfortunately, thumbnail() doesn't filter :-(
	    #tn.thumbnail = thumbnail
	    # FIXME event bicubic filtering looks pretty ugly.
	    # Replace this code with code that calls convert.
	    #thumbnail (tn, (64, 128))
	    #tn.save (thumbnailPath, 'JPEG')
	    if convert:
		cmd = '%s -geometry "64x128>" -quality 100 "%s" "%s"' % (
		    convert, path, thumbnailPath
		)
		#print cmd
		os.system (cmd)
		os.chmod (path, 0644)

	infoFile = path[:pos] + '.txt'
	if os.path.exists (infoFile):
	    fh = open (infoFile)
	    self.text = fh.read ()
	    fh.close ()
	else:
	    self.text = ''

    def toHtml (self):
	'''Convert this into HTML code.'''
	return [
	    TD (
		Href (self.url, Image ((self.thumbnailURL, 0,0))),
		width="64",
		valign="TOP",
	    ),
	    TD (
		Paragraph (RawText (self.text)),
		Font (Text ('%s %dx%d (%s)' % (
		    self.format,
		    self.width, self.height,
		    self.size,
		)), size="-1"),
		#width="35%",
		valign="TOP",
	    ),
	]

def genSnapshots ():
    '''Create the page with the snapshots with sizes and links for
    download.'''
    page = Page (linkBoxItem='Download')

    files = glob.glob (os.path.join (ftpdir, 'snapshots/*.tgz'))
    if not files:
        page.meat = page.meat + [Text ('No snapshots found')]
    else:
	dict = {}
	columns = {}
	days = {}

	for file in files:
	    ss = Snapshot (file)
	    day = dict.get (ss.date, None)
	    if not day:
		day = {}
		dict[ss.date] = day
	    if ss.ext != 'tgz':
		print 'Unknown Snapshot', file
		continue

	    day[ss.title] = ss
	    columns[ss.title] = None
	    days[ss.date] = None
	
	table = TableLite (cellpadding=15, border=2)
	page.meat = page.meat + [table]
	
	colList = columns.keys ()
	colList.sort ()
	row = TR ()
	table.append (row)
	td = TH ('Date')
	row = row + [td]
	    
	for col in colList:
	    td = TH (col)
	    row = row + [td]
	
	dateList = days.keys ()
	dateList.sort ()
	dateList.reverse ()
	for date in dateList:
	    row = TR ()
	    table.append (row)

	    str = '%d.%d.%d' % (
		int (date[6:8]),
		int (date[4:6]),
		int (date[0:4]),
	    )
	    row = row + [TD (str)]

	    day = dict.get (date, {})

	    for col in colList:
		t = Text ()
		ss = day.get (col, None)
		if ss:
		    t.append (Href ('ftp://ftp.aros.org/pub/aros/snapshots/%s' % ss.filename,
			ss.size
		    ))
		else:
		    t.append ('-')
		
		if ss.log:
		    t.append ('(Log: ')
		    t.append (Href (
			'ftp://ftp.aros.org/pub/aros/snapshots/%s' % \
			    ss.log.filename,
			ss.log.size
		    ))
		    t.append (')')
		else:
		    if not ss.title in ('contrib', 'source'):
			t.append ('(No log)')

		row = row + [TD (t)]

    page.write ('snapshots.html')

def processLinks (links):
    list = List ()

    for link in links:
	if type (link) == type (()):
	    link, children = link[0], link[1:]
	else:
	    children = None

	text = Text (link.href)
	if link.text:
	    if type (link.text) == type (()):
		t = Text ()
		for item in link.text:
		    t.append (item)
	    else:
		t = Text (link.text)
	    text.append (t)
	if link.logo:
	    text.append (Image ((link.logo, 0,0)))

	list.append (text)
	
	if children:
	    sublist = processLinks (children)
	    list.append (sublist)
    
    return list

def genLinks ():
    '''Create a page with links from links.py.'''
    def processSection (links, title):
	body = []

	#print title, list

	body.append (Name (title))
	body.append (Heading (2, title))
	list = processLinks (links)
	body.append (list)

	return body

    page = Page (linkBoxItem='Links')

    from links import moreRelated, articles, homepages, lessRelated

    page.meat = page.meat \
	+ processSection (moreRelated, 'More Related') \
	+ processSection (articles, 'Articles') \
	+ processSection (homepages, 'Homepages') \
	+ processSection (lessRelated, 'Less Related')

    page.write ('links.html')

# Call all generators in turn
genNews ()
genStatus ()
genDocumentation ()
genAutodocs ()
genScreenshots ()
genDownload ()
genSnapshots ()
genLinks ()
