#!/usr/bin/env python

'''Generate the AROS WWW site.'''

import glob, os, os.path, sys, cStringIO

# Make sure that all files generated by this script are world-readable
os.umask (022)

# Fix nameclash between Image and HTMLgen.Image
try: #Following switcheroo ensures that if PIL is installed it's used instead
    # of the HTMLgen-bundled copies.
    import Image
    _Image = Image
    del Image
except ImportError:
    import ImageH
    _Image = ImageH
    del ImageH
import GifImagePluginH, JpegImagePluginH, PngImagePluginH

# Import HTML generator
from HTMLcolors import *
from HTMLgen import *

_varprog = None

# Copy of os.path.expandvars
def expandvars (path, dict=os.environ):
    """Expand shell variables of form $var and ${var}.  Unknown variables
are left unchanged"""
    global _varprog
    if '$' not in path:
        return path
    if not _varprog:
        import re
        _varprog = re.compile(r'\$(\w+|\{[^}]*\})')
    i = 0
    while 1:
        m = _varprog.search(path, i)
        if not m:
            break
        i, j = m.span(0)
        name = m.group(1)
        if name[:1] == '{' and name[-1:] == '}':
            name = name[1:-1]
        if dict.has_key(name):
            tail = path[j:]
            path = path[:i] + dict[name]
            i = len(path)
            path = path + tail
        else:
            i = j
    return path

# Import global config (mostly paths)
import config

def expandpath (path):
    return os.path.expanduser (expandvars (expandvars (path, config.__dict__)))

# Copy the "interesting" items of the config into local variables.
htmldir = expandpath (config.HTMLDIR)
ftpdir = expandpath (config.FTPDIR)
cvsrootdir = expandpath (config.CVSROOTDIR)
convert = config.__dict__.get ('CONVERT', None)
basedir = config.__dict__.get ('BASEDIR', None)
if not basedir:
    basedir = os.path.dirname (os.getcwd ())
basedir = os.path.abspath (basedir)
datadir = os.path.join (basedir, 'data')
sys.path.append (datadir)

# Allow to read in python modules from AROS
arosdir = os.path.abspath (expandpath (config.AROSDIR))
path = os.path.join (arosdir, 'docs', 'src')
sys.path.append (path)

# The relative URL from htmldir to the screenshots dir.
screenshoturl = 'pics/screenshots'

# Do everything in htmldir
os.chdir (htmldir)

# Make all paths absolute
htmldir = os.getcwd ()

# This is a list of links which is used to generate the linkbox
# at the beginning of every page. The format is as follows:
#
#  ( 
#    ( main-page, sub-page-1, sub-page-2, ... ),
#    ( next-main-page, ... ),
#    ( ... ),
#  )
#
# All items in the lists must be objects of the class Href.
#
# Whenever a page is generated, you must pass the title of the main
# page (second parameter to Href()) to Page() in the parameter
# linkBoxItem. This will then "open" this item (ie. the subitems
# will be shown).
# FIXME Most pages are much bigger then the link box, therefore, we
# could always open all items. That would allow the user to navigate
# much more quickly.
mainLinks = (
    ( Href ('index.html', 'NEWS'),
	Href ('status.html', 'Status'),
	Href ('credits.html', 'Credits'),
	Href ('oldnews.html', 'Old News'),
    ),
    ( Href ('documentation.html', 'Documentation'),
	Href ('background.html', 'Background'),
	Href ('cvs.html', 'CVS'),
	Href ('mmake.html', 'MetaMake'),
	Href ('autodocs/index.html', 'AutoDocs'),
    ),
    ( Href ('screenshots.html', 'Screenshots'),
	Href ('screenshots.html#Pictures around AROS', 'Pictures'),
	Href ('screenshots.html#Screenshots', 'Screenshots'),
    ),
    ( Href ('download.html', 'Download'),
	Href ('ftp://ftp.aros.org/pub/aros/', 'FTP Server'),
	Href ('snapshots.html', 'Snapshots'),
    ),
    ( Href ('links.html', 'Links'),
	Href ('links.html#More Related', 'More Related'),
	Href ('links.html#Articles', 'Articles'),
	Href ('links.html#Homepages', 'Homepages'),
	Href ('links.html#Less Related', 'Less Related'),
    ),
)

def relpath(path1, path2):
    """Return the relative path from directory 'path1' to directory 'path2'

    Both arguments are assumed to be directory names as there is no
    way to really distinguish a file from a directory by names
    alone. To loosen this restriction one can either assume that both
    arguments represent files or directories currently extant so that
    they can be tested, or add extra arguments to flag the path types
    (file or directory).

    I chose to impose this restriction because I will use this function
    in places where the pathnames are for files yet to be created.
    """
    #print 'relpath', path1, path2
    common = os.path.commonprefix([path1, path2])
    sliceoff = len(common)
    path1 = path1[sliceoff:]
    path2 = path2[sliceoff:]

    dirs1 = string.split(path1, os.sep) # list of directory components below
                                        # the common path
    dirs1 = filter(lambda x: x, dirs1)  # filter out empty elements
    rel = (os.pardir+os.sep)*len(dirs1) # construct the relative path to the
                                        # common point
    rel = os.curdir + os.sep + rel
    
    result = os.path.normpath (rel+path2)
    #print result

    return result

arosRC = os.path.join (datadir, 'aros.rc')

HGHeading = Heading
HeadingPadding = ( 0, 10, 8, 6, 4, 2, 0, )
HeadingColors = ( '', "#80C0F0", "#90D0FF", "#A0E0FF", )
class Heading (HGHeading):
    def __str__ (self):
	s = HGHeading.__str__ (self)

	#print self.contents
	i = int (self.tagname[1:])
	table = TableLite (
	    border="0",
	    width="100%",
	    bgcolor=HeadingColors[i],
	    cellpadding=HeadingPadding[i],
	)
	row = TR ()
	table.append (row)
	td = TD (RawText (s))
	row = row + [td]

	return str (table)

class Page (SeriesDocument):
    def __init__ (self, rcFile=arosRC, linkBoxItem='', **kw):
	'''Base class to generate a page. linkBoxItem must be the
	Title of the main page in the linkbox (see the list mainLinks
	above).

	The "meat" of the page goes into self.meat. To add something
	to the page, use this code:

	    page = Page (...)
	    page.meat = page.meat + [item]
	
	Note that you must add a list (not a tuple or a single element)
	to page.meat.
	'''
	apply (SeriesDocument.__init__, (self, rcFile,), kw)

	self.linksToFix = []
	self.imagesToFix = []
	self.navbar = []

	#self.logo = os.path.join ('pics', 'minilogo.gif')
	#self.blank = os.path.join ('pics', 'blank.gif')
	#self.next = os.path.join ('pics', 'next.gif')
	#self.back = os.path.join ('pics', 'back.gif')
	#self.top = os.path.join ('pics', 'top.gif')
	#self.home = os.path.join ('pics', 'home.gif')

	# Create the header of every page.
	table = TableLite (
	    align="CENTER",
	)
	self.banner = table
	row = TR ()
	table.append (row)
	td = TD (valign='TOP')
	img = Image (
	    'pics/logo.gif',
	    alt='AROS',
	)
	self.imagesToFix.append (img)
	logo = Href ('index.html', img)
	self.linksToFix.append (logo)
	td = td + [logo]
	row = row + [td, TD (Text ('Amiga Research OS'))]

	# Create another table for the page content. 
	table = TableLite ()
	self.append (table)
	row = TR ()
	table.append (row)
	td = TD (valign='TOP')
	row = row + [td,]
	table2 = TableLite ()
	td = td + [table2,]
	row2 = TR ()
	table2.append (row2)
	td2 = TD (bgcolor='#40FF80', valign='TOP')
	row2 = row2 + [td2]
	#self.linkbox = Font (size='-2')
	self.linkbox = Font (size='0')
	td2 = td2 + [self.linkbox]

	# The content will go here
	self.meat = TD (valign='TOP')
	row = row + [self.meat]

	if linkBoxItem:
	    list = []
	    for links in mainLinks:
		if links[0].text == linkBoxItem:
		    list.append (links)
		else:
		    list.append ((links[0],))

	    for links in mainLinks:
		nl = Href (links[0].url, links[0].text)
		self.linksToFix.append (nl)
		self.linkbox = self.linkbox + [nl, BR (), RawText ('\n')]
		for link in links[1:]:
		    nl = Href (link.url, link.text)
		    self.linksToFix.append (nl)
		    self.linkbox = self.linkbox + [
			RawText ('&nbsp;&nbsp;&nbsp;'),
			nl,
			BR (),
			RawText ('\n')
		    ]

    # Fix because of broken Image URLs
    def nav_buttons (self):
        """Generate hyperlinked navigation buttons.

        If a self.go* attribute is null that corresponding button is
        replaced with a transparent gif to properly space the remaining
        buttons.
        """
	s = ''
	for item in self.navbar:
	    s = s + str (item) + '\n'
	return s

    def relurl (self, path1, path2):
	#print self.relurl, path1, path2
	if not path2:
	    return None
	
	if string.find (path2, '://') != -1:
	    return path2
	
	if path1[0] != '/':
	    path1 = os.path.abspath (path1)
	if path2[0] != '/':
	    path2 = os.path.abspath (path2)

	#print "relurl(%s,%s)" % (path1, path2)
	result = relpath (path1, path2)
	#print "relurl(%s,%s)->%s" % (path1, path2, result)
	return result

    def calc_rel_path(self, img, srcUrl):
	# filename contains a valid path to the image
	# srcUrl is the URL of the document which contains the image
	if srcUrl[0] != '/':
	    srcUrl = os.path.abspath (os.path.dirname (srcUrl))

	path2 = os.path.abspath (img.filename)
	
	#print srcUrl, path2
	newUrl = relpath (srcUrl, path2)
	#print newUrl

	img.src = newUrl

    def createNavBar (self):
        s = []
        if self.goprev: # place an image button for previous page
            btn = Image(self.prev, border=0, alt='Previous')
            link = Href(self.goprev, btn)
	    self.linksToFix.append (link)
            s.append(link)
        else: # place a blank gif as spacer
            btn = Image(self.blank)
            s.append(btn)
	self.imagesToFix.append (btn)
        if self.gonext: # place an image button for next page
            btn = Image(self.next, border=0, alt='Next')
            link = Href(self.gonext, btn)
	    self.linksToFix.append (link)
            s.append(link)
        else: # place a blank gif as spacer
            btn = Image(self.blank)
            s.append(btn)
	self.imagesToFix.append (btn)
        if self.gotop: # place an image button for top of manual page
            btn = Image(self.top, border=0, alt='Top of Manual')
            link = Href(self.gotop, btn)
	    self.linksToFix.append (link)
            s.append(link)
        else: # place a blank gif as spacer
            btn = Image(self.blank)
            s.append(btn)
	self.imagesToFix.append (btn)
        if self.gohome: # place an image button for site home page
            btn = Image(self.home, border=0, alt='Home Page')
            link = Href(self.gohome, btn)
	    self.linksToFix.append (link)
            s.append(link)
        else: # place a blank gif as spacer
            btn = Image(self.blank)
            s.append(btn)
	self.imagesToFix.append (btn)
        self.navbar = s

    def footer(self):
        """Generate the standard footer markups.
        """
        # FOOTER SECTION - overload this if you don't like mine.
        t = time.localtime(time.time())
        #self.datetime = time.strftime("%c %Z", t)    #not available in JPython
        self.datetime = time.asctime(t)
        #self.date = time.strftime("%A %B %d, %Y", t)
        x = string.split(self.datetime)
        self.date = x[0] + ' ' + x[1] + ' ' + x[2] + ', ' + x[4]
        s =  ['\n<P><HR>\n']
        if self.place_nav_buttons:
            s.append(self.nav_buttons())
	img = Image(self.logo, align='bottom')
	self.calc_rel_path (img, self.filename)
        s.append('<BR>' + str(img))
        s.append('''
<FONT SIZE="-1"><P>Amiga® is a trademark of Amiga Inc. All other trademarks belong to their respective owners.<BR>
<FONT SIZE="-1"><P>Copyright &#169 AROS - The Amiga Research OS<BR>
All Rights Reserved<BR>''')
        s.append('\nComments to webmaster: ' + str(MailTo(self.email)) )
        s.append('<br>\nGenerated: %s <BR>' % self.date) # can use self.datetime here instead
        s.append('<hr>\n</FONT>')
        return string.join(s, '')

    def write (self, filename):
	# For self.nav_buttons
	self.filename = filename

	# Create relative paths to other pages
	prev = next = top = None
	for j in range (len (mainLinks)):
	    links = mainLinks[j]
	    for i in range (len (links)):
		url = links[i].url
		pos = string.find (url, '#')
		if pos != -1:
		    url = url[:pos]
		if url == filename:
		    if i > 0:
			prev = links[i-1].url
		    else:
			# Wenn j==0 ist, dann wird die letzte Reihe
			# ausgewählt
			prev = mainLinks[j-1][-1].url

		    if i+1 < len (links):
			next = links[i+1].url
		    elif j+1 < len (mainLinks):
			next = mainLinks[j+1][0].url
		    else:
			next = mainLinks[0][0].url

		    top = links[0].url
		    break
	    if top:
		break
	
	path = os.path.abspath (os.path.dirname (filename))
	self.goprev = prev
	self.gonext = next
	self.gotop = top

	self.background = self.relurl (path, self.background)

	self.createNavBar ()

	for link in self.linksToFix:
	    #print link
	    link.url = self.relurl (path, link.url)
	    #print link

	for img in self.imagesToFix:
	    #print img
	    self.calc_rel_path (img, self.filename)
	    #print img

	# Convert myself into HTML
	SeriesDocument.write (self, filename)

parSep = re.compile ('\n\n+', re.MULTILINE)

class MyRawText (RawText):
    def __init__ (self, text):
	RawText.__init__ (self, parSep.sub ('<P>\n\n', text))

def genNews ():
    '''Create the news page (index.html, oldnews.html).'''

    def genPage (items, filename):
	'''Convert a list of news items into an HTML page and save
	it in filename. items must be a list of files with newsitems.
	The filenames must be dates in the form YYYYMMDD.'''

	def prepareNewsItem (filename):
	    '''Convert a single news item into HTML.'''

	    row = TR ()
	    td = TD (bgcolor='#80C0F0', valign='TOP')
	    row = row + [td]
	    str = os.path.basename (filename)
	    date = '%d.%d.%d' % (
		int (str[6:8]),
		int (str[4:6]),
		int (str[0:4]),
	    )
	    td = td + [Name (str), date]

	    td = TD (valign='TOP')
	    row = row + [td]

	    fh = open (filename, 'r')
	    body = fh.read ()
	    fh.close ()

	    td = td + [MyRawText (body)]
	    
	    return row
	    
	page = Page (linkBoxItem='NEWS')
	table = TableLite ()
	page.meat = page.meat + [table,]

	for file in items:
	    item = prepareNewsItem (file)
	    table.append (item)

	if filename == 'index.html':
	    p = Paragraph ()
	    p.append (Href ('oldnews.html', 'Older News'))
	    page.meat = page.meat + [p]

	page.write (filename)

    # Search all known news items, and sort them in reverse order
    list = glob.glob (os.path.join (datadir, 'news', '*'))
    list.remove (os.path.join (datadir, 'news', 'CVS'))
    list.sort ()
    list.reverse ()
    
    # Create a main page with the Top 5 news items and another page
    # with the rest.
    genPage (list[:5], 'index.html')
    genPage (list[5:], 'oldnews.html')

import barchart
class MyDataList (barchart.DataList):
    def sum_totals (self):
	# Totals are passed in
	pass

    def load_tuple (self, t):
	label, total, rest = t[0], t[1], t[2:]
	barchart.DataList.load_tuple (self, [label] + list (rest))
	self[-1]['total'] = total

class MyStackedBarChart (barchart.StackedBarChart):
    def initialize (self):
	barchart.StackedBarChart.initialize (self)
	self.colors = ('green', 'yellow', 'red')

def genStatus ():
    '''Create the status page. This page contains two images (jpg&png)
    with graphs of the sizes of repositories.'''

    import jobs, time

    page = Page (linkBoxItem='NEWS')
    body = []
    body.append (Heading (2, 'Status'))
    body.append (Paragraph (
	'This status was generated %s' % time.strftime ('%d. %B %Y',
	    time.localtime (time.time ()))
    ))

    keys = jobs.jobs.keys ()
    keys.sort ()
    data = []
    for key in keys:
	lib = jobs.jobs[key]
	data.append ((lib.longName,
	    lib.jobsTotal,
	    lib.status[2], lib.status[1], lib.status[0])
	)

    dataList = MyDataList ()
    dataList.segment_names = ('Done', 'In Work', 'Todo')
    dataList.load_tuples (data)
    dataList.sort ()
    chart = MyStackedBarChart (dataList)
    chart.label_shade = AQUA
    chart.title = 'AROS Status'
    
    body.append (chart)
    body.append (Heading (2, 'Size of AROS sources'))
    img = Image ('aros_size.png')
    page.imagesToFix.append (img)
    body.append (Paragraph (img))
    body.append (Paragraph (Href ('aros_size.jpg', 'Also as JPEG')))
    body.append (Heading (2, 'Size of contributed sources'))
    img = Image ('contrib_size.png')
    page.imagesToFix.append (img)
    body.append (Paragraph (img))
    body.append (Paragraph (Href ('contrib_size.jpg', 'Also as JPEG')))
    page.meat = page.meat + body
    page.write ('status.html')

    #from docs.src.credits import credits
    from credits import credits
    page = Page (linkBoxItem='NEWS')
    body = []
    body.append (Heading (2, 'Credits'))
    for area, names in credits:
	body.append (Heading (3, area))
	body.append (Paragraph (string.join (names, ', ')))
    page.meat = page.meat + body

    # Fix paths
    path = os.getcwd ()
    for color in chart.colors:
	colorFile = os.path.abspath (chart.barfiles[color])
	chart.barfiles[color] = page.relurl (path, colorFile)
	
    page.write ('credits.html')

def genDocumentation ():

    page = Page (linkBoxItem='Documentation')
    # Put the old docs here
    page.meat = page.meat + [Text ('Please choose a link to the left')]
    page.write ('documentation.html')

autodocdir = 'autodocs'
includedir = 'includes'
sourcedir = 'sources'

class AutoDocPage (Page):
    def __init__ (self, lib, func):
	Page.__init__ (self)
	
	self.filename = os.path.join (autodocdir,
	    '%s_%s.html' % (
		string.lower (lib.name),
		string.lower (func.name),
	    )
	)
	#self.absname = os.path.abspath (autodocdir)

#    def relurl (self, dest):
#	absdest = os.path.abspath (dest)
#	url = relpath (self.absname, absdest)
#	#print "AD::relurl(%s)->%s" % (dest, url)
#	return url

    def write (self):
	self.gotop = self.relurl (os.getcwd (),
	    os.path.join (autodocdir, 'index.html'))
	self.background = self.relurl (autodocdir, self.background)

	self.createNavBar ()

	for link in self.linksToFix:
	    #print link
	    link.url = self.relurl (autodocdir, link.url)
	    #print link

	for img in self.imagesToFix:
	    #print img
	    self.calc_rel_path (img, self.filename)
	    #print img

	SeriesDocument.write (self, self.filename)

class Dummy:
    def __init__ (self, list):
	self.list = list

    def __str__ (self):
	text = ''
	for item in self.list:
	    text = text + str (item)
	
	return text

class Nbsp:
    def __str__ (self):
	return '&nbsp;'

class AutoDocItem:
    def __init__ (self, contents):
	self.contents = contents

    def __str__ (self):
	if type (self.contents) == type ([]):
	    text = ''
	    for item in self.contents:
		text = text + str (item)
	elif type (self.contents) == type (''):
	    text = str (MyRawText (string.strip (self.contents)))
	else:
	    text = str (self.contents)
	
	text = text + '\n<P>\n'
	return text

class MyCode (Pre):
    pass

includePattern = re.compile (r'\s*#\s*include\s*<([^>]+)>')

def genAutodocs ():
    if not os.path.exists (autodocdir):
	os.makedirs (autodocdir)

    def genPage (db, lib, func):
	try:
	    page = AutoDocPage (lib, func)

	    page.title = 'AROS - %s/%s' % (lib.longName, func.name)

	    dl = DefinitionList ()
	    page.meat = page.meat + [dl]

	    list = []
	    hasIncludes = 0
	    for isLocal, line in func.header:
		#print isLocal, line
		if isLocal:
		    continue
		
		match = includePattern.match (line)
		if match:
		    include = match.group (1)
		    list.append (Text ('#include <'))
		    href = Href (
			os.path.join ('include', include),
			include
		    )
		    page.linksToFix.append (href)
		    list.append (href)
		    list.append (Text ('>'))
		    list.append (BR ())
		    hasIncludes = 1
	    
	    if hasIncludes:
		list.append (BR ())
	    
	    list.append (TT ('%s %s ()' % (func.result.type, func.name)))
	    list.append (BR ())
	    #list.append (Nbsp ())

	    dl.append (('NAME', AutoDocItem (list)))

	    list = []
	    for parameter in func.parameters:
		list.append (TT ('%s ' % parameter.type))
		list.append (Href ('#%s' % parameter.name, parameter.name))
		list.append (BR ())

	    dl.append (('SYNOPSIS', AutoDocItem (list)))

	    #print `func.section['FUNCTION']`
	    dl.append (('FUNCTION', AutoDocItem (func.section['FUNCTION'])))
	    parList = DefinitionList ()
	    for parameter in func.parameters:
		parList.append ((Dummy ([
			Name (parameter.name),
			parameter.name,
		    ]), parameter.explanation))
	    dl.append (('INPUTS', AutoDocItem (parList)))
	    dl.append (('RESULT', AutoDocItem (func.section['RESULT'])))
	    dl.append (('NOTES', AutoDocItem (func.section['NOTES'])))
	    dl.append (('EXAMPLE', AutoDocItem (MyCode (func.section['EXAMPLE']))))
	    dl.append (('BUGS', AutoDocItem (func.section['BUGS'])))

	    # Render SEE ALSO. The first item in the list is always
	    # the library
	    list = []
	    href = Href (
		os.path.join (autodocdir, 'index.html#%s' % lib.longName),
		lib.longName
	    )
	    page.linksToFix.append (href)
	    list.append (href)
	    dl.append (('SEE ALSO', AutoDocItem (list)))
	    
	    dl.append (('INTERNALS', AutoDocItem (func.section['INTERNALS'])))
	    dl.append (('HISTORY', AutoDocItem (func.section['HISTORY'])))

	    func.url = page.filename
	    page.write ()
	except:
	    print 'Error in %s/%s' % (lib.name, func.name)
	    raise
	
    import archtool

    archives = archtool.findArchives (
	    os.path.join (arosdir, 'rom'),
	    os.path.join (arosdir, 'workbench'),
	    os.path.join (arosdir, 'contrib'),
    )

    adocs = archtool.Archive (archives,
	postFunctionCB=genPage,
    )

    page = Page (linkBoxItem='Documentation')

    meat = []
    # --- Create table of libraries -----------------------------------------
    meat.append (Heading (1, 'Libraries sorted by Name'))

    list = []
    libs = adocs.libs.values ()
    libs.sort ()
    libAnchors = {}
    for lib in libs:
	key = string.upper (lib.longName[0])
	if not libAnchors.has_key (key):
	    libAnchors[key] = Href ('#%s' % lib.longName, 
		Font (key, size="-1")
	    )

    keys = libAnchors.keys ()
    keys.sort ()
    keylist = []
    for key in keys:
	keylist.append (libAnchors[key])
	keylist.append (Text (' '))
    meat.append (apply (Paragraph, keylist))

    # --- Create table of libraries -----------------------------------------
    meat.append (Name ('Functions sorted by Library'))
    meat.append (Heading (1, 'Functions sorted by Library'))

    for lib in libs:
	list.append (Font (
	    Href ('#%s' % lib.longName, lib.longName),
	    size="-1",
	))

    meat.append (NonBulletList (list))

    def processFuncList (funcs, meat):
	def makelibcell (func, absolute=os.path.abspath(autodocdir)):
	    return TD (
		Font (
		    Href (relpath (absolute, os.path.abspath (func.url)),
			func.name),
		    size="-1",
		),
		width="33%",
		align="LEFT",
	    )

	table = TableLite (
	    width="100%",
	    border="0",
	    cellspacing="0",
	    cellpadding="0",
	)
	meat.append (table)
	
	i, n = 0, len (funcs)
	while i < n:
	
	    left = funcs[i]
	    middle = right = None
	    if i+1 < n:
		middle = funcs[i+1]
	    if i+2 < n:
		right = funcs[i+2]
	    i = i + 3
	    
	    list = [makelibcell (left)]
	    if middle:
		list.append (makelibcell (middle))
	    if right:
		list.append (makelibcell (right))

	    row = TR ()
	    row = row + list
	    table.append (row)
	
    allFunctions = []

    for lib in libs:
	meat.append (Name (lib.longName))
	meat.append (Heading (2, lib.longName))

	funcs = lib.functions.values ()
	funcs.sort ()
	allFunctions = allFunctions + funcs

	processFuncList (funcs, meat)

    # --- Create table of functions -----------------------------------------
    meat.append (Heading (1, 'Functions sorted by Name'))
    
    allFunctions.sort ()
    funcAnchors = {}

    for func in allFunctions:
	key = string.upper (func.name[0])
	if not funcAnchors.has_key (key):
	    funcAnchors[key] = Href ('#%s' % func.name, 
		Font (key, size="-1")
	    )

    keys = funcAnchors.keys ()
    keys.sort ()
    keylist = []
    for key in keys:
	keylist.append (funcAnchors[key])
	keylist.append (Text (' '))
    meat.append (apply (Paragraph, keylist))

    key = ''
    list = []
    for func in allFunctions:
	if key != string.upper (func.name[0]):
	    if list:
		processFuncList (list, meat)
		list = []

	    key = string.upper (func.name[0])
	    meat.append (Name (func.name))
	    meat.append (Heading (2, key))
	
	list.append (func)

    if list:
	processFuncList (list, meat)

    page.meat = page.meat + meat
    page.write (os.path.join ('autodocs', 'index.html'))

class ThumbnailTable (TableLite):
    '''Helper class to create a table with thumbnails.'''

    def __init__ (self, *pics):
	width = "80%"
	itemwidth = 'width="40%"'

	TableLite.__init__ (self,
	    border="0",
	    width=width,
	    align="center",
	    bgcolor="#000066",
	    cellpadding=0,
	    cellspacing=0,
	)
	row = TR ()
	self.append (row)
	td = TD ()
	row = row + [td]
	table2 = TableLite (
	    border="0",
	    width="100%",
	    align="center",
	    bgcolor="#000066",
	    cellpadding=5,
	    cellspacing=2,
	)
	td = td + [table2]

	if (len (pics) & 1) == 1:
	    pics = list (pics) + [None]
	i, n = 0, len (pics)
	while i < n:
	    row = TR (bgcolor="#000066")
	    left, right = pics[i], pics[i+1]
	    i = i + 2
	    left = left.toHtml ()
	    #print left[1]
	    left[1].attr_dict['width'] = itemwidth
	    #print dir (left[1])
	    #print left[1].attr_dict
	    if not right:
		td = TD (colspan="2", bgcolor="#CCCCCC", width="50%")
		td = td + [Nbsp ()]
		right = [td]
	    else:
		right = right.toHtml ()
		right[1].attr_dict['width'] = itemwidth
	    row = row + left + right
	    
	    table2.append (row)

def genScreenshots ():
    '''Create a page with screenshots.'''

    page = Page (linkBoxItem='Screenshots')

    # First, the pictures of AROS developers, etc.
    tn1 = Thumbnail ('pics/developers/Digulla-2.jpg')
    tn2 = Thumbnail ('pics/developers/Digulla-1.jpg')
    tn3 = Thumbnail ('pics/developers/nlorentz.jpg')
    page.meat = page.meat + [
	Name ('Pictures around AROS'),
	Heading (2, 'Pictures around AROS'),
	Paragraph ('If you ever wanted to know what Aaron "Optimizer" Digulla'
	    ' looks like, here are two pictures:'),
	ThumbnailTable (tn1, tn2),
	Paragraph ('Picture of Nils Henrik Lorentzen:'),
	ThumbnailTable (tn3),
	Paragraph ('Hopefully, more pictures of AROS developers will'
	    ' show up here :-)'),
	Name ('Screenshots'),
	Heading (2, 'Screenshots'),
    ]

    page.linksToFix.append (tn1.href)
    page.imagesToFix.append (tn1.img)
    page.linksToFix.append (tn2.href)
    page.imagesToFix.append (tn2.img)
    page.linksToFix.append (tn3.href)
    page.imagesToFix.append (tn3.img)

    def processDir (dir, page=page):
	'''Read a directory and put all pictures in it into ThumbnailTables.
	The name of the directory must be YYYYMMDD.'''
	str = os.path.basename (dir)
	date = '%d.%d.%d' % (
	    int (str[6:8]),
	    int (str[4:6]),
	    int (str[0:4]),
	)
	fh = open (os.path.join (dir, 'README'), 'r')
	text = fh.read ()
	fh.close ()
	
	list = [
	    Paragraph (RawText ('%s - %s' % (date, text))),
	]
	files = glob.glob (os.path.join (dir, "*.*"))
	files.sort ()
	pics = []
	for file in files:
	    if file[-4:] == '.txt' or string.find (file, '_mini.') != -1:
		continue

	    tn = Thumbnail (
		os.path.join (
		    screenshoturl,
		    str,
		    os.path.basename (file)
		)
	    )
	    pics.append (tn)
	    page.linksToFix.append (tn.href)
	    page.imagesToFix.append (tn.img)
	
	list.append (apply (ThumbnailTable, pics))
	return list
	    
    # Read all screenshots and sort them by date.
    dirs = glob.glob (os.path.join (screenshoturl, '[0-9]*'))
    dirs.sort ()
    dirs.reverse ()
    for dir in dirs:
	page.meat = page.meat + processDir (dir)

    page.write ('screenshots.html')

def genDownload ():
    page = Page (linkBoxItem='Download')
    # Create the page for downloads
    page.meat = page.meat + [Text ('Please choose a link to the left.')]
    page.write ('download.html')

class FileInfo:
    '''Helper class which stores some useful information about a file,
    namely it's size (nicely formatted), the filename and the path
    to the file.
    
    self.filename - Name of the file (last element in the path)
    self.path - Full path to the file (might be relative)
    self.size - Nicely formatted size
    '''

    def __init__ (self, path):
	filename = os.path.basename (path)
	self.filename, self.path = filename, path

	size = os.path.getsize (path)

	if size > 1024:
	    size = ((size+1023) / 1024)
	    self.size = '%dKB' % size
	    if size > 1024:
		size = ((size+1023) / 1024)
		self.size = '%dMB' % size

class Snapshot (FileInfo):
    '''Helper class to store information about a snapshot. This is derived
    from the FileInfo class and contains this additional info:

    self.ext - Extension of the file
    self.date - Creation date (derived from the filename)
    self.title - Middle part of the filename
    self.log - FileInfo object about the logfile which belongs to
	    this snapshot or None.
    '''
    
    def __init__ (self, path):
	'''path must be a snapshot (Format:
	AROS-%(title)s-%(date)s.%(ext)s).'''
	FileInfo.__init__ (self, path)

	filename = self.filename
	self.ext = filename[-3:]
	filename = filename[:-4]
	self.date = filename[-8:]
	filename = filename[:-8]
	self.title = filename[5:-1]
	
	logfile = path[:-3] + 'log'
	if os.path.exists (logfile):
	    self.log = FileInfo (logfile)
	else:
	    self.log = None
	#print self.__dict__

class Thumbnail (FileInfo):
    '''Helper class for thumbnails. Pass it the name of a picture and
    it will contain FileInfo plus:

    self.width, self.height - Size of the picture
    self.format - Format of the file (GIF, JPEG, PNG, ...)
    self.thumbnailURL - URL of the thumbnail picture

    The thumbnail of the picture is created with ImageMagick if it
    doesn't exist or if it is outdated (the picture is newer).'''
    def __init__ (self, url):
	path = os.path.join (htmldir, url)
	FileInfo.__init__ (self, path)

	self.url = url
	pic = _Image.open (path)
	self.width, self.height = pic.size
	self.format = pic.format

	pos = string.rfind (url, '.')
	self.thumbnailURL = url[:pos] + '_mini.jpg'
	pos = string.rfind (path, '.')
	thumbnailPath = path[:pos] + '_mini.jpg'
	picMTime = os.path.getmtime (path)
	if os.path.exists (thumbnailPath):
	    tnMTime = os.path.getmtime (thumbnailPath)
	else:
	    tnMTime = 0
	if tnMTime < picMTime:
	    # Convert if ImageMagick is available
	    if convert:
		cmd = '%s -geometry "64x128>" -quality 100 "%s" "%s"' % (
		    convert, path, thumbnailPath
		)
		#print cmd
		os.system (cmd)
		os.chmod (path, 0644)

	infoFile = path[:pos] + '.txt'
	if os.path.exists (infoFile):
	    fh = open (infoFile)
	    self.text = fh.read ()
	    fh.close ()
	else:
	    self.text = ''

	self.img = Image (self.thumbnailURL)
	self.href = Href (self.url, self.img)

    def toHtml (self):
	'''Convert this into HTML code.'''
	return [
	    TD (
		self.href,
		width="64",
		valign="TOP",
		bgcolor="#CCCCCC",
	    ),
	    TD (
		Paragraph (RawText (self.text)),
		Font (Text ('%s %dx%d (%s)' % (
		    self.format,
		    self.width, self.height,
		    self.size,
		)), size="-1"),
		#width="35%",
		valign="TOP",
		bgcolor="#CCCCCC",
	    ),
	]

def genSnapshots ():
    '''Create the page with the snapshots with sizes and links for
    download.'''
    page = Page (linkBoxItem='Download')

    files = glob.glob (os.path.join (ftpdir, 'snapshots/*.tgz'))
    if not files:
        page.meat = page.meat + [Text ('No snapshots found')]
    else:
	dict = {}
	columns = {}
	days = {}

	for file in files:
	    ss = Snapshot (file)
	    day = dict.get (ss.date, None)
	    if not day:
		day = {}
		dict[ss.date] = day
	    if ss.ext != 'tgz':
		print 'Unknown Snapshot', file
		continue

	    day[ss.title] = ss
	    columns[ss.title] = None
	    days[ss.date] = None
	
	table = TableLite (cellpadding=15, border=2)
	page.meat = page.meat + [table]
	
	colList = columns.keys ()
	colList.sort ()
	row = TR ()
	table.append (row)
	td = TH ('Date')
	row = row + [td]
	    
	for col in colList:
	    td = TH (col)
	    row = row + [td]
	
	dateList = days.keys ()
	dateList.sort ()
	dateList.reverse ()
	for date in dateList:
	    row = TR ()
	    table.append (row)

	    str = '%d.%d.%d' % (
		int (date[6:8]),
		int (date[4:6]),
		int (date[0:4]),
	    )
	    row = row + [TD (str)]

	    day = dict.get (date, {})

	    for col in colList:
		t = Text ()
		ss = day.get (col, None)
		if ss:
		    t.append (Href ('ftp://ftp.aros.org/pub/aros/snapshots/%s' % ss.filename,
			ss.size
		    ))
		
		    if ss.log:
			t.append ('(Log: ')
			t.append (Href (
			    'ftp://ftp.aros.org/pub/aros/snapshots/%s' % \
				ss.log.filename,
			    ss.log.size
			))
			t.append (')')
		    else:
			if not ss.title in ('contrib', 'source'):
			    t.append ('(No log)')
		else:
		    t.append ('-')

		row = row + [TD (t)]

    page.write ('snapshots.html')

def processLinks (links):
    list = List ()

    for link in links:
	if type (link) == type (()):
	    link, children = link[0], link[1:]
	else:
	    children = None

	text = Text (link.href)
	if link.text:
	    if type (link.text) == type (()):
		t = Text ()
		for item in link.text:
		    t.append (item)
	    else:
		t = Text (link.text)
	    text.append (t)
	if link.logo:
	    text.append (Image ((link.logo, 0,0)))

	list.append (text)
	
	if children:
	    sublist = processLinks (children)
	    list.append (sublist)
    
    return list

def genLinks ():
    '''Create a page with links from links.py.'''
    def processSection (links, title):
	body = []

	#print title, list

	body.append (Name (title))
	body.append (Heading (2, title))
	list = processLinks (links)
	body.append (list)

	return body

    page = Page (linkBoxItem='Links')

    from links import moreRelated, articles, homepages, lessRelated

    page.meat = page.meat \
	+ processSection (moreRelated, 'More Related') \
	+ processSection (articles, 'Articles') \
	+ processSection (homepages, 'Homepages') \
	+ processSection (lessRelated, 'Less Related')

    page.write ('links.html')

import xmlsupport

def writeVerbatim (p, xmlfile, item):
    if isinstance (item, xmlsupport.Tag):
	# Give a hint if a tag might be unsupported
	if not item.name in ('p', 'ul', 'li', 'strong', 'i', 'a',):
	    print item.name
	p.fh.write ('<%s' % item.name)
	for attr, value in item.attr.items ():
	    p.fh.write (' %s="%s"' % (attr, value))
	p.fh.write ('>')
	xmlfile.processRecursive (p, item.content)
	p.fh.write ('</%s>' % item.name)
    else:
	p.fh.write (item.text)

def chapterToHtml (p, xmlfile, item):
    p.fh.write (str (Heading (1, item.attr['title'])))
    xmlfile.processRecursive (p, item.content)

def sectionToHtml (p, xmlfile, item):
    p.fh.write (str (Heading (2, item.attr['title'])))
    xmlfile.processRecursive (p, item.content)

def emailToHtml (p, xmlfile, item):
    email = item.content[0].text
    p.fh.write ('<A HREF="mailto:%s">%s</A>' % (email, email))
    subject = item.attr.get ('subject', None)
    if subject:
	p.fh.write (' with the subject "%s"' % subject)
    body = item.attr.get ('body', None)
    if body:
	if subject:
	    p.fh.write (' and')
	p.fh.write ('"%s" in the body' % body)

def exampleToHtml (p, xmlfile, item):
    outerTable = TableLite (
	border="0",
	width="804",
	#align="left",
	bgcolor="#000066",
	cellpadding=2,
	cellspacing=0,
    )
    row = TR ()
    outerTable.append (row)
    td = TD ()
    row = row + [td]
    table = TableLite (
	border="0",
	width="800",
	#align="left",
	bgcolor="#CCCCCC",
	cellpadding=2,
	cellspacing=0,
    )
    td = td + [table]
    oldFH = p.fh
    for line in item.content:
	if not isinstance (line, xmlsupport.Tag) or line.name != 'line':
	    continue
	
	row = TR ()
	table.append (row)
	td = TD ()
	row = row + [td]

	if line.content:
	    p.fh = cStringIO.StringIO ()
	    xmlfile.processRecursive (p, line.content)
	    td = td + [RawText (p.fh.getvalue ())]
	    p.fh.close ()
	else:
	    td = td + [RawText ('&nbsp;')]
    p.fh = oldFH
    p.fh.write (str (outerTable))

def userToHtml (p, xmlfile, item):
    p.fh.write ('<strong><i>')
    xmlfile.processRecursive (p, item.content)
    p.fh.write ('</i></strong>')
    
def shellToHtml (p, xmlfile, item):
    p.fh.write ('<tt>')
    xmlfile.processRecursive (p, item.content)
    p.fh.write ('</tt>')
    
def filenameToHtml (p, xmlfile, item):
    p.fh.write ('<tt>')
    xmlfile.processRecursive (p, item.content)
    p.fh.write ('</tt>')

def descriptionToHtml (p, xmlfile, item):
    p.fh.write ('<p><dl>\n')
    for line in item.content:
	if not isinstance (line, xmlsupport.Tag) or line.name != 'li':
	    continue
	
	itemTitle = line.content[0]
	if not isinstance (itemTitle, xmlsupport.Tag) or itemTitle.name != 'item':
	    line.dump (0)
	    raise 'Expected "item"'
	
	p.fh.write ('<dt>')
	xmlfile.processRecursive (p, itemTitle.content)
	p.fh.write ('</dt>\n<dd>')
	xmlfile.processRecursive (p, line.content[1:])
	p.fh.write ('<dd>\n')

    p.fh.write ('</dl></p>\n')

class Developer:
    def __init__ (self, login, name, email):
	self.login, self.name, self.email = login, name, email

class Developers:
    def __init__ (self):
	self.developers = []
	self.login = {}

	filename = os.path.join (cvsrootdir, 'passwd.txt')
	fh = open (filename)
	for line in fh.readlines ():
	    line = string.strip (line)
	    if not line or line[0] == '#':
		continue
	    words = string.split (line, ':')
	    
	    dev = Developer (words[0], words[2], words[3])
	    self.developers.append (dev)
	    self.login[dev.login] = dev

extraInfo = {
    'devlist': 'TODO',
}

def insertHtml (p, xmlfile, item):
    text = item.content[0].text

    if text == 'devlist':
	developers = Developers ()
	p.fh.write ('<ul>\n')
	for dev in developers.developers:
	    p.fh.write ('<li>%s</li>\n' % (dev.name))
	p.fh.write ('</ul>')
    else:
	print 'Inserting',item.content[0].text
	p.fh.write (p.extraInfo[item.content[0].text])


class XmlPage (Page):
    def __init__ (self, xmlfilename, rcFile=arosRC, linkBoxItem='', **kw):
	apply (Page.__init__, (self, rcFile, linkBoxItem,), kw)

	xmlfile = xmlsupport.XmlFile (xmlfilename)

	XML2HTML = xmlsupport.Processor ()
        XML2HTML.fh = cStringIO.StringIO ()
	XML2HTML.setDefault (writeVerbatim)
	XML2HTML.add ('chapter', chapterToHtml)
	XML2HTML.add ('section', sectionToHtml)
	XML2HTML.add ('email', emailToHtml)
	XML2HTML.add ('insert', insertHtml)
	XML2HTML.add ('example', exampleToHtml)
	XML2HTML.add ('user', userToHtml)
	XML2HTML.add ('shell', shellToHtml)
	XML2HTML.add ('filename', filenameToHtml)
	XML2HTML.add ('description', descriptionToHtml)
	XML2HTML.extraInfo = extraInfo

	xmlfile.process (XML2HTML)
	self.meat = self.meat + [RawText (XML2HTML.fh.getvalue ())]
	XML2HTML.fh.close ()

# Call all generators in turn
genNews ()
genStatus ()
genDocumentation ()
page = XmlPage (os.path.join (datadir, 'background.xml'),
    linkBoxItem='Documentation',
)
page.write ('background.html')
page = XmlPage (os.path.join (datadir, 'cvs.xml'),
    linkBoxItem='Documentation',
)
page.write ('cvs.html')
page = XmlPage (os.path.join (datadir, 'mmake.xml'),
    linkBoxItem='Documentation',
)
page.write ('mmake.html')
genAutodocs ()
genScreenshots ()
genDownload ()
genSnapshots ()
genLinks ()
