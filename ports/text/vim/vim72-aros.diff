diff -Naur vim72-orig/src/edit.c vim72/src/edit.c
--- vim72-orig/src/edit.c	2015-04-26 10:11:05.166298471 +0200
+++ vim72/src/edit.c	2015-04-26 10:12:03.584828227 +0200
@@ -675,7 +675,7 @@
 	}
 
 	/* May need to adjust w_topline to show the cursor. */
-	update_topline();
+	update_topline(TRUE);
 
 	did_backspace = FALSE;
 
@@ -1537,7 +1537,7 @@
 
     if (ScreenLines != NULL)
     {
-	update_topline();	/* just in case w_topline isn't valid */
+	update_topline(TRUE);	/* just in case w_topline isn't valid */
 	validate_cursor();
 	if (highlight)
 	    attr = hl_attr(HLF_8);
@@ -5977,7 +5977,7 @@
 
     if (!format_only && haveto_redraw)
     {
-	update_topline();
+	update_topline(TRUE);
 	redraw_curbuf_later(VALID);
     }
 }
@@ -6720,7 +6720,7 @@
     coladvance(curwin->w_curswant);
 
     if (upd_topline)
-	update_topline();	/* make sure curwin->w_topline is valid */
+	update_topline(TRUE);	/* make sure curwin->w_topline is valid */
 
     return OK;
 }
@@ -6779,7 +6779,7 @@
     coladvance(curwin->w_curswant);
 
     if (upd_topline)
-	update_topline();	/* make sure curwin->w_topline is valid */
+	update_topline(TRUE);	/* make sure curwin->w_topline is valid */
 
     return OK;
 }
diff -Naur vim72-orig/src/eval.c vim72/src/eval.c
--- vim72-orig/src/eval.c	2015-04-26 10:11:05.165298479 +0200
+++ vim72/src/eval.c	2015-04-26 10:12:03.584828227 +0200
@@ -18,7 +18,7 @@
 
 #if defined(FEAT_EVAL) || defined(PROTO)
 
-#ifdef AMIGA
+#ifdef AROS
 # include <time.h>	/* for strftime() */
 #endif
 
@@ -7890,7 +7890,9 @@
     dict_T	*selfdict;	/* Dictionary for "self" */
 {
     int		ret = FAIL;
+#ifndef AROS
 #define ERROR_UNKNOWN	0
+#endif
 #define ERROR_TOOMANY	1
 #define ERROR_TOOFEW	2
 #define ERROR_SCRIPT	3
@@ -10730,12 +10732,12 @@
 	{
 	    name = get_tv_string(&argvars[0]);
 	    if (STRCMP(name, "*") == 0)	    /* don't use font dialog */
-		return;
+            return;
 	    font = gui_mch_get_font(name, FALSE);
 	    if (font == NOFONT)
-		return;	    /* Invalid font name, return empty string. */
+            return;	    /* Invalid font name, return empty string. */
 	}
-	rettv->vval.v_string = gui_mch_get_fontname(font, name);
+	rettv->vval.v_string = (unsigned char *) gui_mch_get_fontname(font, (char *) name);
 	if (argvars[0].v_type != VAR_UNKNOWN)
 	    gui_mch_free_font(font);
     }
@@ -11324,11 +11326,11 @@
     int		n = FALSE;
     static char	*(has_list[]) =
     {
-#ifdef AMIGA
-	"amiga",
-# ifdef FEAT_ARP
-	"arp",
-# endif
+#if defined(AMIGA) || defined(AROS)
+    "amiga",
+#endif
+#ifdef AROS
+    "aros",
 #endif
 #ifdef __BEOS__
 	"beos",
@@ -17692,7 +17694,7 @@
 	pos.col = 0;
 	if (name[1] == '0')		/* "w0": first visible line */
 	{
-	    update_topline();
+	    update_topline(TRUE);
 	    pos.lnum = curwin->w_topline;
 	    return &pos;
 	}
diff -Naur vim72-orig/src/ex_cmds2.c vim72/src/ex_cmds2.c
--- vim72-orig/src/ex_cmds2.c	2015-04-26 10:11:05.169298447 +0200
+++ vim72/src/ex_cmds2.c	2015-04-26 10:12:03.584828227 +0200
@@ -2595,7 +2595,7 @@
     char_u	**files;
     int		i;
     int		did_one = FALSE;
-#ifdef AMIGA
+#if defined(AMIGA) || defined(AROS)
     struct Process	*proc = (struct Process *)FindTask(0L);
     APTR		save_winptr = proc->pr_WindowPtr;
 
@@ -2669,7 +2669,7 @@
 	verbose_leave();
     }
 
-#ifdef AMIGA
+#if defined(AMIGA) || defined(AROS)
     proc->pr_WindowPtr = save_winptr;
 #endif
 
diff -Naur vim72-orig/src/ex_cmds.c vim72/src/ex_cmds.c
--- vim72-orig/src/ex_cmds.c	2015-04-26 10:11:05.164298487 +0200
+++ vim72/src/ex_cmds.c	2015-04-26 10:12:03.584828227 +0200
@@ -1468,7 +1468,7 @@
 	    save_nwr = no_wait_return;
 	    if (swapping_screen())
 		no_wait_return = FALSE;
-# ifdef AMIGA
+# ifdef AROS
 	    wait_return(term_console ? -1 : msg_silent == 0);	/* see below */
 # else
 	    wait_return(msg_silent == 0);
@@ -1483,13 +1483,13 @@
 	    starttermcap();	/* start termcap if not done by wait_return() */
 
 	/*
-	 * In an Amiga window redrawing is caused by asking the window size.
+	 * In an AROS window redrawing is caused by asking the window size.
 	 * If we got an interrupt this will not work. The chance that the
 	 * window size is wrong is very small, but we need to redraw the
 	 * screen.  Don't do this if ':' hit in wait_return().	THIS IS UGLY
 	 * but it saves an extra redraw.
 	 */
-#ifdef AMIGA
+#ifdef AROS
 	if (skip_redraw)		/* ':' hit in wait_return() */
 	{
 	    if (msg_silent == 0)
@@ -3783,7 +3783,7 @@
 	n = p_so;
 	if (topline == 0 && command == NULL)
 	    p_so = 999;			/* force cursor halfway the window */
-	update_topline();
+	update_topline(TRUE);
 #ifdef FEAT_SCROLLBIND
 	curwin->w_scbind_pos = curwin->w_topline;
 #endif
@@ -4676,7 +4676,7 @@
 			    search_match_endcol = regmatch.endpos[0].col;
 			    highlight_match = TRUE;
 
-			    update_topline();
+			    update_topline(TRUE);
 			    validate_cursor();
 			    update_screen(SOME_VALID);
 			    highlight_match = FALSE;
diff -Naur vim72-orig/src/ex_docmd.c vim72/src/ex_docmd.c
--- vim72-orig/src/ex_docmd.c	2015-04-26 10:11:05.170298439 +0200
+++ vim72/src/ex_docmd.c	2015-04-26 10:12:03.584828227 +0200
@@ -8527,7 +8527,7 @@
 
     RedrawingDisabled = 0;
     p_lz = FALSE;
-    update_topline();
+    update_topline(TRUE);
     update_screen(eap->forceit ? CLEAR :
 #ifdef FEAT_VISUAL
 	    VIsual_active ? INVERTED :
@@ -8892,7 +8892,7 @@
 update_topline_cursor()
 {
     check_cursor();		/* put cursor on valid line */
-    update_topline();
+    update_topline(TRUE);
     if (!curwin->w_p_wrap)
 	validate_cursor();
     update_curswant();
@@ -10617,7 +10617,7 @@
 	    else if (vim_ispathsep(*p))
 	    {
 		*s++ = '=';
-#if defined(BACKSLASH_IN_FILENAME) || defined(AMIGA) || defined(RISCOS) \
+#if defined(BACKSLASH_IN_FILENAME) || defined(AMIGA) || defined(AROS) || defined(RISCOS) \
 	|| defined(VMS)
 		if (*p == ':')
 		    *s++ = '-';
diff -Naur vim72-orig/src/ex_getln.c vim72/src/ex_getln.c
--- vim72-orig/src/ex_getln.c	2015-04-26 10:11:05.164298487 +0200
+++ vim72/src/ex_getln.c	2015-04-26 10:12:03.584828227 +0200
@@ -1769,7 +1769,7 @@
 # endif
 	    curwin->w_botline = old_botline;
 	    changed_cline_bef_curs();
-	    update_topline();
+	    update_topline(TRUE);
 
 	    if (i != 0)
 	    {
diff -Naur vim72-orig/src/feature.h vim72/src/feature.h
--- vim72-orig/src/feature.h	2015-04-26 10:11:05.169298447 +0200
+++ vim72/src/feature.h	2015-04-26 10:12:03.585828220 +0200
@@ -60,7 +60,8 @@
  */
 #if !defined(FEAT_TINY) && !defined(FEAT_SMALL) && !defined(FEAT_NORMAL) \
 	&& !defined(FEAT_BIG) && !defined(FEAT_HUGE)
-# if defined(MSWIN) || defined(DJGPP) || defined(OS2) || defined(VMS) || defined(MACOS) || defined(AMIGA)
+# if defined(MSWIN) || defined(DJGPP) || defined(OS2) || defined(VMS) || \
+     defined(MACOS) || defined(AROS) || defined(AMIGA)
 #  define FEAT_BIG
 # else
 #  ifdef MSDOS
@@ -431,7 +432,7 @@
  * +postscript		Printing uses PostScript file output.
  */
 #if defined(FEAT_NORMAL) && (defined(MSWIN) || defined(FEAT_EVAL)) \
-	&& !defined(AMIGA)
+	&& !defined(AMIGA) && !defined(AROS)
 # define FEAT_PRINTER
 #endif
 #if defined(FEAT_PRINTER) && ((defined(MSWIN) && defined(MSWINPS)) \
@@ -1019,7 +1020,7 @@
  * +mouse		Any mouse support (any of the above enabled).
  */
 /* OS/2 and Amiga console have no mouse support */
-#if !defined(AMIGA) && !defined(OS2)
+#if !defined(AMIGA) && !defined(AROS) && !defined(OS2)
 # ifdef FEAT_NORMAL
 #  define FEAT_MOUSE_XTERM
 # endif
diff -Naur vim72-orig/src/fileio.c vim72/src/fileio.c
--- vim72-orig/src/fileio.c	2015-04-26 10:11:05.167298463 +0200
+++ vim72/src/fileio.c	2015-04-26 10:12:03.585828220 +0200
@@ -6099,7 +6099,7 @@
     int		n;
     char	*errmsg = NULL;
     char	*buffer;
-#ifdef AMIGA
+#if defined(AMIGA) || defined(AROS)
     BPTR	flock;
 #endif
     struct stat	st;
@@ -6126,7 +6126,7 @@
      * two files when the mch_rename() fails.
      */
 
-#ifdef AMIGA
+#if defined(AMIGA) || defined(AROS)
     /*
      * With MSDOS-compatible filesystems (crossdos, messydos) it is possible
      * that the name of the "to" file is the same as the "from" file, even
@@ -6143,9 +6143,9 @@
     flock = Lock((UBYTE *)from, (long)ACCESS_READ);
 #endif
     mch_remove(to);
-#ifdef AMIGA
+#if defined(AMIGA) || defined(AROS)
     if (flock)
-	UnLock(flock);
+        UnLock(flock);
 #endif
 
     /*
@@ -6726,7 +6726,7 @@
 	    curwin->w_topline = old_topline;
 	curwin->w_cursor = old_cursor;
 	check_cursor();
-	update_topline();
+	update_topline(TRUE);
 #ifdef FEAT_AUTOCMD
 	keep_filetype = FALSE;
 #endif
diff -Naur vim72-orig/src/getchar.c vim72/src/getchar.c
--- vim72-orig/src/getchar.c	2015-04-26 10:11:05.169298447 +0200
+++ vim72/src/getchar.c	2015-04-26 10:12:03.585828220 +0200
@@ -2275,7 +2275,7 @@
 			    keylen = 0;
 			if (keylen == 0)	/* no matching terminal code */
 			{
-#ifdef AMIGA			/* check for window bounds report */
+#if defined(AMIGA) || defined(AROS)			/* check for window bounds report */
 			    if (typebuf.tb_maplen == 0 && (typebuf.tb_buf[
 					       typebuf.tb_off] & 0xff) == CSI)
 			    {
diff -Naur vim72-orig/src/globals.h vim72/src/globals.h
--- vim72-orig/src/globals.h	2015-04-26 10:11:05.170298439 +0200
+++ vim72/src/globals.h	2015-04-26 10:12:03.585828220 +0200
@@ -1481,7 +1481,7 @@
 EXTERN char_u e_sandbox[]	INIT(= N_("E48: Not allowed in sandbox"));
 #endif
 EXTERN char_u e_secure[]	INIT(= N_("E523: Not allowed here"));
-#if defined(AMIGA) || defined(MACOS) || defined(MSWIN) || defined(RISCOS) \
+#if defined(AMIGA) || defined(AROS) || defined(MACOS) || defined(MSWIN) || defined(RISCOS) \
 	|| defined(UNIX) || defined(VMS) || defined(OS2)
 EXTERN char_u e_screenmode[]	INIT(= N_("E359: Screen mode setting not supported"));
 #endif
diff -Naur vim72-orig/src/gui_aros.c vim72/src/gui_aros.c
--- vim72-orig/src/gui_aros.c	1970-01-01 01:00:00.000000000 +0100
+++ vim72/src/gui_aros.c	2015-04-26 23:58:38.914346282 +0200
@@ -0,0 +1,2533 @@
+/* vi:set ts=8 sts=4 sw=4:
+ *
+ * VIM - Vi IMproved by Bram Moolenaar
+ * AROS UI support by Franck Charlet
+ *
+ * Do ":help uganda"  in Vim to read copying and usage conditions.
+ * Do ":help credits" in Vim to see a list of people who contributed.
+ * See README.txt for an overview of the Vim source code.
+ */
+
+// TODO: - Create a mode to scroll without moving the caret (for the scrollbars).
+//       - See to handle different font.
+
+#include <proto/intuition.h>
+#include <proto/graphics.h>
+#include <proto/layers.h>
+#include <proto/diskfont.h>
+#include <proto/gadtools.h>
+
+#include <exec/types.h>
+#include <intuition/intuition.h>
+#include <intuition/gadgetclass.h>
+#include <utility/tagitem.h>
+#include <graphics/text.h>
+#include <graphics/rastport.h>
+#include <graphics/layers.h>
+#include <devices/timer.h>
+#include <intuition/extensions.h>
+#include <graphics/text.h>
+
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+#include <limits.h>
+#include <assert.h>
+
+#include "vim.h"
+#include "gui_aros.h"
+
+#define DEBUG 10
+#include <aros/debug.h>
+#include <devices/rawkeycodes.h>
+
+#define GUI_MCH_NBR_MENUS 8192
+
+#ifdef FEAT_ASL
+#include <proto/asl.h>
+#endif
+
+#include "version.h"
+
+#define RGB(a, b, c) ((a && 0xff) * 0x10000 + (b * 0xff) * 0x100 + (c & 0xff))
+
+/* When generating prototypes on Unix, these need to be defined */
+#ifdef PROTO
+# define STRPTR char *
+# define BOOL int
+# define UBYTE int
+#endif
+
+#define IDCMP ( IDCMP_NEWSIZE | IDCMP_MOUSEBUTTONS | IDCMP_MOUSEMOVE \
+                | IDCMP_MENUPICK | IDCMP_MENUHELP | IDCMP_CLOSEWINDOW | IDCMP_RAWKEY \
+                | IDCMP_VANILLAKEY | IDCMP_ACTIVEWINDOW | IDCMP_GADGETDOWN | IDCMP_GADGETUP \
+                | IDCMP_INACTIVEWINDOW | IDCMP_GADGETHELP | IDCMP_INTUITICKS | IDCMP_REFRESHWINDOW)
+
+#define WFLAGS ( WFLG_REPORTMOUSE | WFLG_ACTIVATE | WFLG_SMART_REFRESH )
+
+static struct timerequest *TimerIO;
+static struct MsgPort *TimerMP;
+static BOOL	TimerSent;
+
+#if 0
+struct GFXBase *gfxBase;
+struct ExecBase *SysBase;
+struct LayersBase *layersBase;
+struct Library *DiskfontBase;
+#endif
+struct NewMenu *menuPtr;
+
+int cur_menu_nbr;
+
+#ifdef FEAT_ASL
+static struct FileRequester *file_req;
+#endif
+
+ULONG Last_Seconds;
+ULONG Last_Micros;
+
+struct MyColor
+{
+    WORD pen;
+    BOOL alloced;
+};
+
+/*
+ * Get color handle for color "name".
+ * Return INVALCOLOR when not possible.
+ */
+
+typedef struct guicolor_tTable
+{
+    char *name;
+    UBYTE red;
+    UBYTE green;
+    UBYTE blue;
+    char allocated;
+} guicolor_tTable;
+
+static guicolor_tTable table[2048] =
+{
+ 	{ "Grey", 0xbe,0xbe,0xbe},
+	{ "Black", 0x00, 0x00, 0x00},
+    { "LightRed", 0xff, 0x00, 0x00, 0 },
+    { "LightMagenta", 0xff, 0x00, 0xff, 0 },
+    { "grey40", 0x66, 0x66, 0x66, 0 },
+    { "alice", 0xf0, 0xf8, 0xff, 0 },
+    { "aliceblue", 0xf0, 0xf8, 0xff, 0 },
+    { "antique", 0xfa, 0xeb, 0xd7, 0 },
+    { "antiquewhite", 0xfa, 0xeb, 0xd7, 0 },
+    { "antiquewhite1", 0xff, 0xef, 0xdb, 0 },
+    { "antiquewhite2", 0xee, 0xdf, 0xcc, 0 },
+    { "antiquewhite3", 0xcd, 0xc0, 0xb0, 0 },
+    { "antiquewhite4", 0x8b, 0x83, 0x78, 0 },
+    { "aquamarine", 0x7f, 0xff, 0xd4, 0 },
+    { "aquamarine1", 0x7f, 0xff, 0xd4, 0 },
+    { "aquamarine2", 0x76, 0xee, 0xc6, 0 },
+    { "aquamarine3", 0x66, 0xcd, 0xaa, 0 },
+    { "aquamarine4", 0x45, 0x8b, 0x74, 0 },
+    { "azure", 0xf0, 0xff, 0xff, 0 },
+    { "azure1", 0xf0, 0xff, 0xff, 0 },
+    { "azure2", 0xe0, 0xee, 0xee, 0 },
+    { "azure3", 0xc1, 0xcd, 0xcd, 0 },
+    { "azure4", 0x83, 0x8b, 0x8b, 0 },
+    { "beige", 0xf5, 0xf5, 0xdc, 0 },
+    { "bisque", 0xff, 0xe4, 0xc4, 0 },
+    { "bisque1", 0xff, 0xe4, 0xc4, 0 },
+    { "bisque2", 0xee, 0xd5, 0xb7, 0 },
+    { "bisque3", 0xcd, 0xb7, 0x9e, 0 },
+    { "bisque4", 0x8b, 0x7d, 0x6b, 0 },
+    { "blanched", 0xff, 0xeb, 0xcd, 0 },
+    { "blanchedalmond", 0xff, 0xeb, 0xcd, 0 },
+    { "blue", 0x8a, 0x2b, 0xe2, 0 },
+    { "blue1", 0x00, 0x00, 0xff, 0 },
+    { "blue2", 0x00, 0x00, 0xee, 0 },
+    { "blue3", 0x00, 0x00, 0xcd, 0 },
+    { "blue4", 0x00, 0x00, 0x8b, 0 },
+    { "blueviolet", 0x8a, 0x2b, 0xe2, 0 },
+    { "brown", 0xa5, 0x2a, 0x2a, 0 },
+    { "brown1", 0xff, 0x40, 0x40, 0 },
+    { "brown2", 0xee, 0x3b, 0x3b, 0 },
+    { "brown3", 0xcd, 0x33, 0x33, 0 },
+    { "brown4", 0x8b, 0x23, 0x23, 0 },
+    { "burlywood", 0xde, 0xb8, 0x87, 0 },
+    { "burlywood1", 0xff, 0xd3, 0x9b, 0 },
+    { "burlywood2", 0xee, 0xc5, 0x91, 0 },
+    { "burlywood3", 0xcd, 0xaa, 0x7d, 0 },
+    { "burlywood4", 0x8b, 0x73, 0x55, 0 },
+    { "cadet", 0x5f, 0x9e, 0xa0, 0 },
+    { "cadetblue", 0x5f, 0x9e, 0xa0, 0 },
+    { "cadetblue1", 0x98, 0xf5, 0xff, 0 },
+    { "cadetblue2", 0x8e, 0xe5, 0xee, 0 },
+    { "cadetblue3", 0x7a, 0xc5, 0xcd, 0 },
+    { "cadetblue4", 0x53, 0x86, 0x8b, 0 },
+    { "chartreuse", 0x7f, 0xff, 0x00, 0 },
+    { "chartreuse1", 0x7f, 0xff, 0x00, 0 },
+    { "chartreuse2", 0x76, 0xee, 0x00, 0 },
+    { "chartreuse3", 0x66, 0xcd, 0x00, 0 },
+    { "chartreuse4", 0x45, 0x8b, 0x00, 0 },
+    { "chocolate", 0xd2, 0x69, 0x1e, 0 },
+    { "chocolate1", 0xff, 0x7f, 0x24, 0 },
+    { "chocolate2", 0xee, 0x76, 0x21, 0 },
+    { "chocolate3", 0xcd, 0x66, 0x1d, 0 },
+    { "chocolate4", 0x8b, 0x45, 0x13, 0 },
+    { "coral", 0xff, 0x7f, 0x50, 0 },
+    { "coral1", 0xff, 0x72, 0x56, 0 },
+    { "coral2", 0xee, 0x6a, 0x50, 0 },
+    { "coral3", 0xcd, 0x5b, 0x45, 0 },
+    { "coral4", 0x8b, 0x3e, 0x2f, 0 },
+    { "cornflower", 0x64, 0x95, 0xed, 0 },
+    { "cornflowerblue", 0x64, 0x95, 0xed, 0 },
+    { "cornsilk", 0xff, 0xf8, 0xdc, 0 },
+    { "cornsilk1", 0xff, 0xf8, 0xdc, 0 },
+    { "cornsilk2", 0xee, 0xe8, 0xcd, 0 },
+    { "cornsilk3", 0xcd, 0xc8, 0xb1, 0 },
+    { "cornsilk4", 0x8b, 0x88, 0x78, 0 },
+    { "cyan", 0x00,0xff,0xff, 0 },
+    { "cyan1", 0x00,0xff,0xff, 0 },
+    { "cyan2", 0x00,0xee,0xee, 0 },
+    { "cyan3", 0x00,0xcd,0xcd, 0 },
+    { "cyan4", 0x00,0x8b,0x8b, 0 },
+    { "dark", 0x8b,0x00,0x00, 0 },
+    { "darkblue", 0x00,0x00,0x8b, 0 },
+    { "darkcyan", 0x00,0x8b,0x8b, 0 },
+    { "darkgoldenrod", 0xb8,0x86,0x0b, 0 },
+    { "darkgoldenrod1", 0xff,0xb9,0x0f, 0 },
+    { "darkgoldenrod2", 0xee,0xad,0x0e, 0 },
+    { "darkgoldenrod3", 0xcd,0x95,0x0c, 0 },
+    { "darkgoldenrod4", 0x8b,0x65,0x08, 0 },
+    { "darkgray", 0xa9,0xa9,0xa9, 0 },
+    { "darkgreen", 0x00,0x64,0x00, 0 },
+    { "darkgrey", 0xa9,0xa9,0xa9, 0 },
+    { "darkkhaki", 0xbd,0xb7,0x6b, 0 },
+    { "darkmagenta", 0x8b,0x00,0x8b, 0 },
+    { "darkolivegreen", 0x55,0x6b,0x2f, 0 },
+    { "darkolivegreen1", 0xca,0xff,0x70, 0 },
+    { "darkolivegreen2", 0xbc,0xee,0x68, 0 },
+    { "darkolivegreen3", 0xa2,0xcd,0x5a, 0 },
+    { "darkolivegreen4", 0x6e,0x8b,0x3d, 0 },
+    { "darkorange", 0xff,0x8c,0x00, 0 },
+    { "darkorange1", 0xff,0x7f,0x00, 0 },
+    { "darkorange2", 0xee,0x76,0x00, 0 },
+    { "darkorange3", 0xcd,0x66,0x00, 0 },
+    { "darkorange4", 0x8b,0x45,0x00, 0 },
+    { "darkorchid", 0x99,0x32,0xcc, 0 },
+    { "darkorchid1", 0xbf,0x3e,0xff, 0 },
+    { "darkorchid2", 0xb2,0x3a,0xee, 0 },
+    { "darkorchid3", 0x9a,0x32,0xcd, 0 },
+    { "darkorchid4", 0x68,0x22,0x8b, 0 },
+    { "darkred", 0x8b,0x00,0x00, 0 },
+    { "darksalmon", 0xe9,0x96,0x7a, 0 },
+    { "darkseagreen", 0x8f,0xbc,0x8f, 0 },
+    { "darkseagreen1", 0xc1,0xff,0xc1, 0 },
+    { "darkseagreen2", 0xb4,0xee,0xb4, 0 },
+    { "darkseagreen3", 0x9b,0xcd,0x9b, 0 },
+    { "darkseagreen4", 0x69,0x8b,0x69, 0 },
+    { "darkslateblue", 0x48,0x3d,0x8b, 0 },
+    { "darkslategray", 0x2f,0x4f,0x4f, 0 },
+    { "darkslategray1", 0x97,0xff,0xff, 0 },
+    { "darkslategray2", 0x8d,0xee,0xee, 0 },
+    { "darkslategray3", 0x79,0xcd,0xcd, 0 },
+    { "darkslategray4", 0x52,0x8b,0x8b, 0 },
+    { "darkslategrey", 0x2f,0x4f,0x4f, 0 },
+    { "darkturquoise", 0x00,0xce,0xd1, 0 },
+    { "darkviolet", 0x94,0x00,0xd3, 0 },
+    { "deep", 0xff,0x14,0x93, 0 },
+    { "deeppink", 0xff,0x14,0x93, 0 },
+    { "deeppink1", 0xff,0x14,0x93, 0 },
+    { "deeppink2", 0xee,0x12,0x89, 0 },
+    { "deeppink3", 0xcd,0x10,0x76, 0 },
+    { "deeppink4", 0x8b,0x0a,0x50, 0 },
+    { "deepskyblue", 0x00,0xbf,0xff, 0 },
+    { "deepskyblue1", 0x00,0xbf,0xff, 0 },
+    { "deepskyblue2", 0x00,0xb2,0xee, 0 },
+    { "deepskyblue3", 0x00,0x9a,0xcd, 0 },
+    { "deepskyblue4", 0x00,0x68,0x8b, 0 },
+    { "dim", 0x69,0x69,0x69, 0 },
+    { "dimgray", 0x69,0x69,0x69, 0 },
+    { "dimgrey", 0x69,0x69,0x69, 0 },
+    { "dodger", 0x1e,0x90,0xff, 0 },
+    { "dodgerblue", 0x1e,0x90,0xff, 0 },
+    { "dodgerblue1", 0x1e,0x90,0xff, 0 },
+    { "dodgerblue2", 0x1c,0x86,0xee, 0 },
+    { "dodgerblue3", 0x18,0x74,0xcd, 0 },
+    { "dodgerblue4", 0x10,0x4e,0x8b, 0 },
+    { "firebrick", 0xb2,0x22,0x22, 0 },
+    { "firebrick1", 0xff,0x30,0x30, 0 },
+    { "firebrick2", 0xee,0x2c,0x2c, 0 },
+    { "firebrick3", 0xcd,0x26,0x26, 0 },
+    { "firebrick4", 0x8b,0x1a,0x1a, 0 },
+    { "floral", 0xff,0xfa,0xf0, 0 },
+    { "floralwhite", 0xff,0xfa,0xf0, 0 },
+    { "forest", 0x22,0x8b,0x22, 0 },
+    { "forestgreen", 0x22,0x8b,0x22, 0 },
+    { "gainsboro", 0xdc,0xdc,0xdc, 0 },
+    { "ghost", 0xf8,0xf8,0xff, 0 },
+    { "ghostwhite", 0xf8,0xf8,0xff, 0 },
+    { "gold", 0xff,0xd7,0x00, 0 },
+    { "gold1", 0xff,0xd7,0x00, 0 },
+    { "gold2", 0xee,0xc9,0x00, 0 },
+    { "gold3", 0xcd,0xad,0x00, 0 },
+    { "gold4", 0x8b,0x75,0x00, 0 },
+    { "goldenrod", 0xda,0xa5,0x20, 0 },
+    { "goldenrod1", 0xff,0xc1,0x25, 0 },
+    { "goldenrod2", 0xee,0xb4,0x22, 0 },
+    { "goldenrod3", 0xcd,0x9b,0x1d, 0 },
+    { "goldenrod4", 0x8b,0x69,0x14, 0 },
+    { "gray", 0xbe,0xbe,0xbe, 0 },
+    { "gray0", 0x00,0x00,0x00, 0 },
+    { "gray1", 0x03,0x03,0x03, 0 },
+    { "gray10", 0x1a,0x1a,0x1a, 0 },
+    { "gray100", 0xff,0xff,0xff, 0 },
+    { "gray11", 0x1c,0x1c,0x1c, 0 },
+    { "gray12", 0x1f,0x1f,0x1f, 0 },
+    { "gray13", 0x21,0x21,0x21, 0 },
+    { "gray14", 0x24,0x24,0x24, 0 },
+    { "gray15", 0x26,0x26,0x26, 0 },
+    { "gray16", 0x29,0x29,0x29, 0 },
+    { "gray17", 0x2b,0x2b,0x2b, 0 },
+    { "gray18", 0x2e,0x2e,0x2e, 0 },
+    { "gray19", 0x30,0x30,0x30, 0 },
+    { "gray2", 0x05,0x05,0x05, 0 },
+    { "gray20", 0x33,0x33,0x33, 0 },
+    { "gray21", 0x36,0x36,0x36, 0 },
+    { "gray22", 0x38,0x38,0x38, 0 },
+    { "gray23", 0x3b,0x3b,0x3b, 0 },
+    { "gray24", 0x3d,0x3d,0x3d, 0 },
+    { "gray25", 0x40,0x40,0x40, 0 },
+    { "gray26", 0x42,0x42,0x42, 0 },
+    { "gray27", 0x45,0x45,0x45, 0 },
+    { "gray28", 0x47,0x47,0x47, 0 },
+    { "gray29", 0x4a,0x4a,0x4a, 0 },
+    { "gray3", 0x08,0x08,0x08, 0 },
+    { "gray30", 0x4d,0x4d,0x4d, 0 },
+    { "gray31", 0x4f,0x4f,0x4f, 0 },
+    { "gray32", 0x52,0x52,0x52, 0 },
+    { "gray33", 0x54,0x54,0x54, 0 },
+    { "gray34", 0x57,0x57,0x57, 0 },
+    { "gray35", 0x59,0x59,0x59, 0 },
+    { "gray36", 0x5c,0x5c,0x5c, 0 },
+    { "gray37", 0x5e,0x5e,0x5e, 0 },
+    { "gray38", 0x61,0x61,0x61, 0 },
+    { "gray39", 0x63,0x63,0x63, 0 },
+    { "gray4", 0x0a,0x0a,0x0a, 0 },
+    { "gray40", 0x66,0x66,0x66, 0 },
+    { "gray41", 0x69,0x69,0x69, 0 },
+    { "gray42", 0x6b,0x6b,0x6b, 0 },
+    { "gray43", 0x6e,0x6e,0x6e, 0 },
+    { "gray44", 0x70,0x70,0x70, 0 },
+    { "gray45", 0x73,0x73,0x73, 0 },
+    { "gray46", 0x75,0x75,0x75, 0 },
+    { "gray47", 0x78,0x78,0x78, 0 },
+    { "gray48", 0x7a,0x7a,0x7a, 0 },
+    { "gray49", 0x7d,0x7d,0x7d, 0 },
+    { "gray5", 0x0d,0x0d,0x0d, 0 },
+    { "gray50", 0x7f,0x7f,0x7f, 0 },
+    { "gray51", 0x82,0x82,0x82, 0 },
+    { "gray52", 0x85,0x85,0x85, 0 },
+    { "gray53", 0x87,0x87,0x87, 0 },
+    { "gray54", 0x8a,0x8a,0x8a, 0 },
+    { "gray55", 0x8c,0x8c,0x8c, 0 },
+    { "gray56", 0x8f,0x8f,0x8f, 0 },
+    { "gray57", 0x91,0x91,0x91, 0 },
+    { "gray58", 0x94,0x94,0x94, 0 },
+    { "gray59", 0x96,0x96,0x96, 0 },
+    { "gray6", 0x0f,0x0f,0x0f, 0 },
+    { "gray60", 0x99,0x99,0x99, 0 },
+    { "gray61", 0x9c,0x9c,0x9c, 0 },
+    { "gray62", 0x9e,0x9e,0x9e, 0 },
+    { "gray63", 0xa1,0xa1,0xa1, 0 },
+    { "gray64", 0xa3,0xa3,0xa3, 0 },
+    { "gray65", 0xa6,0xa6,0xa6, 0 },
+    { "gray66", 0xa8,0xa8,0xa8, 0 },
+    { "gray67", 0xab,0xab,0xab, 0 },
+    { "gray68", 0xad,0xad,0xad, 0 },
+    { "gray69", 0xb0,0xb0,0xb0, 0 },
+    { "gray7", 0x12,0x12,0x12, 0 },
+    { "gray70", 0xb3,0xb3,0xb3, 0 },
+    { "gray71", 0xb5,0xb5,0xb5, 0 },
+    { "gray72", 0xb8,0xb8,0xb8, 0 },
+    { "gray73", 0xba,0xba,0xba, 0 },
+    { "gray74", 0xbd,0xbd,0xbd, 0 },
+    { "gray75", 0xbf,0xbf,0xbf, 0 },
+    { "gray76", 0xc2,0xc2,0xc2, 0 },
+    { "gray77", 0xc4,0xc4,0xc4, 0 },
+    { "gray78", 0xc7,0xc7,0xc7, 0 },
+    { "gray79", 0xc9,0xc9,0xc9, 0 },
+    { "gray8", 0x14,0x14,0x14, 0 },
+    { "gray80", 0xcc,0xcc,0xcc, 0 },
+    { "gray81", 0xcf,0xcf,0xcf, 0 },
+    { "gray82", 0xd1,0xd1,0xd1, 0 },
+    { "gray83", 0xd4,0xd4,0xd4, 0 },
+    { "gray84", 0xd6,0xd6,0xd6, 0 },
+    { "gray85", 0xd9,0xd9,0xd9, 0 },
+    { "gray86", 0xdb,0xdb,0xdb, 0 },
+    { "gray87", 0xde,0xde,0xde, 0 },
+    { "gray88", 0xe0,0xe0,0xe0, 0 },
+    { "gray89", 0xe3,0xe3,0xe3, 0 },
+    { "gray9", 0x17,0x17,0x17, 0 },
+    { "gray90", 0xe5,0xe5,0xe5, 0 },
+    { "gray91", 0xe8,0xe8,0xe8, 0 },
+    { "gray92", 0xeb,0xeb,0xeb, 0 },
+    { "gray93", 0xed,0xed,0xed, 0 },
+    { "gray94", 0xf0,0xf0,0xf0, 0 },
+    { "gray95", 0xf2,0xf2,0xf2, 0 },
+    { "gray96", 0xf5,0xf5,0xf5, 0 },
+    { "gray97", 0xf7,0xf7,0xf7, 0 },
+    { "gray98", 0xfa,0xfa,0xfa, 0 },
+    { "gray99", 0xfc,0xfc,0xfc, 0 },
+    { "green", 0xad,0xff,0x2f, 0 },
+    { "green1", 0x00,0xff,0x00, 0 },
+    { "green2", 0x00,0xee,0x00, 0 },
+    { "green3", 0x00,0xcd,0x00, 0 },
+    { "green4", 0x00,0x8b,0x00, 0 },
+    { "greenyellow", 0xad,0xff,0x2f, 0 },
+    { "grey0", 0x00,0x00,0x00, 0 },
+    { "grey1", 0x03,0x03,0x03, 0 },
+    { "grey10", 0x1a,0x1a,0x1a, 0 },
+    { "grey100", 0xff,0xff,0xff, 0 },
+    { "grey11", 0x1c,0x1c,0x1c, 0 },
+    { "grey12", 0x1f,0x1f,0x1f, 0 },
+    { "grey13", 0x21,0x21,0x21, 0 },
+    { "grey14", 0x24,0x24,0x24, 0 },
+    { "grey15", 0x26,0x26,0x26, 0 },
+    { "grey16", 0x29,0x29,0x29, 0 },
+    { "grey17", 0x2b,0x2b,0x2b, 0 },
+    { "grey18", 0x2e,0x2e,0x2e, 0 },
+    { "grey19", 0x30,0x30,0x30, 0 },
+    { "grey2", 0x05,0x05,0x05, 0 },
+    { "grey20", 0x33,0x33,0x33, 0 },
+    { "grey21", 0x36,0x36,0x36, 0 },
+    { "grey22", 0x38,0x38,0x38, 0 },
+    { "grey23", 0x3b,0x3b,0x3b, 0 },
+    { "grey24", 0x3d,0x3d,0x3d, 0 },
+    { "grey25", 0x40,0x40,0x40, 0 },
+    { "grey26", 0x42,0x42,0x42, 0 },
+    { "grey27", 0x45,0x45,0x45, 0 },
+    { "grey28", 0x47,0x47,0x47, 0 },
+    { "grey29", 0x4a,0x4a,0x4a, 0 },
+    { "grey3", 0x08,0x08,0x08, 0 },
+    { "grey30", 0x4d,0x4d,0x4d, 0 },
+    { "grey31", 0x4f,0x4f,0x4f, 0 },
+    { "grey32", 0x52,0x52,0x52, 0 },
+    { "grey33", 0x54,0x54,0x54, 0 },
+    { "grey34", 0x57,0x57,0x57, 0 },
+    { "grey35", 0x59,0x59,0x59, 0 },
+    { "grey36", 0x5c,0x5c,0x5c, 0 },
+    { "grey37", 0x5e,0x5e,0x5e, 0 },
+    { "grey38", 0x61,0x61,0x61, 0 },
+    { "grey39", 0x63,0x63,0x63, 0 },
+    { "grey4", 0x0a,0x0a,0x0a, 0 },
+    { "grey4", 0x66,0x66,0x66, 0 },
+    { "grey41", 0x69,0x69,0x69, 0 },
+    { "grey42", 0x6b,0x6b,0x6b, 0 },
+    { "grey43", 0x6e,0x6e,0x6e, 0 },
+    { "grey44", 0x70,0x70,0x70, 0 },
+    { "grey45", 0x73,0x73,0x73, 0 },
+    { "grey46", 0x75,0x75,0x75, 0 },
+    { "grey47", 0x78,0x78,0x78, 0 },
+    { "grey48", 0x7a,0x7a,0x7a, 0 },
+    { "grey49", 0x7d,0x7d,0x7d, 0 },
+    { "grey5", 0x0d,0x0d,0x0d, 0 },
+    { "grey50", 0x7f,0x7f,0x7f, 0 },
+    { "grey51", 0x82,0x82,0x82, 0 },
+    { "grey52", 0x85,0x85,0x85, 0 },
+    { "grey53", 0x87,0x87,0x87, 0 },
+    { "grey54", 0x8a,0x8a,0x8a, 0 },
+    { "grey55", 0x8c,0x8c,0x8c, 0 },
+    { "grey56", 0x8f,0x8f,0x8f, 0 },
+    { "grey57", 0x91,0x91,0x91, 0 },
+    { "grey58", 0x94,0x94,0x94, 0 },
+    { "grey59", 0x96,0x96,0x96, 0 },
+    { "grey6", 0x0f,0x0f,0x0f, 0 },
+    { "grey60", 0x99,0x99,0x99, 0 },
+    { "grey61", 0x9c,0x9c,0x9c, 0 },
+    { "grey62", 0x9e,0x9e,0x9e, 0 },
+    { "grey63", 0xa1,0xa1,0xa1, 0 },
+    { "grey64", 0xa3,0xa3,0xa3, 0 },
+    { "grey65", 0xa6,0xa6,0xa6, 0 },
+    { "grey66", 0xa8,0xa8,0xa8, 0 },
+    { "grey67", 0xab,0xab,0xab, 0 },
+    { "grey68", 0xad,0xad,0xad, 0 },
+    { "grey69", 0xb0,0xb0,0xb0, 0 },
+    { "grey7", 0x12,0x12,0x12, 0 },
+    { "grey70", 0xb3,0xb3,0xb3, 0 },
+    { "grey71", 0xb5,0xb5,0xb5, 0 },
+    { "grey72", 0xb8,0xb8,0xb8, 0 },
+    { "grey73", 0xba,0xba,0xba, 0 },
+    { "grey74", 0xbd,0xbd,0xbd, 0 },
+    { "grey75", 0xbf,0xbf,0xbf, 0 },
+    { "grey76", 0xc2,0xc2,0xc2, 0 },
+    { "grey77", 0xc4,0xc4,0xc4, 0 },
+    { "grey78", 0xc7,0xc7,0xc7, 0 },
+    { "grey79", 0xc9,0xc9,0xc9, 0 },
+    { "grey8", 0x14,0x14,0x14, 0 },
+    { "grey80", 0xcc,0xcc,0xcc, 0 },
+    { "grey81", 0xcf,0xcf,0xcf, 0 },
+    { "grey82", 0xd1,0xd1,0xd1, 0 },
+    { "grey83", 0xd4,0xd4,0xd4, 0 },
+    { "grey84", 0xd6,0xd6,0xd6, 0 },
+    { "grey85", 0xd9,0xd9,0xd9, 0 },
+    { "grey86", 0xdb,0xdb,0xdb, 0 },
+    { "grey87", 0xde,0xde,0xde, 0 },
+    { "grey88", 0xe0,0xe0,0xe0, 0 },
+    { "grey89", 0xe3,0xe3,0xe3, 0 },
+    { "grey9", 0x17,0x17,0x17, 0 },
+    { "grey90", 0xe5,0xe5,0xe5, 0 },
+    { "grey91", 0xe8,0xe8,0xe8, 0 },
+    { "grey92", 0xeb,0xeb,0xeb, 0 },
+    { "grey93", 0xed,0xed,0xed, 0 },
+    { "grey94", 0xf0,0xf0,0xf0, 0 },
+    { "grey95", 0xf2,0xf2,0xf2, 0 },
+    { "grey96", 0xf5,0xf5,0xf5, 0 },
+    { "grey97", 0xf7,0xf7,0xf7, 0 },
+    { "grey98", 0xfa,0xfa,0xfa, 0 },
+    { "grey99", 0xfc,0xfc,0xfc, 0 },
+    { "honeydew", 0xf0,0xff,0xf0, 0 },
+    { "honeydew1", 0xf0,0xff,0xf0, 0 },
+    { "honeydew2", 0xe0,0xee,0xe0, 0 },
+    { "honeydew3", 0xc1,0xcd,0xc1, 0 },
+    { "honeydew4", 0x83,0x8b,0x83, 0 },
+    { "hot", 0xff,0x69,0xb4, 0 },
+    { "hotpink", 0xff,0x69,0xb4, 0 },
+    { "hotpink1", 0xff,0x6e,0xb4, 0 },
+    { "hotpink2", 0xee,0x6a,0xa7, 0 },
+    { "hotpink3", 0xcd,0x60,0x90, 0 },
+    { "hotpink4", 0x8b,0x3a,0x62, 0 },
+    { "indian", 0xcd,0x5c,0x5c, 0 },
+    { "indianred", 0xcd,0x5c,0x5c, 0 },
+    { "indianred1", 0xff,0x6a,0x6a, 0 },
+    { "indianred2", 0xee,0x63,0x63, 0 },
+    { "indianred3", 0xcd,0x55,0x55, 0 },
+    { "indianred4", 0x8b,0x3a,0x3a, 0 },
+    { "ivory", 0xff,0xff,0xf0, 0 },
+    { "ivory1", 0xff,0xff,0xf0, 0 },
+    { "ivory2", 0xee,0xee,0xe0, 0 },
+    { "ivory3", 0xcd,0xcd,0xc1, 0 },
+    { "ivory4", 0x8b,0x8b,0x83, 0 },
+    { "khaki", 0xf0,0xe6,0x8c, 0 },
+    { "khaki1", 0xff,0xf6,0x8f, 0 },
+    { "khaki2", 0xee,0xe6,0x85, 0 },
+    { "khaki3", 0xcd,0xc6,0x73, 0 },
+    { "khaki4", 0x8b,0x86,0x4e, 0 },
+    { "lavender", 0xff,0xf0,0xf5, 0 },
+    { "lavenderblush", 0xff,0xf0,0xf5, 0 },
+    { "lavenderblush1", 0xff,0xf0,0xf5, 0 },
+    { "lavenderblush2", 0xee,0xe0,0xe5, 0 },
+    { "lavenderblush3", 0xcd,0xc1,0xc5, 0 },
+    { "lavenderblush4", 0x8b,0x83,0x86, 0 },
+    { "lawn", 0x7c,0xfc,0x00, 0 },
+    { "lawngreen", 0x7c,0xfc,0x00, 0 },
+    { "lemon", 0xff,0xfa,0xcd, 0 },
+    { "lemonchiffon", 0xff,0xfa,0xcd, 0 },
+    { "lemonchiffon1", 0xff,0xfa,0xcd, 0 },
+    { "lemonchiffon2", 0xee,0xe9,0xbf, 0 },
+    { "lemonchiffon3", 0xcd,0xc9,0xa5, 0 },
+    { "lemonchiffon4", 0x8b,0x89,0x70, 0 },
+    { "light", 0x90,0xee,0x90, 0 },
+    { "lightblue", 0xad,0xd8,0xe6, 0 },
+    { "lightblue1", 0xbf,0xef,0xff, 0 },
+    { "lightblue2", 0xb2,0xdf,0xee, 0 },
+    { "lightblue3", 0x9a,0xc0,0xcd, 0 },
+    { "lightblue4", 0x68,0x83,0x8b, 0 },
+    { "lightcoral", 0xf0,0x80,0x80, 0 },
+    { "lightcyan", 0xe0,0xff,0xff, 0 },
+    { "lightcyan1", 0xe0,0xff,0xff, 0 },
+    { "lightcyan2", 0xd1,0xee,0xee, 0 },
+    { "lightcyan3", 0xb4,0xcd,0xcd, 0 },
+    { "lightcyan4", 0x7a,0x8b,0x8b, 0 },
+    { "lightgoldenrod", 0xee,0xdd,0x82, 0 },
+    { "lightgoldenrod1", 0xff,0xec,0x8b, 0 },
+    { "lightgoldenrod2", 0xee,0xdc,0x82, 0 },
+    { "lightgoldenrod3", 0xcd,0xbe,0x70, 0 },
+    { "lightgoldenrod4", 0x8b,0x81,0x4c, 0 },
+    { "lightgoldenrodyellow", 0xfa,0xfa,0xd2, 0 },
+    { "lightgray", 0xd3,0xd3,0xd3, 0 },
+    { "lightgreen", 0x90,0xee,0x90, 0 },
+    { "lightgrey", 0xd3,0xd3,0xd3, 0 },
+    { "lightpink", 0xff,0xb6,0xc1, 0 },
+    { "lightpink1", 0xff,0xae,0xb9, 0 },
+    { "lightpink2", 0xee,0xa2,0xad, 0 },
+    { "lightpink3", 0xcd,0x8c,0x95, 0 },
+    { "lightpink4", 0x8b,0x5f,0x65, 0 },
+    { "lightsalmon", 0xff,0xa0,0x7a, 0 },
+    { "lightsalmon1", 0xff,0xa0,0x7a, 0 },
+    { "lightsalmon2", 0xee,0x95,0x72, 0 },
+    { "lightsalmon3", 0xcd,0x81,0x62, 0 },
+    { "lightsalmon4", 0x8b,0x57,0x42, 0 },
+    { "lightseagreen", 0x20,0xb2,0xaa, 0 },
+    { "lightskyblue", 0x87,0xce,0xfa, 0 },
+    { "lightskyblue1", 0xb0,0xe2,0xff, 0 },
+    { "lightskyblue2", 0xa4,0xd3,0xee, 0 },
+    { "lightskyblue3", 0x8d,0xb6,0xcd, 0 },
+    { "lightskyblue4", 0x60,0x7b,0x8b, 0 },
+    { "lightslateblue", 0x84,0x70,0xff, 0 },
+    { "lightslategray", 0x77,0x88,0x99, 0 },
+    { "lightslategrey", 0x77,0x88,0x99, 0 },
+    { "lightsteelblue", 0xb0,0xc4,0xde, 0 },
+    { "lightsteelblue1", 0xca,0xe1,0xff, 0 },
+    { "lightsteelblue2", 0xbc,0xd2,0xee, 0 },
+    { "lightsteelblue3", 0xa2,0xb5,0xcd, 0 },
+    { "lightsteelblue4", 0x6e,0x7b,0x8b, 0 },
+    { "lightyellow", 0xff,0xff,0xe0, 0 },
+    { "lightyellow1", 0xff,0xff,0xe0, 0 },
+    { "lightyellow2", 0xee,0xee,0xd1, 0 },
+    { "lightyellow3", 0xcd,0xcd,0xb4, 0 },
+    { "lightyellow4", 0x8b,0x8b,0x7a, 0 },
+    { "lime", 0x32,0xcd,0x32, 0 },
+    { "limegreen", 0x32,0xcd,0x32, 0 },
+    { "linen", 0xfa,0xf0,0xe6, 0 },
+    { "magenta", 0xff,0x00,0xff, 0 },
+    { "magenta1", 0xff,0x00,0xff, 0 },
+    { "magenta2", 0xee,0x00,0xee, 0 },
+    { "magenta3", 0xcd,0x00,0xcd, 0 },
+    { "magenta4", 0x8b,0x00,0x8b, 0 },
+    { "maroon", 0xb0,0x30,0x60, 0 },
+    { "maroon1", 0xff,0x34,0xb3, 0 },
+    { "maroon2", 0xee,0x30,0xa7, 0 },
+    { "maroon3", 0xcd,0x29,0x90, 0 },
+    { "maroon4", 0x8b,0x1c,0x62, 0 },
+    { "medium", 0x93,0x70,0xdb, 0 },
+    { "mediumaquamarine", 0x66,0xcd,0xaa, 0 },
+    { "mediumblue", 0x00,0x00,0xcd, 0 },
+    { "mediumorchid", 0xba,0x55,0xd3, 0 },
+    { "mediumorchid1", 0xe0,0x66,0xff, 0 },
+    { "mediumorchid2", 0xd1,0x5f,0xee, 0 },
+    { "mediumorchid3", 0xb4,0x52,0xcd, 0 },
+    { "mediumorchid4", 0x7a,0x37,0x8b, 0 },
+    { "mediumpurple", 0x93,0x70,0xdb, 0 },
+    { "mediumpurple1", 0xab,0x82,0xff, 0 },
+    { "mediumpurple2", 0x9f,0x79,0xee, 0 },
+    { "mediumpurple3", 0x89,0x68,0xcd, 0 },
+    { "mediumpurple4", 0x5d,0x47,0x8b, 0 },
+    { "mediumseagreen", 0x3c,0xb3,0x71, 0 },
+    { "mediumslateblue", 0x7b,0x68,0xee, 0 },
+    { "mediumspringgreen", 0x00,0xfa,0x9a, 0 },
+    { "mediumturquoise", 0x48,0xd1,0xcc, 0 },
+    { "mediumvioletred", 0xc7,0x15,0x85, 0 },
+    { "midnight", 0x19,0x19,0x70, 0 },
+    { "midnightblue", 0x19,0x19,0x70, 0 },
+    { "mint", 0xf5,0xff,0xfa, 0 },
+    { "mintcream", 0xf5,0xff,0xfa, 0 },
+    { "misty", 0xff,0xe4,0xe1, 0 },
+    { "mistyrose", 0xff,0xe4,0xe1, 0 },
+    { "mistyrose1", 0xff,0xe4,0xe1, 0 },
+    { "mistyrose2", 0xee,0xd5,0xd2, 0 },
+    { "mistyrose3", 0xcd,0xb7,0xb5, 0 },
+    { "mistyrose4", 0x8b,0x7d,0x7b, 0 },
+    { "moccasin", 0xff,0xe4,0xb5, 0 },
+    { "navajo", 0xff,0xde,0xad, 0 },
+    { "navajowhite", 0xff,0xde,0xad, 0 },
+    { "navajowhite1", 0xff,0xde,0xad, 0 },
+    { "navajowhite2", 0xee,0xcf,0xa1, 0 },
+    { "navajowhite3", 0xcd,0xb3,0x8b, 0 },
+    { "navajowhite4", 0x8b,0x79,0x5e, 0 },
+    { "navy", 0x00,0x00,0x80, 0 },
+    { "navyblue", 0x00,0x00,0x80, 0 },
+    { "old", 0xfd,0xf5,0xe6, 0 },
+    { "oldlace", 0xfd,0xf5,0xe6, 0 },
+    { "olive", 0x6b,0x8e,0x23, 0 },
+    { "olivedrab", 0x6b,0x8e,0x23, 0 },
+    { "olivedrab1", 0xc0,0xff,0x3e, 0 },
+    { "olivedrab2", 0xb3,0xee,0x3a, 0 },
+    { "olivedrab3", 0x9a,0xcd,0x32, 0 },
+    { "olivedrab4", 0x69,0x8b,0x22, 0 },
+    { "orange", 0xff,0x45,0x00, 0 },
+    { "orange1", 0xff,0xa5,0x00, 0 },
+    { "orange2", 0xee,0x9a,0x00, 0 },
+    { "orange3", 0xcd,0x85,0x00, 0 },
+    { "orange4", 0x8b,0x5a,0x00, 0 },
+    { "orangered", 0xff,0x45,0x00, 0 },
+    { "orangered1", 0xff,0x45,0x00, 0 },
+    { "orangered2", 0xee,0x40,0x00, 0 },
+    { "orangered3", 0xcd,0x37,0x00, 0 },
+    { "orangered4", 0x8b,0x25,0x00, 0 },
+    { "orchid", 0xda,0x70,0xd6, 0 },
+    { "orchid1", 0xff,0x83,0xfa, 0 },
+    { "orchid2", 0xee,0x7a,0xe9, 0 },
+    { "orchid3", 0xcd,0x69,0xc9, 0 },
+    { "orchid4", 0x8b,0x47,0x89, 0 },
+    { "pale", 0xdb,0x70,0x93, 0 },
+    { "palegoldenrod", 0xee,0xe8,0xaa, 0 },
+    { "palegreen", 0x98,0xfb,0x98, 0 },
+    { "palegreen1", 0x9a,0xff,0x9a, 0 },
+    { "palegreen2", 0x90,0xee,0x90, 0 },
+    { "palegreen3", 0x7c,0xcd,0x7c, 0 },
+    { "palegreen4", 0x54,0x8b,0x54, 0 },
+    { "paleturquoise", 0xaf,0xee,0xee, 0 },
+    { "paleturquoise1", 0xbb,0xff,0xff, 0 },
+    { "paleturquoise2", 0xae,0xee,0xee, 0 },
+    { "paleturquoise3", 0x96,0xcd,0xcd, 0 },
+    { "paleturquoise4", 0x66,0x8b,0x8b, 0 },
+    { "palevioletred", 0xdb,0x70,0x93, 0 },
+    { "palevioletred1", 0xff,0x82,0xab, 0 },
+    { "palevioletred2", 0xee,0x79,0x9f, 0 },
+    { "palevioletred3", 0xcd,0x68,0x89, 0 },
+    { "palevioletred4", 0x8b,0x47,0x5d, 0 },
+    { "papaya", 0xff,0xef,0xd5, 0 },
+    { "papayawhip", 0xff,0xef,0xd5, 0 },
+    { "peach", 0xff,0xda,0xb9, 0 },
+    { "peachpuff", 0xff,0xda,0xb9, 0 },
+    { "peachpuff1", 0xff,0xda,0xb9, 0 },
+    { "peachpuff2", 0xee,0xcb,0xad, 0 },
+    { "peachpuff3", 0xcd,0xaf,0x95, 0 },
+    { "peachpuff4", 0x8b,0x77,0x65, 0 },
+    { "peru", 0xcd,0x85,0x3f, 0 },
+    { "pink", 0xff,0xc0,0xcb, 0 },
+    { "pink1", 0xff,0xb5,0xc5, 0 },
+    { "pink2", 0xee,0xa9,0xb8, 0 },
+    { "pink3", 0xcd,0x91,0x9e, 0 },
+    { "pink4", 0x8b,0x63,0x6c, 0 },
+    { "plum", 0xdd,0xa0,0xdd, 0 },
+    { "plum1", 0xff,0xbb,0xff, 0 },
+    { "plum2", 0xee,0xae,0xee, 0 },
+    { "plum3", 0xcd,0x96,0xcd, 0 },
+    { "plum4", 0x8b,0x66,0x8b, 0 },
+    { "powder", 0xb0,0xe0,0xe6, 0 },
+    { "powderblue", 0xb0,0xe0,0xe6, 0 },
+    { "purple", 0xa0,0x20,0xf0, 0 },
+    { "purple1", 0x9b,0x30,0xff, 0 },
+    { "purple2", 0x91,0x2c,0xee, 0 },
+    { "purple3", 0x7d,0x26,0xcd, 0 },
+    { "purple4", 0x55,0x1a,0x8b, 0 },
+    { "red", 0xff,0x00,0x00, 0 },
+    { "red1", 0xff,0x00,0x00, 0 },
+    { "red2", 0xee,0x00,0x00, 0 },
+    { "red3", 0xcd,0x00,0x00, 0 },
+    { "red4", 0x8b,0x00,0x00, 0 },
+    { "rosy", 0xbc,0x8f,0x8f, 0 },
+    { "rosybrown", 0xbc,0x8f,0x8f, 0 },
+    { "rosybrown1", 0xff,0xc1,0xc1, 0 },
+    { "rosybrown2", 0xee,0xb4,0xb4, 0 },
+    { "rosybrown3", 0xcd,0x9b,0x9b, 0 },
+    { "rosybrown4", 0x8b,0x69,0x69, 0 },
+    { "royal", 0x41,0x69,0xe1, 0 },
+    { "royalblue", 0x41,0x69,0xe1, 0 },
+    { "royalblue1", 0x48,0x76,0xff, 0 },
+    { "royalblue2", 0x43,0x6e,0xee, 0 },
+    { "royalblue3", 0x3a,0x5f,0xcd, 0 },
+    { "royalblue4", 0x27,0x40,0x8b, 0 },
+    { "saddle", 0x8b,0x45,0x13, 0 },
+    { "saddlebrown", 0x8b,0x45,0x13, 0 },
+    { "salmon", 0xfa,0x80,0x72, 0 },
+    { "salmon1", 0xff,0x8c,0x69, 0 },
+    { "salmon2", 0xee,0x82,0x62, 0 },
+    { "salmon3", 0xcd,0x70,0x54, 0 },
+    { "salmon4", 0x8b,0x4c,0x39, 0 },
+    { "sandy", 0xf4,0xa4,0x60, 0 },
+    { "sandybrown", 0xf4,0xa4,0x60, 0 },
+    { "sea", 0x2e,0x8b,0x57, 0 },
+    { "seagreen", 0x2e,0x8b,0x57, 0 },
+    { "seagreen1", 0x54,0xff,0x9f, 0 },
+    { "seagreen2", 0x4e,0xee,0x94, 0 },
+    { "seagreen3", 0x43,0xcd,0x80, 0 },
+    { "seagreen4", 0x2e,0x8b,0x57, 0 },
+    { "seashell", 0xff, 0xf5, 0xee, 0 },
+    { "seashell1", 0xff,0xf5,0xee, 0 },
+    { "seashell2", 0xee,0xe5,0xde, 0 },
+    { "seashell3", 0xcd,0xc5,0xbf, 0 },
+    { "seashell4", 0x8b,0x86,0x82, 0 },
+    { "sienna", 0xa0,0x52,0x2d, 0 },
+    { "sienna1", 0xff,0x82,0x47, 0 },
+    { "sienna2", 0xee,0x79,0x42, 0 },
+    { "sienna3", 0xcd,0x68,0x39, 0 },
+    { "sienna4", 0x8b,0x47,0x26, 0 },
+    { "sky", 0x87,0xce,0xeb, 0 },
+    { "skyblue", 0x87,0xce,0xeb, 0 },
+    { "skyblue1", 0x87,0xce,0xff, 0 },
+    { "skyblue2", 0x7e,0xc0,0xee, 0 },
+    { "skyblue3", 0x6c,0xa6,0xcd, 0 },
+    { "skyblue4", 0x4a,0x70,0x8b, 0 },
+    { "slate", 0x6a,0x5a,0xcd, 0 },
+    { "slateblue", 0x6a,0x5a,0xcd, 0 },
+    { "slateblue1", 0x83,0x6f,0xff, 0 },
+    { "slateblue2", 0x7a,0x67,0xee, 0 },
+    { "slateblue3", 0x69,0x59,0xcd, 0 },
+    { "slateblue4", 0x47,0x3c,0x8b, 0 },
+    { "slategray", 0x70,0x80,0x90, 0 },
+    { "slategray1", 0xc6,0xe2,0xff, 0 },
+    { "slategray2", 0xb9,0xd3,0xee, 0 },
+    { "slategray3", 0x9f,0xb6,0xcd, 0 },
+    { "slategray4", 0x6c,0x7b,0x8b, 0 },
+    { "slategrey", 0x70,0x80,0x90, 0 },
+    { "snow", 0xff,0xfa,0xfa, 0 },
+    { "snow1", 0xff,0xfa,0xfa, 0 },
+    { "snow2", 0xee,0xe9,0xe9, 0 },
+    { "snow3", 0xcd,0xc9,0xc9, 0 },
+    { "snow4", 0x8b,0x89,0x89, 0 },
+    { "spring", 0x00,0xff,0x7f, 0 },
+    { "springgreen", 0x00,0xff,0x7f, 0 },
+    { "springgreen1", 0x00,0xff,0x7f, 0 },
+    { "springgreen2", 0x00,0xee,0x76, 0 },
+    { "springgreen3", 0x00,0xcd,0x66, 0 },
+    { "springgreen4", 0x00,0x8b,0x45, 0 },
+    { "steel", 0x46,0x82,0xb4, 0 },
+    { "steelblue", 0x46,0x82,0xb4, 0 },
+    { "steelblue1", 0x63,0xb8,0xff, 0 },
+    { "steelblue2", 0x5c,0xac,0xee, 0 },
+    { "steelblue3", 0x4f,0x94,0xcd, 0 },
+    { "steelblue4", 0x36,0x64,0x8b, 0 },
+    { "tan", 0xd2,0xb4,0x8c, 0 },
+    { "tan1", 0xff,0xa5,0x4f, 0 },
+    { "tan2", 0xee,0x9a,0x49, 0 },
+    { "tan3", 0xcd,0x85,0x3f, 0 },
+    { "tan4", 0x8b,0x5a,0x2b, 0 },
+    { "thistle", 0xd8,0xbf,0xd8, 0 },
+    { "thistle1", 0xff,0xe1,0xff, 0 },
+    { "thistle2", 0xee,0xd2,0xee, 0 },
+    { "thistle3", 0xcd,0xb5,0xcd, 0 },
+    { "thistle4", 0x8b,0x7b,0x8b, 0 },
+    { "tomato", 0xff,0x63,0x47, 0 },
+    { "tomato1", 0xff,0x63,0x47, 0 },
+    { "tomato2", 0xee,0x5c,0x42, 0 },
+    { "tomato3", 0xcd,0x4f,0x39, 0 },
+    { "tomato4", 0x8b,0x36,0x26, 0 },
+    { "turquoise", 0x40,0xe0,0xd0, 0 },
+    { "turquoise1", 0x00,0xf5,0xff, 0 },
+    { "turquoise2", 0x00,0xe5,0xee, 0 },
+    { "turquoise3", 0x00,0xc5,0xcd, 0 },
+    { "turquoise4", 0x00,0x86,0x8b, 0 },
+    { "violet", 0xee,0x82,0xee, 0 },
+    { "violetred", 0xd0,0x20,0x90, 0 },
+    { "violetred1", 0xff,0x3e,0x96, 0 },
+    { "violetred2", 0xee,0x3a,0x8c, 0 },
+    { "violetred3", 0xcd,0x32,0x78, 0 },
+    { "violetred4", 0x8b,0x22,0x52, 0 },
+    { "wheat", 0xf5,0xde,0xb3, 0 },
+    { "wheat1", 0xff,0xe7,0xba, 0 },
+    { "wheat2", 0xee,0xd8,0xae, 0 },
+    { "wheat3", 0xcd,0xba,0x96, 0 },
+    { "wheat4", 0x8b,0x7e,0x66, 0 },
+    { "white", 0xff,0xff,0xff, 0 },
+    { "whitesmoke", 0xf5,0xf5,0xf5, 0 },
+    { "yellow", 0xff,0xff,0x00, 0 },
+    { "yellow1", 0xff,0xff,0x00, 0 },
+    { "yellow2", 0xee,0xee,0x00, 0 },
+    { "yellow3", 0xcd,0xcd,0x00, 0 },
+    { "yellow4", 0x8b,0x8b,0x00, 0 },
+    { "yellowgreen", 0x9a,0xcd,0x32, 0 },
+    { NULL, 0, 0, 0, 0 }
+};
+
+struct Trans_key
+{
+    int amiga_key;
+    int vim_key;
+    int vim_shift_key;
+};
+
+struct Trans_key table_keys[] =
+{
+    { RAWKEY_BACKSPACE, K_BS },
+
+    { RAWKEY_TAB, K_TAB, K_S_TAB },
+
+    { RAWKEY_INSERT, K_INS, K_INS },
+    { RAWKEY_HOME, K_HOME, K_S_HOME },
+    { RAWKEY_END, K_END, K_S_END },
+    { RAWKEY_PAGEUP, K_PAGEUP, K_PAGEUP },
+    { RAWKEY_PAGEDOWN, K_PAGEDOWN, K_PAGEDOWN },
+    { RAWKEY_HELP, K_HELP, K_HELP },
+
+    { RAWKEY_UP, K_UP, K_S_UP },
+    { RAWKEY_LEFT, K_LEFT, K_S_LEFT },
+    { RAWKEY_DOWN, K_DOWN, K_S_DOWN },
+    { RAWKEY_RIGHT, K_RIGHT, K_S_RIGHT },
+
+    { RAWKEY_KP_7, K_K7, K_K7 },
+    { RAWKEY_KP_8, K_K8, K_K8 },
+    { RAWKEY_KP_9, K_K9, K_K9 },
+    { RAWKEY_KP_4, K_K4, K_K4 },
+    { RAWKEY_KP_5, K_K5, K_K5 },
+    { RAWKEY_KP_6, K_K6, K_K6 },
+    { RAWKEY_KP_1, K_K1, K_K1 },
+    { RAWKEY_KP_2, K_K2, K_K2 },
+    { RAWKEY_KP_3, K_K3, K_K3 },
+    { RAWKEY_KP_0, K_K0, K_K0 },
+    { RAWKEY_KP_DECIMAL, K_KPOINT, K_KPOINT },
+    { RAWKEY_KP_PLUS, K_KPLUS, K_KPLUS },
+    { RAWKEY_KP_ENTER, K_KENTER, K_KENTER },
+
+    { RAWKEY_F1, K_F1, K_S_F1 },
+    { RAWKEY_F2, K_F2, K_S_F2 },
+    { RAWKEY_F3, K_F3, K_S_F3 },
+    { RAWKEY_F4, K_F4, K_S_F4 },
+    { RAWKEY_F5, K_F5, K_S_F5 },
+    { RAWKEY_F6, K_F6, K_S_F6 },
+    { RAWKEY_F7, K_F7, K_S_F7 },
+    { RAWKEY_F8, K_F8, K_S_F8 },
+    { RAWKEY_F9, K_F9, K_S_F9 },
+    { RAWKEY_F10, K_F10, K_S_F10 },
+    { RAWKEY_F11, K_F11, K_S_F11 },
+    { RAWKEY_F12, K_F12, K_S_F12 },
+};
+
+struct MyColor MyColorTable[2048];
+
+void HandleEvent(unsigned long * object);
+static UBYTE getrealcolor(guicolor_T i);
+
+static struct
+{
+    unsigned int  key_sym;
+    char_u  vim_code0;
+    char_u  vim_code1;
+} special_keys[] =
+{
+    { 0, 0, 0 }
+};
+
+static int characterWidth = -1;
+static int characterHeight = -1;
+
+static struct
+{
+    BOOL active;
+    enum
+    {
+        CursorOff,
+        CursorOn,
+        CursorWait
+    } state;
+    int onTime;
+    int	offTime;
+    int	waitTime;
+    int	current;
+} cursor =
+{
+    TRUE,
+    CursorWait,
+    10,
+    10,
+    7,
+    0
+};
+
+enum DrawBoxMode
+{
+    DB_Filled,
+    DB_NotFilled
+};
+
+struct TextAttr aros_font =
+{
+    (STRPTR) "",     /* name */
+    0,               /* size */
+    0,               /* style */
+    0                /* flags */
+};
+
+
+static void TextDimensions(void)
+{
+    struct TextExtent textExt;
+
+    TextExtent(gui.window->RPort, (unsigned char *) "hq", 1, &textExt);
+
+    characterWidth = textExt.te_Width;
+    characterHeight = textExt.te_Height;
+}
+
+static int WidthCharToPoint(int width)
+{
+    return width * characterWidth;
+}
+
+static int HeightCharToPoint(int height)
+{
+    return height * characterHeight;
+}
+
+static void refreshBorder(void)
+{
+    RefreshWindowFrame(gui.window);
+}
+
+static void drawBox(enum DrawBoxMode mode,
+                    unsigned short col,
+                    unsigned short row,
+                    int w,
+                    int h,
+                    guicolor_T color)
+{
+    LONG apen = GetAPen(gui.window->RPort);
+    LONG x1, y1, x2, y2;
+
+    SetAPen(gui.window->RPort, getrealcolor(color));
+
+    x1 = WidthCharToPoint(col);
+    y1 = HeightCharToPoint(row + 1) - h;
+    x2 = x1 + w - 1;
+    y2 = HeightCharToPoint(row + 1) - 1;
+
+    switch(mode)
+    {
+        case DB_Filled:
+            RectFill(gui.window->RPort, x1, y1, x2, y2);
+            break;
+
+        case DB_NotFilled:
+            Move(gui.window->RPort, x1, y1);
+            Draw(gui.window->RPort, x2, y1);
+            Draw(gui.window->RPort, x2, y2);
+            Draw(gui.window->RPort, x1, y2);
+            Draw(gui.window->RPort, x1, y1);
+            break;
+    }
+
+    SetAPen(gui.window->RPort, apen);
+}
+
+scrollbar_T *own_gui_find_scrollbar(struct Gadget *bargad)
+{
+    win_T *wp;
+
+    if (gui.bottom_sbar.bargad == bargad)
+        return &gui.bottom_sbar;
+
+    FOR_ALL_WINDOWS(wp)
+    {
+        if (wp->w_scrollbars[SBAR_LEFT].bargad == bargad)
+            return &wp->w_scrollbars[SBAR_LEFT];
+        if (wp->w_scrollbars[SBAR_RIGHT].bargad == bargad)
+            return &wp->w_scrollbars[SBAR_RIGHT];
+    }
+    return NULL;
+}
+
+static int_u trans_modifiers(int modifiers)
+{
+    int_u vimModifiers = 0;
+
+    if (modifiers & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT | IEQUALIFIER_CAPSLOCK))
+        vimModifiers |= MOD_MASK_SHIFT;
+    if (modifiers & (IEQUALIFIER_CONTROL))
+        vimModifiers |= MOD_MASK_CTRL;
+    if (modifiers & (IEQUALIFIER_LALT | IEQUALIFIER_RALT))
+        vimModifiers |= MOD_MASK_ALT;
+    if (modifiers & (IEQUALIFIER_LCOMMAND | IEQUALIFIER_RCOMMAND))
+        vimModifiers |= MOD_MASK_META;
+    return (vimModifiers);
+}
+
+/* Add possible keys to queue */
+/* note: fetching vim_key may be wrong on big endian machines */
+void convert_raw_input(char_u *string, int *len, int code, int modifiers)
+{
+    int i;
+
+    for(i = 0; i < sizeof(table_keys) / sizeof(table_keys[0]); i++)
+    {
+        if(table_keys[i].amiga_key == code)
+        {
+            string[*len] = CSI;
+            *len = *len + 1;
+            if(modifiers & MOD_MASK_SHIFT)
+                string[*len] = KEY2TERMCAP0(table_keys[i].vim_shift_key);
+            else
+                string[*len] = KEY2TERMCAP0(table_keys[i].vim_key);
+            *len = *len + 1;
+            if(modifiers & MOD_MASK_SHIFT)
+                string[*len] = KEY2TERMCAP1(table_keys[i].vim_shift_key);
+            else
+                string[*len] = KEY2TERMCAP1(table_keys[i].vim_key);
+            *len = *len + 1;
+            break;
+        }
+    }
+}
+
+static enum event EventHandler(void)
+{
+    struct IntuiMessage *msg;
+    enum event returnEvent = ev_Ignore;
+    int class, code;
+    static int dragging = 0;
+    static int mouseX, mouseY;
+    char_u string[40];
+    BOOL quit_request = FALSE;
+    int vim_modifiers = 0;
+    int len = 0;
+    int mode;
+    int cx;
+    int cy;
+    int click_was_double;
+    scrollbar_T *scrollbar;
+    struct MenuItem *item;
+    int menuNumber;
+
+    msg = (struct IntuiMessage *) GetMsg(gui.window->UserPort);
+
+    if (!msg)
+    {
+        returnEvent = ev_NullEvent;
+    }
+    else
+    {
+        class = msg->Class;
+        code = msg->Code;
+
+        switch(class)
+        {
+            case IDCMP_INTUITICKS:
+               break;
+
+            case IDCMP_MOUSEBUTTONS:
+                if(msg->MouseX >= 0 &&
+                   msg->MouseX < gui.window->Width &&
+                   msg->MouseY >= 0 &&
+                   msg->MouseY < gui.window->Height)
+                {
+                   vim_modifiers = trans_modifiers(msg->Qualifier);
+
+                   /* Look for double clicks */
+                   click_was_double = DoubleClick(Last_Seconds,
+                                                  Last_Micros,
+                                                  msg->Seconds,
+                                                  msg->Micros);
+
+                   Last_Seconds = msg->Seconds;
+                   Last_Micros = msg->Micros;
+
+                   if (code == SELECTDOWN)
+                   {
+                       dragging = 1;
+                       gui_send_mouse_event(MOUSE_LEFT,
+                                            mouseX = msg->MouseX,
+                                            mouseY = msg->MouseY,
+                                            click_was_double,
+                                            vim_modifiers);
+                   }
+                   else if (code == SELECTUP)
+                   {
+                       dragging = 0;
+                       gui_send_mouse_event(MOUSE_RELEASE,
+                                            msg->MouseX,
+                                            msg->MouseY,
+                                            click_was_double,
+                                            vim_modifiers);
+                   }
+               }
+               returnEvent = ev_MouseButtons;
+               break;
+
+            case IDCMP_MOUSEMOVE:
+                if(msg->MouseX >= 0 &&
+                   msg->MouseX < gui.window->Width &&
+                   msg->MouseY >= 0 &&
+                   msg->MouseY < gui.window->Height)
+               {
+                   vim_modifiers = trans_modifiers(msg->Qualifier);
+
+                   mouseX = msg->MouseX;
+                   mouseY = msg->MouseY;
+                   if (dragging)
+                   {
+                       gui_send_mouse_event(MOUSE_DRAG, mouseX, mouseY, FALSE, vim_modifiers);
+                   }
+               }
+
+               if(gui.sel_bargad)
+               {
+                   if(gui.sel_bargad->bargad->Flags & GFLG_SELECTED)
+                   {
+                       long newtop = 0;
+                       GetAttr(PGA_Top, (Object *) gui.sel_bargad->bargad, (void *) &newtop);
+                       gui_drag_scrollbar(gui.sel_bargad, newtop, TRUE);
+                       out_flush();
+                   }
+                   else
+                   {
+                        gui.sel_bargad = NULL;
+                   }
+               }
+               returnEvent = ev_MouseMove;
+               break;
+
+            case IDCMP_VANILLAKEY:
+               returnEvent = ev_KeyStroke;
+
+               vim_modifiers = trans_modifiers(msg->Qualifier);
+               len = 0;
+
+               if (vim_modifiers)
+               {
+                   string[len++] = CSI;
+                   string[len++] = KS_MODIFIER;
+                   string[len++] = vim_modifiers;
+               }
+
+               if (code == CSI)
+               {
+                   /* Insert CSI as K_CSI.  Untested! */
+                   string[len++] = (char_u) code;
+                   string[len++] = KS_EXTRA;
+                   string[len++] = (int) KE_CSI;
+                   add_to_input_buf(string, len);
+               }
+               else if (code == 127)
+               {
+                   mode = get_shape_idx(FALSE);
+                   if(mode == SHAPE_IDX_I || mode == SHAPE_IDX_R || mode == SHAPE_IDX_CI)
+                   {
+                       string[len++] = CSI;
+                       string[len++] = 'k';
+                       string[len++] = 'D';
+                       add_to_input_buf(string, len);
+                   }
+               }
+               else
+               {
+                   if(code == 8)
+                   {
+                       mode = get_shape_idx(FALSE);
+                       if(mode != SHAPE_IDX_I &&
+                          mode != SHAPE_IDX_R &&
+                          mode != SHAPE_IDX_CI &&
+                          mode != SHAPE_IDX_C)
+                       {
+                            break;
+                       }
+                       if ((State & CMDLINE) != CMDLINE)
+                       {
+                           string[len++] = CSI;
+                           string[len++] = 'k';
+                           string[len++] = 'b';
+                           add_to_input_buf(string, len);
+                           break;
+                       }
+                   }
+                   string[len++] = (char_u) code;
+                   if (input_conv.vc_type != CONV_NONE)
+                   {
+                       len += convert_input(&string[len - 1], 1, sizeof(string));
+                   }
+                   //D(bug("LEN: %d %d %d", code, len, vim_modifiers));
+
+                   add_to_input_buf(string, len);
+               }
+               break;
+
+            case IDCMP_RAWKEY:
+               vim_modifiers = trans_modifiers(msg->Qualifier);
+               len = 0;
+
+               if (vim_modifiers)
+               {
+                   string[len++] = CSI;
+                   string[len++] = KS_MODIFIER;
+                   string[len++] = vim_modifiers;
+               }
+
+               convert_raw_input(string, &len, code, vim_modifiers);
+
+               //D(bug("RAW: %d %d\n", code, vim_modifiers));
+
+               if(len) add_to_input_buf(string, len);
+
+               if (msg->Code == RAWKEY_NM_WHEEL_UP)
+               {
+                   gui_send_mouse_event(MOUSE_4,
+                                        msg->MouseX,
+                                        msg->MouseY - (gui.screen->BarHeight + 1),
+                                        FALSE,
+                                        vim_modifiers);
+               }
+               else if (msg->Code == RAWKEY_NM_WHEEL_DOWN)
+               {
+                   gui_send_mouse_event(MOUSE_5,
+                                        msg->MouseX,
+                                        msg->MouseY - (gui.screen->BarHeight + 1),
+                                        FALSE,
+                                        vim_modifiers);
+               }
+
+               returnEvent = ev_KeyStroke;
+               break;
+
+            case IDCMP_MENUVERIFY:
+               returnEvent = ev_MenuVerify;
+               /* Menu verification requested */
+               switch (code)
+               {
+                   case MENUWAITING:
+                       /*
+                        ** It's not for us, the user is accessing another
+                        ** programs menu, this is a good time to do some
+                        ** cleanup etc
+                        */
+                       break;
+                   case MENUHOT:
+                       /*
+                        ** It is our menu that is going hot, we have kontrol
+                        ** Menu action can be cancelled by
+                        ** msg->Code = MENUCANCEL;
+                        */
+                       break;
+                   default:
+                       break;
+               }
+               break;
+
+            case IDCMP_MENUPICK:
+               returnEvent = ev_MenuPick;
+
+               menuNumber = code;
+               item = (struct MenuItem *) ItemAddress(gui.menu, menuNumber);
+               if (item)
+               {
+                   gui_menu_cb(GTMENUITEM_USERDATA(item));
+               }
+               break;
+
+            case IDCMP_CLOSEWINDOW:
+                quit_request = TRUE;
+                break;
+
+            case IDCMP_NEWSIZE:
+               cx = gui.window->Width;;
+               cy = gui.window->Height - (gui.screen->BarHeight + 1);
+               cx = ((cx / characterWidth) * characterWidth);;
+               cy = ((cy / characterHeight) * characterHeight) + characterHeight;
+               gui_resize_shell(cx, cy);
+               RefreshWindowFrame(gui.window);
+               returnEvent = ev_NewSize;
+               break;
+
+            case IDCMP_REFRESHWINDOW:
+               refreshBorder();
+               returnEvent = ev_RefreshWindow;
+               break;
+
+            case IDCMP_GADGETDOWN:
+            case IDCMP_GADGETUP:
+
+                scrollbar = own_gui_find_scrollbar((struct Gadget *) msg->IAddress);
+                switch(class)
+                {
+                    case IDCMP_GADGETUP:
+                        gui.sel_bargad = NULL;
+                        returnEvent = ev_GadgetUp;
+                        break;
+                    case IDCMP_GADGETDOWN:
+                        gui.sel_bargad = scrollbar;
+                        returnEvent = ev_GadgetDown;
+                        break;
+                }
+                if(scrollbar)
+                {
+                    long newtop = 0;
+                    GetAttr(PGA_Top, (Object *) scrollbar->bargad, (void *) &newtop);
+                    gui_drag_scrollbar(scrollbar, newtop, FALSE);
+                    out_flush();
+                }
+                break;
+
+            case IDCMP_MENUHELP:
+                returnEvent = ev_MenuHelp;
+                break;
+
+            case IDCMP_GADGETHELP:
+                returnEvent = ev_GadgetHelp;
+                break;
+
+            case IDCMP_INACTIVEWINDOW:
+                gui.in_focus = FALSE;
+                gui_update_cursor(TRUE, FALSE);
+                break;
+
+            case IDCMP_ACTIVEWINDOW:
+                gui.in_focus = TRUE;
+                gui_update_cursor(TRUE, FALSE);
+                break;
+
+            default:
+                break;
+
+        }
+        ReplyMsg((struct Message *) msg);
+    }
+
+    if (quit_request)
+    {
+        getout(0);
+    }
+
+    return returnEvent;
+}
+
+static int checkEventHandler(void)
+{
+    enum event happened;
+
+    do
+    {
+        happened = EventHandler();
+    }
+    while  (happened != ev_NullEvent);
+
+    return OK;
+}
+
+int gui_mch_set_blinking(long wait, long on, long off)
+{
+    cursor.waitTime = wait / 100;
+    cursor.onTime = on / 100;
+    cursor.offTime = off / 100;
+    return OK;
+}
+
+void gui_mch_prepare(int *argc, char **argv)
+{
+#if 0
+    SysBase = (struct ExecBase *) OpenLibrary((STRPTR) "exec.library", 0);
+    gfxBase = (struct GFXBase *) OpenLibrary((STRPTR) "graphics.library", 0);
+    layersBase = (struct LayersBase *) OpenLibrary((STRPTR) "layers.library", 0);
+    DiskfontBase = OpenLibrary((STRPTR) "diskfont.library", 0);
+#ifdef FEAT_ASL
+    AslBase = OpenLibrary((STRPTR) "asl.library", 0);
+#endif
+
+    if (!SysBase || !gfxBase || !layersBase || ! DiskfontBase
+#ifdef FEAT_ASL
+        || !AslBase
+#endif
+       )
+    {
+        exit(3);
+    }
+#endif
+}
+
+void atexitDoThis(void)
+{
+    gui_mch_exit(-1);
+}
+
+/*
+ * Check if the GUI can be started.  Called before gvimrc is sourced.
+ * Return OK or FAIL.
+ */
+int gui_mch_init_check(void)
+{
+#if 0
+    if (SysBase && gfxBase && layersBase && AslBase && DiskfontBase)
+        return OK;
+    return FAIL;
+#endif
+    return OK;
+}
+
+int gui_mch_init(void)
+{
+    int returnCode = FAIL; /* assume failure */
+
+    TimerMP = CreateMsgPort();
+    if (!TimerMP) return FAIL;
+
+    TimerIO = (struct timerequest *) CreateIORequest(TimerMP, sizeof(*TimerIO));
+    if (!TimerIO) return FAIL;
+
+    if (OpenDevice((STRPTR) "timer.device", UNIT_VBLANK, &TimerIO->tr_node, 0)) return FAIL;
+
+    gui.screen = OpenScreenTags( NULL,
+                                 SA_Left, 0,
+                                 SA_Top, 0,
+                                 SA_Type, CUSTOMSCREEN,
+                                 SA_Overscan, OSCAN_TEXT,
+                                 SA_LikeWorkbench , TRUE,
+                                 SA_AutoScroll, TRUE,
+                                 SA_Title, (ULONG) VIM_VERSION_LONG,
+                                 TAG_DONE
+                               );
+
+    gui.window = OpenWindowTags(NULL, WA_Left, 0,
+                                      WA_Top, (gui.screen->BarHeight + 1),
+                                      WA_Width, gui.screen->Width,
+                                      WA_Height, gui.screen->Height - (gui.screen->BarHeight + 1),
+                                      WA_Borderless, TRUE,
+                                      WA_Backdrop, TRUE,
+                                      WA_IDCMP, IDCMP,
+                                      WA_Flags, WFLAGS,
+                                      WA_AutoAdjust, FALSE,
+                                      WA_CustomScreen, gui.screen,
+                                      WA_MouseQueue, 1,
+                                      WA_RptQueue, 10,
+                                      WA_NoCareRefresh, TRUE,
+                                      WA_GimmeZeroZero, TRUE,
+                                      TAG_END);
+
+    if (gui.window)
+    {
+        gui.in_use = TRUE;
+        gui.in_focus = TRUE;
+        gui.norm_pixel = gui.def_norm_pixel = 1;
+        gui.back_pixel = gui.def_back_pixel = 0;
+
+        set_normal_colors();
+        gui_check_colors();
+
+        SetDrMd(gui.window->RPort, JAM2);
+        gui_mch_set_colors(gui.norm_pixel, gui.back_pixel);
+
+        atexit(atexitDoThis);
+
+        TextDimensions();
+        returnCode = OK; /* we've had success */
+        if (gui_win_x != -1 && gui_win_y != -1)
+        {
+            gui_mch_set_winpos(gui_win_x, gui_win_y);
+        }
+
+        gui_mch_clear_all();
+    }
+    gui.menu = NULL;
+
+    menuPtr = (struct NewMenu *) malloc(GUI_MCH_NBR_MENUS * sizeof(struct NewMenu));
+    memset(menuPtr, 0, GUI_MCH_NBR_MENUS * sizeof(struct NewMenu));
+    cur_menu_nbr = 0;
+
+    return returnCode;
+}
+
+void gui_mch_new_colors(void)
+{
+    SetAPen(gui.window->RPort, getrealcolor(gui.norm_pixel));
+    SetBPen(gui.window->RPort, getrealcolor(gui.back_pixel));
+}
+
+int gui_mch_open(void)
+{
+    highlight_gui_started();
+    return OK;
+}
+
+char_u *gui_mch_browse(int saving,
+                       char_u *title,
+                       char_u *dflt,          /* default name */
+                       char_u *ext,           /* default extension */
+                       char_u *initdir,       /* NULL = current dir */
+                       char_u *filter)        /* filter */
+{
+    char_u *result = NULL;
+
+#ifdef FEAT_ASL
+    file_req = AllocAslRequestTags(ASL_FileRequest, TAG_DONE);
+    if(file_req)
+    {
+        if(AslRequestTags(file_req,
+                          ASLFR_TitleText, title,
+                          ASLFR_Window, gui.window,
+                          ASLFR_InitialFile, dflt,
+                          ASLFR_InitialDrawer, initdir,
+                          ASLFR_InitialPattern, filter,
+                          ASLFR_DoSaveMode, saving == BROWSE_SAVE ? TRUE : FALSE,
+                          ASLFR_DrawersOnly, saving == BROWSE_DIR ? TRUE : FALSE,
+                          ASLFR_DoPatterns, TRUE,
+                          ASLFR_RejectIcons, TRUE,
+                          TAG_END))
+        {
+            long sellen = strlen((char *) file_req->fr_Drawer) + strlen((char *) file_req->fr_File) + 2;
+            if((result = (char_u *) malloc(sellen)))
+            {
+                memset(result, 0, sellen);
+                strcpy((char *) result, (char *) file_req->rf_Dir);
+                if(strlen((char *) file_req->rf_Dir)) strcat((char *) result, "/");
+                strcat((char *) result, (char *) file_req->rf_File);
+            }
+        }
+        FreeAslRequest(file_req);
+    }
+#else
+    /* TODO: create an alternative to asl ? */
+#endif
+
+    return(result);
+}
+
+void gui_mch_exit(int returnCode)
+{
+	if (TimerSent)
+    {
+        if (!CheckIO(&TimerIO->tr_node)) AbortIO(&TimerIO->tr_node);
+        WaitIO(&TimerIO->tr_node);
+        TimerSent = FALSE;
+    }
+
+    if (TimerIO)
+    {
+        CloseDevice(&TimerIO->tr_node);
+        DeleteIORequest(&TimerIO->tr_node);
+        TimerIO = NULL;
+    }
+
+    if (TimerMP)
+    {
+        DeleteMsgPort(TimerMP);
+        TimerMP = NULL;
+    }
+
+    if (gui.window)
+    {
+        int i;
+
+        i = 0;
+        for(;;)
+        {
+            if(menuPtr[i].nm_Label != NM_BARLABEL)
+            {
+                if(menuPtr[i].nm_Label) free((void *) menuPtr[i].nm_Label);
+            }
+            if(menuPtr[i].nm_CommKey)
+            {
+                free((void *) menuPtr[i].nm_CommKey);
+            }
+            if(menuPtr[i].nm_Type == NM_END) break;
+            i++;
+        }
+
+        for(i = 0; i < sizeof(table) / sizeof(table[0]); i++)
+        {
+            if (MyColorTable[i].alloced)
+            {
+                ReleasePen(gui.window->WScreen->ViewPort.ColorMap, MyColorTable[i].pen);
+                MyColorTable[i].alloced = FALSE;
+            }
+			if(table[i].allocated == TRUE)
+			{
+				if(table[i].name) free(table[i].name);
+			}
+        }
+
+		CloseWindow(gui.window);
+
+        CloseScreen(gui.screen);
+
+#if 0
+#ifdef FEAT_ASL
+        CloseLibrary((struct Library *) AslBase);
+#endif
+
+        CloseLibrary((struct Library *) DiskfontBase);
+        CloseLibrary((struct Library *) layersBase);
+        CloseLibrary((struct Library *) SysBase);
+        CloseLibrary((struct Library *) gfxBase);
+#endif
+
+        if(menuPtr) free(menuPtr);
+			cur_menu_nbr = 0;
+
+        gui.window = NULL;
+        gui.in_use = FALSE;
+    }
+}
+
+/*
+ * Get the position of the top left corner of the window.
+ */
+int gui_mch_get_winpos(int *x, int *y)
+{
+    if (gui.window)
+    {
+        *x = 0;
+        *y = 0;
+    }
+    else
+    {
+        return FAIL;
+    }
+
+    return OK;
+}
+
+/*
+ * Set the position of the top left corner of the window to the given
+ * coordinates.
+ */
+void gui_mch_set_winpos(int x, int y)
+{
+    if (gui.window)
+    {
+        ChangeWindowBox(gui.window,
+                        0,
+                        (gui.screen->BarHeight + 1),
+                        gui.window->Width,
+                        gui.window->Height - (gui.screen->BarHeight + 1)
+                       );
+    }
+}
+
+void gui_mch_set_shellsize(int width, int height,
+                           int min_width, int min_height,
+                           int base_width, int base_height,
+                           int direction)
+{
+    ChangeWindowBox(gui.window,
+                    0,
+                    (gui.screen->BarHeight + 1),
+                    WidthCharToPoint(width),
+                    HeightCharToPoint(height) - (gui.screen->BarHeight + 1)
+                   );
+    checkEventHandler();
+}
+
+void gui_mch_get_screen_dimensions(int *screen_w, int *screen_h)
+{
+    *screen_w = gui.window->Width;
+    *screen_h = gui.window->Height - (gui.screen->BarHeight + 1);
+}
+
+void gui_mch_set_text_area_pos(int x, int y, int w, int h)
+{
+
+}
+
+/* ----------------------------------------------------------
+   Scrollbars functions
+   ---------------------------------------------------------- */
+void gui_mch_create_scrollbar(scrollbar_T *sb, int orient)
+{
+    sb->bargad = NULL;
+    sb->orientation = orient;
+    sb->enabled = FALSE;
+    sb->old_size = -1;
+    sb->old_max = -1;
+    sb->old_val = -1;
+    sb->old_x = -1;
+    sb->old_y = -1;
+    sb->old_w = -1;
+    sb->old_h = -1;
+    if(sb->orientation == SBAR_HORIZ)
+    {
+        sb->bargad = NewObject(NULL, (STRPTR) PROPGCLASS,
+                               GA_Top, 0,
+                               GA_Left, 0,
+                               GA_Width, 0,
+                               GA_Height, 0,
+                               GA_Immediate, TRUE,
+                               GA_RelVerify, TRUE,
+                               GA_FollowMouse, TRUE,
+                               PGA_Borderless, TRUE,
+                               PGA_Freedom, FREEHORIZ,
+                               PGA_Total, 0,
+                               PGA_Visible, 0,
+                               PGA_Top, 0,
+                               PGA_NewLook, TRUE,
+                               TAG_END);
+    }
+    else
+    {
+        sb->bargad = NewObject(NULL, (STRPTR) PROPGCLASS,
+                               GA_Top, 0,
+                               GA_Left, 0,
+                               GA_Width, 0,
+                               GA_Height, 0,
+                               GA_Immediate, TRUE,
+                               GA_RelVerify, TRUE,
+                               GA_FollowMouse, TRUE,
+                               PGA_Borderless, TRUE,
+                               PGA_Freedom, FREEVERT,
+                               PGA_Total, 0,
+                               PGA_Visible, 0,
+                               PGA_Top, 0,
+                               PGA_NewLook, TRUE,
+                               TAG_END);
+    }
+
+    if(sb->bargad) AddGadget(gui.window, sb->bargad, -1);
+}
+
+void gui_mch_destroy_scrollbar(scrollbar_T *sb)
+{
+    if(sb->bargad)
+    {
+        RemoveGadget(gui.window, sb->bargad);
+        DisposeObject(sb->bargad);
+    }
+}
+ 
+void gui_mch_enable_scrollbar(scrollbar_T *sb, int flag)
+{
+    if(sb->bargad)
+    {
+        if(flag)
+        {
+            SetGadgetAttrs(sb->bargad, gui.window, NULL,
+                           GA_Disabled, FALSE,
+                           TAG_END);
+        }
+        else
+        {
+            SetGadgetAttrs(sb->bargad, gui.window, NULL,
+                           GA_Disabled, TRUE,
+                           TAG_END);
+        }
+    }
+}
+
+void gui_mch_set_scrollbar_thumb(scrollbar_T *sb, long val, long size, long max)
+{
+    if(sb->bargad)
+    {
+        if(sb->old_size != size ||
+           sb->old_max != max ||
+           sb->old_val != val)
+        {
+            SetGadgetAttrs(sb->bargad, gui.window, NULL,
+                           PGA_Visible, size,
+                           PGA_Total, max,
+                           PGA_Top, val,
+                           TAG_END);
+            sb->old_size = size;
+            sb->old_max = max;
+            sb->old_val = val;
+        }
+    }
+    return;
+
+}
+
+void gui_mch_set_scrollbar_pos(scrollbar_T *sb, int x, int y, int w, int h)
+{
+    if(sb->bargad)
+    {
+        if(sb->old_x != x ||
+           sb->old_y != y ||
+           sb->old_y != w ||
+           sb->old_y != h)
+        {
+            if(sb->orientation == SBAR_HORIZ)
+            {
+                SetGadgetAttrs(sb->bargad, gui.window, NULL,
+                               GA_Width, w,
+                               GA_Height, h,
+                               GA_Left, x,
+                               GA_Top, y - 1,
+                               TAG_END);
+            }
+            else
+            {
+                /* Nasty hack */
+                if(x) x = gui.window->Width - w;
+                else x = gui.window->Width - w - w;
+
+                SetGadgetAttrs(sb->bargad, gui.window, NULL,
+                               GA_Width, w,
+                               GA_Height, h,
+                               GA_Top, y,
+                               GA_Left, x,
+                               TAG_END);
+            }
+            sb->old_x = x;
+            sb->old_y = y;
+            sb->old_w = w;
+            sb->old_h = h;
+        }
+    }
+}
+
+/* ----------------------------------------------------------
+   Font functions
+   ---------------------------------------------------------- */
+char *gui_mch_get_fontname(GuiFont font, char *name)
+{
+//    D(bug("gui_mch_get_fontname() %s\n", name));
+    // ???
+    return name;
+}
+
+int gui_mch_init_font(char_u *font_name, int fontset)
+{
+//    D(bug("gui_mch_init_font() %s %d\n", font_name, fontset));
+    
+    gui.char_width = characterWidth;
+    gui.char_height = characterHeight;
+    gui.char_ascent = gui.window->RPort->TxBaseline;
+
+    return OK;
+}
+
+int gui_mch_adjust_charsize()
+{
+    return FAIL;
+}
+
+GuiFont gui_mch_get_font(char_u *name, int giveErrorIfMissing)
+{
+//    D(bug("gui_mch_get_font() %s\n", name));
+
+    return (int) NULL;
+}
+
+void gui_mch_set_font(GuiFont font)
+{
+//    D(bug("gui_mch_set_font()\n"));
+
+    gui.currFont = font;
+}
+
+void gui_mch_free_font(GuiFont font)
+{
+//    D(bug("gui_mch_free_font()\n"));
+    if (font)
+    {
+//        D("gui_mch_free_font");
+    }
+}
+
+int gui_mch_adjust_charheight(void)
+{
+//    D(bug("gui_mch_adjust_charheight()\n"));
+    // ???
+    return FAIL;
+}
+
+/* ----------------------------------------------------------
+   Colors functions
+   ---------------------------------------------------------- */
+int gui_mch_get_color_value_char(char value)
+{
+    int hex_table[] =
+    {
+        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1, -1,
+        0xa, 0xb, 0xc, 0xd, 0xe, 0xf
+    };
+    // Uppercase
+    if(value >= 'a' && value <= 'f') value -= 0x20;
+    if(value < '0' || value > 'F') return(-1);
+    return(hex_table[value - '0']);
+}
+
+guicolor_T gui_mch_get_color(char_u *name)
+{
+    guicolor_T color = INVALCOLOR;
+
+    int i;
+    int number_char;
+    if(name[0] == '#')
+    {
+        /* color by value */
+
+        /* Search it in our table */
+        for (i = 0; table[i].name != NULL; i++)
+        {
+            if (stricmp((char *) name, table[i].name) == 0)
+            {
+                /* Return it's offset if found */
+                return(i);
+            }
+        }
+
+        /* Otherwise, add it */
+        table[i].name = strdup((char *) name);
+        table[i].allocated = TRUE;
+       
+        table[i].red = 0;
+        table[i].green = 0;
+        table[i].blue = 0;
+        name++;
+        if(name[0] == '\0') return INVALCOLOR;
+        if((number_char = gui_mch_get_color_value_char(*name++)) == -1) return(INVALCOLOR);
+            table[i].red = (table[i].red << 4) | number_char;
+        if(name[0] == '\0') return INVALCOLOR;
+        if((number_char = gui_mch_get_color_value_char(*name++)) == -1) return(INVALCOLOR);
+            table[i].red = (table[i].red << 4) | number_char;
+        if(name[0] == '\0') return i;
+
+        if((number_char = gui_mch_get_color_value_char(*name++)) == -1) return(INVALCOLOR);
+            table[i].green = (table[i].green << 4) | number_char;
+        if(name[0] == '\0') return INVALCOLOR;
+        if((number_char = gui_mch_get_color_value_char(*name++)) == -1) return(INVALCOLOR);
+            table[i].green = (table[i].green << 4) | number_char;
+        if(name[0] == '\0') return i;
+
+        if((number_char = gui_mch_get_color_value_char(*name++)) == -1) return(INVALCOLOR);
+            table[i].blue = (table[i].blue << 4) | number_char;
+        if(name[0] == '\0') return INVALCOLOR;
+        if((number_char = gui_mch_get_color_value_char(*name++)) == -1) return(INVALCOLOR);
+            table[i].blue = (table[i].blue << 4) | number_char;
+
+        // Return it's newly created index from the table
+        return i;
+    }
+    else
+    {
+        /* color by name */
+        for (i = 0; table[i].name != NULL; i++)
+        {
+            if (stricmp((char *) name, table[i].name) == 0)
+            {
+                color = i;
+                break;
+            }
+        }
+    }
+    return color;
+}
+
+static UBYTE getrealcolor(guicolor_T i)
+{
+    if (!MyColorTable[i].alloced)
+    {
+        MyColorTable[i].pen = ObtainBestPen(gui.window->WScreen->ViewPort.ColorMap,
+                                            table[i].red * 0x01010101,
+                                            table[i].green * 0x01010101,
+                                            table[i].blue * 0x01010101,
+                                            OBP_FailIfBad, FALSE,
+                                            OBP_Precision, PRECISION_GUI,
+                                            TAG_DONE);
+        if (MyColorTable[i].pen != -1)
+        {
+            MyColorTable[i].alloced = TRUE;
+        }
+    }
+
+    return MyColorTable[i].pen;
+}
+
+void gui_mch_set_colors(guicolor_T fg, guicolor_T bg)
+{
+    SetABPenDrMd(gui.window->RPort, getrealcolor(fg), getrealcolor(bg), JAM2);
+}
+
+void gui_mch_set_fg_color(guicolor_T color)
+{
+    SetAPen(gui.window->RPort, getrealcolor(color));
+    SetDrMd(gui.window->RPort, JAM2);
+}
+
+void gui_mch_set_bg_color(guicolor_T color)
+{
+    SetBPen(gui.window->RPort, getrealcolor(color));
+}
+
+void gui_mch_set_sp_color(guicolor_T color)
+{
+    // could it be for SetOPen ?
+}
+
+long_u gui_mch_get_rgb(guicolor_T pixel)
+{
+    ULONG coltable[3], color;
+
+    GetRGB32(gui.window->WScreen->ViewPort.ColorMap,
+             getrealcolor(pixel),
+             1,
+             coltable);
+
+    color = ((coltable[0] & 0xFF000000) >> 8) |
+            ((coltable[1] & 0xFF000000) >> 16) |
+            ((coltable[2] & 0xFF000000) >> 24);
+
+    return color;
+}
+
+/* ----------------------------------------------------------
+   Mouse functions
+   ---------------------------------------------------------- */
+void gui_mch_getmouse(int *x, int *y)
+{
+    *x = gui.window->GZZMouseX;
+    *y = gui.window->GZZMouseY;
+}
+
+/*
+ * Get current y mouse coordinate in text window.
+ * Return -1 when unknown.
+ */
+int gui_mch_get_mouse_x()
+{
+    return gui.window->GZZMouseX;
+}
+
+int gui_mch_get_mouse_y()
+{
+    return gui.window->GZZMouseY;
+}
+
+void gui_mch_setmouse(int x, int y)
+{
+    /* TODO */
+}
+
+/* ----------------------------------------------------------
+   Text drawing functions
+   ---------------------------------------------------------- */
+void gui_mch_draw_string(int row, int col, char_u *s, int len, int flags)
+{
+    char tempstring[300];
+
+    memcpy(tempstring, s, len);
+    tempstring[len] = '\0';
+
+    if (flags & DRAW_TRANSP)
+    {
+        SetDrMd(gui.window->RPort, JAM1);
+        Move(gui.window->RPort,
+             WidthCharToPoint(col),
+             HeightCharToPoint(row) + gui.window->RPort->TxBaseline);
+        Text(gui.window->RPort, s, len);
+    }
+    else
+    {
+        SetDrMd(gui.window->RPort, JAM2);
+        Move(gui.window->RPort,
+             WidthCharToPoint(col),
+             HeightCharToPoint(row) + gui.window->RPort->TxBaseline);
+        Text(gui.window->RPort, s, len);
+    }
+
+    if (flags & DRAW_BOLD)
+    {
+        SetDrMd(gui.window->RPort, JAM1);
+        Move(gui.window->RPort,
+             WidthCharToPoint(col) + 1,
+             HeightCharToPoint(row) + gui.window->RPort->TxBaseline);
+        Text(gui.window->RPort, s, len);
+    }
+
+    if (flags & DRAW_UNDERL)
+    {
+        Move(gui.window->RPort,
+             WidthCharToPoint(col),
+             HeightCharToPoint(row + 1) - 1);
+        Draw(gui.window->RPort, WidthCharToPoint(col + len) - 1, HeightCharToPoint(row + 1) - 1);
+    }
+
+    SetDrMd(gui.window->RPort, JAM2);
+}
+
+void gui_mch_insert_lines(int row, int num_lines)
+{
+     ScrollWindowRaster(gui.window,
+                        0,
+                        -characterHeight * num_lines,
+                        WidthCharToPoint(gui.scroll_region_left),
+                        HeightCharToPoint(row),
+                        WidthCharToPoint(gui.scroll_region_right + 1) - 1,
+                        HeightCharToPoint(gui.scroll_region_bot +1 ) - 1);
+
+    gui_clear_block(row,
+                    gui.scroll_region_left,
+                    row + num_lines - 1,
+                    gui.scroll_region_right);
+
+}
+
+void gui_mch_draw_hollow_cursor(guicolor_T color)
+{
+    drawBox(DB_NotFilled, gui.col, gui.row, characterWidth, characterHeight, color);
+}
+
+void gui_mch_draw_part_cursor(int w,
+                              int h,
+                              guicolor_T color)
+{
+    drawBox(DB_Filled, gui.col, gui.row, w, h, color);
+}
+
+void gui_mch_settitle(char_u *title, char_u *icon)
+{
+    SetWindowTitles(gui.window, title, (STRPTR) ~0);
+}
+
+void gui_mch_stop_blink(void)
+{
+    gui_undraw_cursor();
+}
+
+void gui_mch_start_blink(void)
+{
+    gui_update_cursor(FALSE, FALSE);
+}
+
+void gui_mch_clear_block(int row1, int col1, int row2, int col2)
+{
+    UBYTE apen = GetAPen(gui.window->RPort);
+
+    SetAPen(gui.window->RPort, getrealcolor(gui.back_pixel));
+    RectFill(gui.window->RPort,
+             WidthCharToPoint(col1),
+             HeightCharToPoint(row1),
+             WidthCharToPoint(col2 + 1) - 1,
+             HeightCharToPoint(row2 + 1) - 1);
+    SetAPen(gui.window->RPort, apen);
+}
+
+void gui_mch_clear_all(void)
+{
+    SetRast(gui.window->RPort, GetBPen(gui.window->RPort));
+    refreshBorder();
+}
+
+void gui_mch_delete_lines(int row, int num_lines)
+{
+    ScrollWindowRaster(gui.window,
+                       0,
+                       characterHeight * num_lines,
+                       WidthCharToPoint(gui.scroll_region_left),
+                       HeightCharToPoint(row),
+                       WidthCharToPoint(gui.scroll_region_right + 1) - 1,
+                       HeightCharToPoint(gui.scroll_region_bot + 1) - 1
+                      );
+
+    gui_clear_block(gui.scroll_region_bot - num_lines + 1,
+                    gui.scroll_region_left,
+                    gui.scroll_region_bot,
+                    gui.scroll_region_right
+                   );
+
+}
+
+/* ----------------------------------------------------------
+   Keyboard functions
+   ---------------------------------------------------------- */
+int gui_mch_haskey(char_u *name)
+{
+    int i;
+
+    for (i = 0; special_keys[i].vim_code1 != NUL; i++)
+    {
+        if (name[0] == special_keys[i].vim_code0 &&
+            name[1] == special_keys[i].vim_code1)
+        {
+            return OK;
+        }
+    }
+    return FAIL;
+}
+
+/* ----------------------------------------------------------
+   Misc. functions
+   ---------------------------------------------------------- */
+void gui_mch_beep(void)
+{
+    /* I'm not certain that it works properly under AROS */
+	/*DisplayBeep(NULL); */
+}
+
+void gui_mch_flash(int msec)
+{
+    SetDrMd(gui.window->RPort, COMPLEMENT);
+    RectFill(gui.window->RPort,
+             0,
+             0,
+             gui.window->Width - 1,
+             gui.window->Height - 1);
+    Delay(msec * 50 / 1000);
+    RectFill(gui.window->RPort,
+             0,
+             0,
+             gui.window->Width - 1,
+             gui.window->Height - 1);
+    SetDrMd(gui.window->RPort, JAM2);
+}
+
+void gui_mch_invert_rectangle( int r, int c, int nr, int nc)
+{
+
+}
+
+void gui_mch_iconify(void)
+{
+
+}
+
+#if defined(FEAT_EVAL) || defined(PROTO)
+/*
+ * Bring the Vim window to the foreground.
+ */
+void gui_mch_set_foreground()
+{
+    WindowToFront(gui.window);
+}
+#endif
+
+void gui_mch_update(void)
+{
+    checkEventHandler();
+}
+
+int gui_mch_wait_for_chars(int wtime)
+{
+    ULONG timermask = 1L << TimerMP->mp_SigBit;
+    ULONG winmask = 1L << gui.window->UserPort->mp_SigBit;
+    int retval = FAIL;
+
+    if (wtime == -1) wtime = 1000000000;
+    if (wtime < 20) wtime = 20;
+
+    SetSignal(0, timermask);
+    TimerIO->tr_node.io_Command = TR_ADDREQUEST;
+    TimerIO->tr_time.tv_secs = wtime / 1000;
+    TimerIO->tr_time.tv_micro = (wtime % 1000) * 1000;
+    SendIO(&TimerIO->tr_node);
+    TimerSent = TRUE;
+
+    for(;;)
+    {
+        ULONG sigs = Wait(winmask | timermask);
+
+        if (sigs & winmask)
+        {
+            checkEventHandler();
+            if (!vim_is_input_buf_empty())
+            {
+                retval = OK;
+                if (!CheckIO(&TimerIO->tr_node)) AbortIO(&TimerIO->tr_node);
+                WaitIO(&TimerIO->tr_node);
+                TimerSent = FALSE;
+                break;
+            }
+        }
+
+        if (sigs & timermask)
+        {
+            struct Message *msg;
+
+            if ((msg = GetMsg(TimerMP)))
+            {
+                ReplyMsg(msg);
+                TimerSent = FALSE;
+                retval = FAIL;
+                break;
+            }
+        }
+    }
+
+    return retval;
+}
+
+void gui_mch_flush(void)
+{
+//    RefreshWindowFrame(gui.window);
+}
+
+/* ----------------------------------------------------------
+   Menus functions
+   ---------------------------------------------------------- */
+int search_insert_idx(vimmenu_T *parent, char *name)
+{
+    D(bug("search_insert_idx parent %s name %s\n", parent->name, name));
+
+    int i;
+    int j;
+    int parent_exist;
+    vimmenu_T *oldmenu;
+
+    /* Search if the parent exists */
+    parent_exist = FALSE;
+    for(i = 0; i < cur_menu_nbr; i++)
+    {
+        oldmenu = (vimmenu_T *) menuPtr[i].nm_UserData;
+        if(oldmenu == parent)
+        {
+            parent_exist = TRUE;
+            i++;
+            D(bug("(FOUND: %s/%s %d %d)\n", parent->name, name, i, cur_menu_nbr ));
+            break;
+        }
+    }
+
+    if(parent_exist)
+    {
+        /* Search for last entry with this parent from the found position */
+        parent_exist = FALSE;
+        for(; i < cur_menu_nbr; i++)
+        {
+            oldmenu = ((vimmenu_T *) menuPtr[i].nm_UserData)->parent;
+            if(oldmenu != parent)
+            {
+                 /* We can't be bothered by menu titles */
+                if(oldmenu)
+                {
+                    /* Was it already a sub menu ? Then go back 1 level */
+                    if(oldmenu->parent) continue;
+                }
+                    
+                D(bug(" (INSERT: %s/%s %d %d)\n", parent->name, name, i, cur_menu_nbr));
+                /* Prepare slot for insertion */
+                for(j = cur_menu_nbr - 1; j >= i; j--)
+                {
+                    memcpy(&menuPtr[j + 1], &menuPtr[j], sizeof(struct NewMenu));
+                }
+                memset(&menuPtr[i], 0, sizeof(struct NewMenu));
+                /* And return the menu entry where it should be inserted */
+                return(i);
+            }
+        }
+    }
+
+    return(-1);
+}
+
+void gui_mch_add_menu_item(vimmenu_T *menu, int idx)
+{
+    D(bug("gui_mch_add_menu_item name %s\n", menu->name));
+    struct NewMenu *menuitem = NULL;
+    char string[512];
+    int entry_type = NM_ITEM;
+    int entry_idx;
+
+    if(menu->parent)
+    {
+        if(stricmp((char *) menu->parent->name, "popupi") == 0 ||
+           stricmp((char *) menu->parent->name, "popupo") == 0 ||
+           stricmp((char *) menu->parent->name, "popups") == 0 ||
+           stricmp((char *) menu->parent->name, "popupn") == 0 ||
+           stricmp((char *) menu->parent->name, "popupv") == 0 ||
+           stricmp((char *) menu->parent->name, "popupc") == 0 ||
+           stricmp((char *) menu->parent->name, "popup") == 0)
+        {
+            return;
+        }
+
+        if(menu->parent->parent)
+        {
+            entry_type = NM_SUB;
+        }
+        entry_idx = search_insert_idx(menu->parent, (char *) menu->name);
+        if(entry_idx == -1) menuitem = &menuPtr[cur_menu_nbr];
+        else menuitem = &menuPtr[entry_idx];
+    }
+    else
+    {
+        return;
+    }
+
+    if (menu_is_separator(menu->name))
+    {
+        menuitem->nm_Type = entry_type;
+        menuitem->nm_Label = NM_BARLABEL;
+    }
+    else
+    {
+        menuitem->nm_Type = entry_type;
+        sprintf(string, "%s", menu->dname);
+        menuitem->nm_Label = (STRPTR) strdup(string);
+        if(menu->actext)
+        {
+            menuitem->nm_CommKey = (STRPTR) strdup((char *) menu->actext);
+            menuitem->nm_Flags = NM_COMMANDSTRING;
+        }
+    }
+    menuitem->nm_UserData = menu;
+    cur_menu_nbr++;
+}
+
+void gui_mch_add_menu(vimmenu_T *menu, int idx)
+{
+    D(bug("gui_mch_add_menu name %s\n", menu->name));
+    struct NewMenu *menubar = NULL;
+    int entry_type = NM_ITEM;
+    int entry_idx;
+
+    if (menu_is_popup(menu->name))
+    {
+        return;
+    }
+
+    if(menu->parent)
+    {
+        entry_idx = search_insert_idx(menu->parent, (char *) menu->name);
+        if(entry_idx == -1) menubar = &menuPtr[cur_menu_nbr];
+        else menubar = &menuPtr[entry_idx];
+
+        if (menu_is_separator(menu->name))
+        {
+            menubar->nm_Type = entry_type;
+            menubar->nm_Label = NM_BARLABEL;
+        }
+        else
+        {
+            menubar->nm_Type = entry_type;
+            menubar->nm_Label = menu->dname;
+        }
+    }
+    else
+    {
+        /* root */
+        menubar = &menuPtr[cur_menu_nbr];
+        menubar->nm_Type = NM_TITLE;
+        menubar->nm_Label = menu->dname;
+    }
+    menubar->nm_UserData = menu;
+    cur_menu_nbr++;
+}
+
+void gui_mch_toggle_tearoffs(int enable)
+{
+    /* no tearoff menus */
+}
+
+void gui_mch_enable_menu(int flag)
+{
+
+}
+
+void gui_mch_set_menu_pos(int x, int y, int w, int h)
+{
+
+}
+
+void gui_mch_destroy_menu(vimmenu_T *menu)
+{
+    D(bug("gui_mch_destroy_menu name %s\n", menu->name));
+    ClearMenuStrip(gui.window);
+    if(gui.menu) FreeMenus(gui.menu);
+    gui.menu = NULL;
+}
+
+void gui_mch_menu_grey(vimmenu_T *menu, int grey)
+{
+
+}
+
+void gui_mch_menu_hidden(vimmenu_T *menu, int hidden)
+{
+    D(bug("gui_mch_menu_hidden\n"));
+    ClearMenuStrip(gui.window);
+    if(gui.menu) FreeMenus(gui.menu);
+    gui.menu = NULL;
+}
+
+void gui_mch_draw_menubar(void)
+{
+    D(bug("gui_mch_draw_menubar\n"));
+    APTR vi;
+
+    gui.menu = CreateMenus(menuPtr, TAG_END);
+    if(gui.menu)
+    {
+        vi = GetVisualInfo(gui.screen, NULL);
+        LayoutMenus(gui.menu, vi,
+                              GTMN_NewLookMenus, TRUE,
+                              TAG_END);
+        SetMenuStrip(gui.window, gui.menu);
+    }
+}
+
+int clip_mch_own_selection(VimClipboard *cbd)
+{
+    return OK;
+}
+
+void gui_mch_show_popupmenu(vimmenu_T *menu)
+{
+    /* TODO */
+}
+
+void clip_mch_lose_selection(VimClipboard *cbd)
+{
+
+}
+
+void clip_mch_request_selection(VimClipboard *cbd)
+{
+
+}
+
+void clip_mch_set_selection(VimClipboard *cbd)
+{
+
+}
diff -Naur vim72-orig/src/gui_aros.h vim72/src/gui_aros.h
--- vim72-orig/src/gui_aros.h	1970-01-01 01:00:00.000000000 +0100
+++ vim72/src/gui_aros.h	2015-04-26 10:12:03.585828220 +0200
@@ -0,0 +1,35 @@
+/* vi:set ts=8 sts=4 sw=4:
+ *
+ * VIM - Vi IMproved		by Bram Moolenaar
+ *				Amiga GUI support by Michael Nielsen
+ *
+ * Do ":help uganda"  in Vim to read copying and usage conditions.
+ * Do ":help credits" in Vim to see a list of people who contributed.
+ *
+ * Amiga GUI header file.
+ */
+
+#ifndef _GUI_AROS_H_
+#define _GUI_AROS_H_
+
+enum event
+{
+    ev_NullEvent,
+    ev_MenuVerify,
+    ev_MenuPick,
+    ev_CloseWindow,
+    ev_NewSize,
+    ev_RefreshWindow,
+    ev_MouseButtons,
+    ev_MouseMove,
+    ev_GadgetDown,
+    ev_GadgetUp,
+    ev_KeyStroke,
+    ev_IntuiTicks,
+    ev_MenuHelp,
+    ev_GadgetHelp,
+
+    ev_Ignore
+};
+
+#endif
diff -Naur vim72-orig/src/gui.c vim72/src/gui.c
--- vim72-orig/src/gui.c	2015-04-26 10:11:05.169298447 +0200
+++ vim72/src/gui.c	2015-04-26 10:12:03.585828220 +0200
@@ -139,7 +139,7 @@
 		/* The read returns when the child closes the pipe (or when
 		 * the child dies for some reason). */
 		close(pipefd[1]);
-		(void)read(pipefd[0], &dummy, (size_t)1);
+		ignored = (int) read(pipefd[0], &dummy, (size_t)1);
 		close(pipefd[0]);
 	    }
 
@@ -222,9 +222,9 @@
 
     if (result != MAYBE)
     {
-	if (result == FAIL)
-	    EMSG(_("E229: Cannot start the GUI"));
-	return result;
+        if (result == FAIL)
+            EMSG(_("E229: Cannot start the GUI"));
+        return result;
     }
 
     gui.shell_created = FALSE;
@@ -234,6 +234,7 @@
     gui.dragged_wp = NULL;
     gui.pointer_hidden = FALSE;
     gui.col = 0;
+    gui.min_col = 0;
     gui.row = 0;
     gui.num_cols = Columns;
     gui.num_rows = Rows;
@@ -455,7 +456,7 @@
      */
     gui.in_use = TRUE;		/* Must be set after menus have been set up */
     if (gui_mch_init() == FAIL)
-	goto error;
+        goto error;
 
     /* Avoid a delay for an error message that was printed in the terminal
      * where Vim was started. */
@@ -484,12 +485,12 @@
 	    gui_init_font(*p_guifont == NUL ? hl_get_font_name()
 						  : p_guifont, FALSE) == FAIL)
     {
-	EMSG(_("E665: Cannot start GUI, no valid font found"));
-	goto error2;
+        EMSG(_("E665: Cannot start GUI, no valid font found"));
+        goto error2;
     }
 #ifdef FEAT_MBYTE
     if (gui_get_wide_font() == FAIL)
-	EMSG(_("E231: 'guifontwide' invalid"));
+        EMSG(_("E231: 'guifontwide' invalid"));
 #endif
 
     gui.num_cols = Columns;
@@ -499,8 +500,8 @@
     /* Create initial scrollbars */
     FOR_ALL_WINDOWS(wp)
     {
-	gui_create_scrollbar(&wp->w_scrollbars[SBAR_LEFT], SBAR_LEFT, wp);
-	gui_create_scrollbar(&wp->w_scrollbars[SBAR_RIGHT], SBAR_RIGHT, wp);
+        gui_create_scrollbar(&wp->w_scrollbars[SBAR_LEFT], SBAR_LEFT, wp);
+        gui_create_scrollbar(&wp->w_scrollbars[SBAR_RIGHT], SBAR_RIGHT, wp);
     }
     gui_create_scrollbar(&gui.bottom_sbar, SBAR_BOTTOM, NULL);
 
@@ -509,7 +510,7 @@
 #endif
 #ifdef FEAT_SUN_WORKSHOP
     if (usingSunWorkShop)
-	workshop_init();
+        workshop_init();
 #endif
 #ifdef FEAT_SIGN_ICONS
     sign_gui_started();
@@ -538,17 +539,17 @@
     if (gui_mch_open() != FAIL)
     {
 #ifdef FEAT_TITLE
-	maketitle();
-	resettitle();
+        maketitle();
+        resettitle();
 #endif
-	init_gui_options();
+        init_gui_options();
 #ifdef FEAT_ARABIC
 	/* Our GUI can't do bidi. */
-	p_tbidi = FALSE;
+        p_tbidi = FALSE;
 #endif
 #if defined(FEAT_GUI_GTK)
 	/* Give GTK+ a chance to put all widget's into place. */
-	gui_mch_update();
+        gui_mch_update();
 
 # ifdef FEAT_MENU
 	/* If there is no 'm' in 'guioptions' we need to remove the menu now.
@@ -647,7 +648,7 @@
     void
 gui_shell_closed()
 {
-    cmdmod_T	    save_cmdmod;
+    cmdmod_T save_cmdmod;
 
     save_cmdmod = cmdmod;
 
@@ -662,7 +663,7 @@
     /* If there are changed buffers, present the user with a dialog if
      * possible, otherwise give an error message. */
     if (!check_changed_any(FALSE))
-	getout(0);
+        getout(0);
 
     exiting = FALSE;
     cmdmod = save_cmdmod;
@@ -678,7 +679,6 @@
  * Return OK when able to set the font.  When it failed FAIL is returned and
  * the fonts are unchanged.
  */
-/*ARGSUSED*/
     int
 gui_init_font(font_list, fontset)
     char_u	*font_list;
@@ -732,12 +732,12 @@
 	    && STRCMP(font_list, "*") != 0
 	    && (font_list_empty || gui.norm_font == NOFONT))
     {
-	/*
-	 * Couldn't load any font in 'font_list', keep the current font if
-	 * there is one.  If 'font_list' is empty, or if there is no current
-	 * font, tell gui_mch_init_font() to try to find a font we can load.
-	 */
-	ret = gui_mch_init_font(NULL, FALSE);
+        /*
+         * Couldn't load any font in 'font_list', keep the current font if
+         * there is one.  If 'font_list' is empty, or if there is no current
+         * font, tell gui_mch_init_font() to try to find a font we can load.
+         */
+        ret = gui_mch_init_font(NULL, FALSE);
     }
 
     if (ret == OK)
@@ -781,35 +781,35 @@
     wp = wide_name;
     for (p = name; *p != NUL; ++p)
     {
-	*wp++ = *p;
-	if (*p == '-')
-	{
-	    ++i;
-	    if (i == 6)		/* font type: change "--" to "-*-" */
-	    {
-		if (p[1] == '-')
-		    *wp++ = '*';
-	    }
-	    else if (i == 12)	/* found the width */
-	    {
-		++p;
-		i = getdigits(&p);
-		if (i != 0)
-		{
-		    /* Double the width specification. */
-		    sprintf((char *)wp, "%d%s", i * 2, p);
-		    font = gui_mch_get_font(wide_name, FALSE);
-		    if (font != NOFONT)
-		    {
-			gui_mch_free_font(gui.wide_font);
-			gui.wide_font = font;
-			set_string_option_direct((char_u *)"gfw", -1,
-						      wide_name, OPT_FREE, 0);
-		    }
-		}
-		break;
-	    }
-	}
+        *wp++ = *p;
+        if (*p == '-')
+        {
+            ++i;
+            if (i == 6)		/* font type: change "--" to "-*-" */
+            {
+                if (p[1] == '-')
+                    *wp++ = '*';
+            }
+            else if (i == 12)	/* found the width */
+            {
+                ++p;
+                i = getdigits(&p);
+                if (i != 0)
+                {
+                    /* Double the width specification. */
+                    sprintf((char *)wp, "%d%s", i * 2, p);
+                    font = gui_mch_get_font(wide_name, FALSE);
+                    if (font != NOFONT)
+                    {
+                        gui_mch_free_font(gui.wide_font);
+                        gui.wide_font = font;
+                        set_string_option_direct((char_u *)"gfw", -1,
+                                          wide_name, OPT_FREE, 0);
+                    }
+                }
+                break;
+            }
+        }
     }
 }
 # endif /* !HAVE_GTK2 */
@@ -848,12 +848,12 @@
     if (font != NOFONT && gui.norm_font != NOFONT
 			 && pango_font_description_equal(font, gui.norm_font))
     {
-	gui.wide_font = NOFONT;
-	gui_mch_free_font(font);
+        gui.wide_font = NOFONT;
+        gui_mch_free_font(font);
     }
     else
 #endif
-	gui.wide_font = font;
+        gui.wide_font = font;
     return OK;
 }
 #endif
@@ -874,11 +874,11 @@
 gui_check_pos()
 {
     if (gui.row >= screen_Rows)
-	gui.row = screen_Rows - 1;
+        gui.row = screen_Rows - 1;
     if (gui.col >= screen_Columns)
-	gui.col = screen_Columns - 1;
+        gui.col = screen_Columns - 1;
     if (gui.cursor_row >= screen_Rows || gui.cursor_col >= screen_Columns)
-	gui.cursor_is_valid = FALSE;
+        gui.cursor_is_valid = FALSE;
 }
 
 /*
@@ -905,7 +905,7 @@
      * doesn't match 'columns' and 'lines.  ScreenLines[] isn't valid then. */
     if (!can_update_cursor || screen_Columns != gui.num_cols
 					       || screen_Rows != gui.num_rows)
-	return;
+        return;
 
     gui_check_pos();
     if (!gui.cursor_is_valid || force
@@ -956,27 +956,27 @@
 	    cattr = syn_id2colors(id, &cfg, &cbg);
 #if defined(USE_IM_CONTROL) || defined(FEAT_HANGULIN)
 	    {
-		static int iid;
-		guicolor_T fg, bg;
+            static int iid;
+            guicolor_T fg, bg;
 
-		if (
-# ifdef HAVE_GTK2
-			preedit_get_status()
+            if (
+# if defined(HAVE_GTK2) && !defined(FEAT_HANGULIN)
+                preedit_get_status()
 # else
-			im_get_status()
+                im_get_status()
 # endif
-			)
-		{
-		    iid = syn_name2id((char_u *)"CursorIM");
-		    if (iid > 0)
-		    {
-			syn_id2colors(iid, &fg, &bg);
-			if (bg != INVALCOLOR)
-			    cbg = bg;
-			if (fg != INVALCOLOR)
-			    cfg = fg;
-		    }
-		}
+                )
+            {
+                iid = syn_name2id((char_u *)"CursorIM");
+                if (iid > 0)
+                {
+                    syn_id2colors(iid, &fg, &bg);
+                    if (bg != INVALCOLOR)
+                        cbg = bg;
+                    if (fg != INVALCOLOR)
+                        cfg = fg;
+                }
+            }
 	    }
 #endif
 	}
@@ -1076,15 +1076,15 @@
 	     */
 	    if (shape_table[idx].shape == SHAPE_VER)
 	    {
-		cur_height = gui.char_height;
-		cur_width = (gui.char_width * shape_table[idx].percentage
-								  + 99) / 100;
+            cur_height = gui.char_height;
+            cur_width = (gui.char_width * shape_table[idx].percentage
+                                      + 99) / 100;
 	    }
 	    else
 	    {
-		cur_height = (gui.char_height * shape_table[idx].percentage
-								  + 99) / 100;
-		cur_width = gui.char_width;
+            cur_height = (gui.char_height * shape_table[idx].percentage
+                                      + 99) / 100;
+            cur_width = gui.char_width;
 	    }
 #ifdef FEAT_MBYTE
 	    if (has_mbyte && (*mb_off2cells)(LineOffset[gui.row] + gui.col,
@@ -1129,7 +1129,7 @@
 {
 # if !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_MOTIF)
     if (gui.menu_is_active && gui.in_use)
-	gui_mch_set_menu_pos(0, 0, gui.menu_width, gui.menu_height);
+        gui_mch_set_menu_pos(0, 0, gui.menu_width, gui.menu_height);
 # endif
 }
 #endif
@@ -1138,7 +1138,6 @@
  * Position the various GUI components (text area, menu).  The vertical
  * scrollbars are NOT handled here.  See gui_update_scrollbars().
  */
-/*ARGSUSED*/
     static void
 gui_position_components(total_width)
     int	    total_width;
@@ -1153,33 +1152,35 @@
 
     text_area_x = 0;
     if (gui.which_scrollbars[SBAR_LEFT])
-	text_area_x += gui.scrollbar_width;
-
+    {
+        text_area_x += gui.scrollbar_width;
+    }
     text_area_y = 0;
+
 #if defined(FEAT_MENU) && !(defined(FEAT_GUI_GTK) || defined(FEAT_GUI_PHOTON))
     gui.menu_width = total_width;
     if (gui.menu_is_active)
-	text_area_y += gui.menu_height;
+        text_area_y += gui.menu_height;
 #endif
 #if defined(FEAT_TOOLBAR) && defined(FEAT_GUI_MSWIN)
     if (vim_strchr(p_go, GO_TOOLBAR) != NULL)
-	text_area_y = TOOLBAR_BUTTON_HEIGHT + TOOLBAR_BORDER_HEIGHT;
+        text_area_y = TOOLBAR_BUTTON_HEIGHT + TOOLBAR_BORDER_HEIGHT;
 #endif
 
 # if defined(FEAT_GUI_TABLINE) && (defined(FEAT_GUI_MSWIN) \
 	|| defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_MAC))
     if (gui_has_tabline())
-	text_area_y += gui.tabline_height;
+        text_area_y += gui.tabline_height;
 #endif
 
 #if defined(FEAT_TOOLBAR) && (defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA))
     if (vim_strchr(p_go, GO_TOOLBAR) != NULL)
     {
 # ifdef FEAT_GUI_ATHENA
-	gui_mch_set_toolbar_pos(0, text_area_y,
-				gui.menu_width, gui.toolbar_height);
+        gui_mch_set_toolbar_pos(0, text_area_y,
+                                gui.menu_width, gui.toolbar_height);
 # endif
-	text_area_y += gui.toolbar_height;
+        text_area_y += gui.toolbar_height;
     }
 #endif
 
@@ -1198,11 +1199,13 @@
     gui_position_menu();
 #endif
     if (gui.which_scrollbars[SBAR_BOTTOM])
-	gui_mch_set_scrollbar_pos(&gui.bottom_sbar,
-				  text_area_x,
-				  text_area_y + text_area_height,
-				  text_area_width,
-				  gui.scrollbar_height);
+    {
+        gui_mch_set_scrollbar_pos(&gui.bottom_sbar,
+                      text_area_x,
+                      text_area_y + text_area_height,
+                      text_area_width,
+                      gui.scrollbar_height);
+    }
     gui.left_sbar_x = 0;
     gui.right_sbar_x = text_area_x + text_area_width;
 
@@ -1215,13 +1218,13 @@
     int
 gui_get_base_width()
 {
-    int	    base_width;
+    int	base_width;
 
     base_width = 2 * gui.border_offset;
     if (gui.which_scrollbars[SBAR_LEFT])
-	base_width += gui.scrollbar_width;
+        base_width += gui.scrollbar_width;
     if (gui.which_scrollbars[SBAR_RIGHT])
-	base_width += gui.scrollbar_width;
+        base_width += gui.scrollbar_width;
     return base_width;
 }
 
@@ -1231,11 +1234,11 @@
     int
 gui_get_base_height()
 {
-    int	    base_height;
+    int	base_height;
 
     base_height = 2 * gui.border_offset;
     if (gui.which_scrollbars[SBAR_BOTTOM])
-	base_height += gui.scrollbar_height;
+        base_height += gui.scrollbar_height;
 #ifdef FEAT_GUI_GTK
     /* We can't take the sizes properly into account until anything is
      * realized.  Therefore we recalculate all the values here just before
@@ -1243,24 +1246,24 @@
 #else
 # ifdef FEAT_MENU
     if (gui.menu_is_active)
-	base_height += gui.menu_height;
+        base_height += gui.menu_height;
 # endif
 # ifdef FEAT_TOOLBAR
     if (vim_strchr(p_go, GO_TOOLBAR) != NULL)
 #  if defined(FEAT_GUI_MSWIN) && defined(FEAT_TOOLBAR)
-	base_height += (TOOLBAR_BUTTON_HEIGHT + TOOLBAR_BORDER_HEIGHT);
+        base_height += (TOOLBAR_BUTTON_HEIGHT + TOOLBAR_BORDER_HEIGHT);
 #  else
-	base_height += gui.toolbar_height;
+        base_height += gui.toolbar_height;
 #  endif
 # endif
 # if defined(FEAT_GUI_TABLINE) && (defined(FEAT_GUI_MSWIN) \
 	|| defined(FEAT_GUI_MOTIF))
     if (gui_has_tabline())
-	base_height += gui.tabline_height;
+        base_height += gui.tabline_height;
 # endif
 # ifdef FEAT_FOOTER
     if (vim_strchr(p_go, GO_FOOTER) != NULL)
-	base_height += gui.footer_height;
+        base_height += gui.footer_height;
 # endif
 # if defined(FEAT_GUI_MOTIF) && defined(FEAT_MENU)
     base_height += gui_mch_text_area_extra_height();
@@ -1281,7 +1284,7 @@
     static int	busy = FALSE;
 
     if (!gui.shell_created)	    /* ignore when still initializing */
-	return;
+        return;
 
     /*
      * Can't resize the screen while it is being redrawn.  Remember the new
@@ -1289,9 +1292,9 @@
      */
     if (updating_screen || busy)
     {
-	new_pixel_width = pixel_width;
-	new_pixel_height = pixel_height;
-	return;
+        new_pixel_width = pixel_width;
+        new_pixel_height = pixel_height;
+        return;
     }
 
 again:
@@ -1311,13 +1314,13 @@
      * at the last line here (why does it have to be one row too low?).
      */
     if (State == ASKMORE || State == CONFIRM)
-	gui.row = gui.num_rows;
+        gui.row = gui.num_rows;
 
     /* Only comparing Rows and Columns may be sufficient, but let's stay on
      * the safe side. */
     if (gui.num_rows != screen_Rows || gui.num_cols != screen_Columns
 	    || gui.num_rows != Rows || gui.num_cols != Columns)
-	shell_resized();
+        shell_resized();
 
     gui_update_scrollbars(TRUE);
     gui_update_cursor(FALSE, TRUE);
@@ -1333,11 +1336,11 @@
      */
     if (new_pixel_height)
     {
-	pixel_width = new_pixel_width;
-	pixel_height = new_pixel_height;
-	new_pixel_width = 0;
-	new_pixel_height = 0;
-	goto again;
+        pixel_width = new_pixel_width;
+        pixel_height = new_pixel_height;
+        new_pixel_width = 0;
+        new_pixel_height = 0;
+        goto again;
     }
 }
 
@@ -1351,13 +1354,13 @@
 
     if (new_pixel_height)
     {
-	/* careful: gui_resize_shell() may postpone the resize again if we
-	 * were called indirectly by it */
-	w = new_pixel_width;
-	h = new_pixel_height;
-	new_pixel_width = 0;
-	new_pixel_height = 0;
-	gui_resize_shell(w, h);
+        /* careful: gui_resize_shell() may postpone the resize again if we
+         * were called indirectly by it */
+        w = new_pixel_width;
+        h = new_pixel_height;
+        new_pixel_width = 0;
+        new_pixel_height = 0;
+        gui_resize_shell(w, h);
     }
 }
 
@@ -1374,7 +1377,6 @@
  * If "fit_to_display" is TRUE then the size may be reduced to fit the window
  * on the screen.
  */
-/*ARGSUSED*/
     void
 gui_set_shellsize(mustset, fit_to_display, direction)
     int		mustset;		/* set by the user */
@@ -1389,17 +1391,21 @@
     int		min_height;
     int		screen_w;
     int		screen_h;
+#ifdef HAVE_GTK2
+    int     un_maximize = mustset;
+    int         did_adjust = 0;
+#endif
 
     if (!gui.shell_created)
-	return;
+        return;
 
 #ifdef MSWIN
     /* If not setting to a user specified size and maximized, calculate the
      * number of characters that fit in the maximized window. */
     if (!mustset && gui_mch_maximized())
     {
-	gui_mch_newfont();
-	return;
+        gui_mch_newfont();
+        return;
     }
 #endif
 
@@ -1409,52 +1415,77 @@
     if (!mustset && usingSunWorkShop
 				&& workshop_get_width_height(&width, &height))
     {
-	Columns = (width - base_width + gui.char_width - 1) / gui.char_width;
-	Rows = (height - base_height + gui.char_height - 1) / gui.char_height;
+        Columns = (width - base_width + gui.char_width - 1) / gui.char_width;
+        Rows = (height - base_height + gui.char_height - 1) / gui.char_height;
     }
     else
 #endif
     {
-	width = Columns * gui.char_width + base_width;
-	height = Rows * gui.char_height + base_height;
+        width = Columns * gui.char_width + base_width;
+        height = Rows * gui.char_height + base_height;
     }
 
     if (fit_to_display)
     {
-	gui_mch_get_screen_dimensions(&screen_w, &screen_h);
-	if ((direction & RESIZE_HOR) && width > screen_w)
-	{
-	    Columns = (screen_w - base_width) / gui.char_width;
-	    if (Columns < MIN_COLUMNS)
-		Columns = MIN_COLUMNS;
-	    width = Columns * gui.char_width + base_width;
-	}
-	if ((direction & RESIZE_VERT) && height > screen_h)
-	{
-	    Rows = (screen_h - base_height) / gui.char_height;
-	    check_shellsize();
-	    height = Rows * gui.char_height + base_height;
-	}
+        gui_mch_get_screen_dimensions(&screen_w, &screen_h);
+        if ((direction & RESIZE_HOR) && width > screen_w)
+        {
+            Columns = (screen_w - base_width) / gui.char_width;
+            if (Columns < MIN_COLUMNS)
+                Columns = MIN_COLUMNS;
+            width = Columns * gui.char_width + base_width;
+#ifdef HAVE_GTK2
+            ++did_adjust;
+#endif
+        }
+        if ((direction & RESIZE_VERT) && height > screen_h)
+        {
+            Rows = (screen_h - base_height) / gui.char_height;
+            check_shellsize();
+            height = Rows * gui.char_height + base_height;
+#ifdef HAVE_GTK2
+            ++did_adjust;
+#endif
+        }
+#ifdef HAVE_GTK2
+        if (did_adjust == 2 || (width + gui.char_width >= screen_w
+                     && height + gui.char_height >= screen_h))
+            /* don't unmaximize if at maximum size */
+            un_maximize = FALSE;
+#endif
     }
     gui.num_cols = Columns;
     gui.num_rows = Rows;
 
     min_width = base_width + MIN_COLUMNS * gui.char_width;
     min_height = base_height + MIN_LINES * gui.char_height;
-# ifdef FEAT_WINDOWS
+#ifdef FEAT_WINDOWS
     min_height += tabline_height() * gui.char_height;
-# endif
+#endif
+
+#ifdef HAVE_GTK2
+    if (un_maximize)
+    {
+    /* If the window size is smaller than the screen unmaximize the
+     * window, otherwise resizing won't work. */
+    gui_mch_get_screen_dimensions(&screen_w, &screen_h);
+    if ((width + gui.char_width < screen_w
+                   || height + gui.char_height * 2 < screen_h)
+        && gui_mch_maximized())
+        gui_mch_unmaximize();
+    }
+#endif
 
     gui_mch_set_shellsize(width, height, min_width, min_height,
 					  base_width, base_height, direction);
     if (fit_to_display)
     {
-	int	    x, y;
+        int	    x, y;
 
-	/* Some window managers put the Vim window left of/above the screen. */
-	gui_mch_update();
-	if (gui_mch_get_winpos(&x, &y) == OK && (x < 0 || y < 0))
-	    gui_mch_set_winpos(x < 0 ? 0 : x, y < 0 ? 0 : y);
+        /* Some window managers put the Vim window left of/above the screen. */
+        gui_mch_update();
+        if (gui_mch_get_winpos(&x, &y) == OK && (x < 0 || y < 0))
+            gui_mch_set_winpos(x < 0 ? 0 : x, y < 0 ? 0 : y);
     }
 
     gui_position_components(width);
@@ -1488,9 +1519,9 @@
     int	    mask;
 {
     if (mask > HL_ALL)		    /* highlight code */
-	gui.highlight_mask = mask;
+        gui.highlight_mask = mask;
     else			    /* mask */
-	gui.highlight_mask |= mask;
+        gui.highlight_mask |= mask;
 }
 
     void
@@ -1498,9 +1529,9 @@
     int	    mask;
 {
     if (mask > HL_ALL)		    /* highlight code */
-	gui.highlight_mask = HL_NORMAL;
+        gui.highlight_mask = HL_NORMAL;
     else			    /* mask */
-	gui.highlight_mask &= ~mask;
+        gui.highlight_mask &= ~mask;
 }
 
 /*
@@ -1556,26 +1587,26 @@
 /* #define DEBUG_GUI_WRITE */
 #ifdef DEBUG_GUI_WRITE
     {
-	int i;
-	char_u *str;
+        int i;
+        char_u *str;
 
-	printf("gui_write(%d):\n    ", len);
-	for (i = 0; i < len; i++)
-	    if (s[i] == ESC)
-	    {
-		if (i != 0)
-		    printf("\n    ");
-		printf("<ESC>");
-	    }
-	    else
-	    {
-		str = transchar_byte(s[i]);
-		if (str[0] && str[1])
-		    printf("<%s>", (char *)str);
-		else
-		    printf("%s", (char *)str);
-	    }
-	printf("\n");
+        printf("gui_write(%d):\n    ", len);
+        for (i = 0; i < len; i++)
+            if (s[i] == ESC)
+            {
+            if (i != 0)
+                printf("\n    ");
+                printf("<ESC>");
+            }
+            else
+            {
+            str = transchar_byte(s[i]);
+            if (str[0] && str[1])
+                printf("<%s>", (char *)str);
+            else
+                printf("%s", (char *)str);
+            }
+        printf("\n");
     }
 #endif
     while (len)
@@ -1626,13 +1657,13 @@
 		case 'V':	/* Set vertical scroll region */
 		    if (arg1 < arg2)
 		    {
-			gui.scroll_region_left = arg1;
-			gui.scroll_region_right = arg2;
+                gui.scroll_region_left = arg1;
+                gui.scroll_region_right = arg2;
 		    }
 		    else
 		    {
-			gui.scroll_region_left = arg2;
-			gui.scroll_region_right = arg1;
+                gui.scroll_region_left = arg2;
+                gui.scroll_region_right = arg1;
 		    }
 		    break;
 #endif
@@ -1692,7 +1723,7 @@
 	    }
 	    else if (s[0] == '\r')	/* CR */
 	    {
-		gui.col = 0;
+            gui.col = 0;
 	    }
 	    else if (s[0] == '\b')	/* Backspace */
 	    {
@@ -1745,7 +1776,7 @@
     /* When switching to another window the dragging must have stopped.
      * Required for GTK, dragged_sb isn't reset. */
     if (old_curwin != curwin)
-	gui.dragged_sb = SBAR_NONE;
+        gui.dragged_sb = SBAR_NONE;
 
     /* Update the scrollbars after clearing the screen or when switched
      * to another window.
@@ -1828,9 +1859,9 @@
 	else
 #endif
 	    if (gui.col + len > Columns)
-	    this_len = Columns - gui.col;
-	else
-	    this_len = len;
+            this_len = Columns - gui.col;
+        else
+            this_len = len;
 
 	(void)gui_outstr_nowrap(s, this_len,
 					  0, (guicolor_T)0, (guicolor_T)0, 0);
@@ -2010,9 +2041,9 @@
 #endif
 
     if (len < 0)
-	len = (int)STRLEN(s);
+        len = (int)STRLEN(s);
     if (len == 0)
-	return OK;
+        return OK;
 
 #ifdef FEAT_SIGN_ICONS
     if (*s == SIGN_BYTE
@@ -2099,41 +2130,41 @@
     bg_color = gui.back_pixel;
     if ((flags & GUI_MON_IS_CURSOR) && gui.in_focus)
     {
-	draw_flags |= DRAW_CURSOR;
-	fg_color = fg;
-	bg_color = bg;
-	sp_color = fg;
+		draw_flags |= DRAW_CURSOR;
+		fg_color = fg;
+		bg_color = bg;
+		sp_color = fg;
     }
     else if (aep != NULL)
     {
-	fg_color = aep->ae_u.gui.fg_color;
-	if (fg_color == INVALCOLOR)
-	    fg_color = gui.norm_pixel;
-	bg_color = aep->ae_u.gui.bg_color;
-	if (bg_color == INVALCOLOR)
-	    bg_color = gui.back_pixel;
-	sp_color = aep->ae_u.gui.sp_color;
-	if (sp_color == INVALCOLOR)
-	    sp_color = fg_color;
+		fg_color = aep->ae_u.gui.fg_color;
+		if (fg_color == INVALCOLOR)
+			fg_color = gui.norm_pixel;
+		bg_color = aep->ae_u.gui.bg_color;
+		if (bg_color == INVALCOLOR)
+			bg_color = gui.back_pixel;
+		sp_color = aep->ae_u.gui.sp_color;
+		if (sp_color == INVALCOLOR)
+			sp_color = fg_color;
     }
     else
     {
-	fg_color = gui.norm_pixel;
-	sp_color = fg_color;
+		fg_color = gui.norm_pixel;
+		sp_color = fg_color;
     }
 
     if (highlight_mask & (HL_INVERSE | HL_STANDOUT))
     {
-#if defined(AMIGA) || defined(RISCOS)
-	gui_mch_set_colors(bg_color, fg_color);
+#if defined(AMIGA) || defined(AROS) || defined(RISCOS)
+        gui_mch_set_colors(bg_color, fg_color);
 #else
-	gui_mch_set_fg_color(bg_color);
-	gui_mch_set_bg_color(fg_color);
+        gui_mch_set_fg_color(bg_color);
+        gui_mch_set_bg_color(fg_color);
 #endif
     }
     else
     {
-#if defined(AMIGA) || defined(RISCOS)
+#if defined(AMIGA) || defined(AROS) || defined(RISCOS)
 	gui_mch_set_colors(fg_color, bg_color);
 #else
 	gui_mch_set_fg_color(fg_color);
@@ -2144,8 +2175,7 @@
 
     /* Clear the selection if we are about to write over it */
     if (!(flags & GUI_MON_NOCLEAR))
-	clip_may_clear_selection(gui.row, gui.row);
-
+        clip_may_clear_selection(gui.row, gui.row);
 
 #ifndef MSWIN16_FASTTEXT
     /* If there's no bold font, then fake it */
@@ -2159,17 +2189,17 @@
      * just after a blank.
      */
     if (back != 0 && ((draw_flags & DRAW_BOLD) || (highlight_mask & HL_ITALIC)))
-	return FAIL;
+        return FAIL;
 
 #if defined(RISCOS) || defined(HAVE_GTK2)
     /* If there's no italic font, then fake it.
      * For GTK2, we don't need a different font for italic style. */
     if (hl_mask_todo & HL_ITALIC)
-	draw_flags |= DRAW_ITALIC;
+        draw_flags |= DRAW_ITALIC;
 
     /* Do we underline the text? */
     if (hl_mask_todo & HL_UNDERLINE)
-	draw_flags |= DRAW_UNDERL;
+        draw_flags |= DRAW_UNDERL;
 #else
     /* Do we underline the text? */
     if ((hl_mask_todo & HL_UNDERLINE)
@@ -2221,15 +2251,15 @@
 		    && fontset == NOFONTSET
 #  endif
 		    && gui.wide_font != NOFONT)
-		dowide = TRUE;
+            dowide = TRUE;
 	    else
-		dowide = FALSE;
+            dowide = FALSE;
 	    comping = utf_iscomposing(c);
 	    if (!comping)	/* count cells from non-composing chars */
-		cells += cn;
+            cells += cn;
 	    cl = utf_ptr2len(s + i);
 	    if (cl == 0)	/* hit end of string */
-		len = i + cl;	/* len must be wrong "cannot happen" */
+            len = i + cl;	/* len must be wrong "cannot happen" */
 
 	    /* print the string so far if it's the last character or there is
 	     * a composing character. */
@@ -2298,25 +2328,25 @@
     else
 # endif
     {
-	gui_mch_draw_string(gui.row, col, s, len, draw_flags);
+        gui_mch_draw_string(gui.row, col, s, len, draw_flags);
 # ifdef FEAT_MBYTE
-	if (enc_dbcs == DBCS_JPNU)
-	{
-	    int		clen = 0;
-	    int		i;
-
-	    /* Get the length in display cells, this can be different from the
-	     * number of bytes for "euc-jp". */
-	    for (i = 0; i < len; i += (*mb_ptr2len)(s + i))
-		clen += (*mb_ptr2cells)(s + i);
-	    len = clen;
-	}
+        if (enc_dbcs == DBCS_JPNU)
+        {
+            int		clen = 0;
+            int		i;
+
+            /* Get the length in display cells, this can be different from the
+             * number of bytes for "euc-jp". */
+            for (i = 0; i < len; i += (*mb_ptr2len)(s + i))
+                clen += (*mb_ptr2cells)(s + i);
+            len = clen;
+        }
 # endif
     }
 #endif /* !HAVE_GTK2 */
 
     if (!(flags & (GUI_MON_IS_CURSOR | GUI_MON_TRS_CURSOR)))
-	gui.col = col + len;
+        gui.col = col + len;
 
     /* May need to invert it when it's part of the selection. */
     if (flags & GUI_MON_NOCLEAR)
@@ -2499,13 +2529,13 @@
 #if defined(FEAT_MBYTE) && !defined(HAVE_GTK2)
 	    if (enc_utf8 && ScreenLinesUC[off] != 0)
 	    {
-		/* output multi-byte character separately */
-		nback = gui_screenchar(off, flags,
-					  (guicolor_T)0, (guicolor_T)0, back);
-		if (gui.col < Columns && ScreenLines[off + 1] == 0)
-		    idx = 2;
-		else
-		    idx = 1;
+            /* output multi-byte character separately */
+            nback = gui_screenchar(off, flags,
+                          (guicolor_T)0, (guicolor_T)0, back);
+            if (gui.col < Columns && ScreenLines[off + 1] == 0)
+                idx = 2;
+            else
+                idx = 1;
 	    }
 	    else if (enc_dbcs == DBCS_JPNU && ScreenLines[off] == 0x8e)
 	    {
@@ -2585,9 +2615,9 @@
 	return;
 
     if (row + count > gui.scroll_region_bot)
-	/* Scrolled out of region, just blank the lines out */
-	gui_clear_block(row, gui.scroll_region_left,
-			      gui.scroll_region_bot, gui.scroll_region_right);
+        /* Scrolled out of region, just blank the lines out */
+        gui_clear_block(row, gui.scroll_region_left,
+                      gui.scroll_region_bot, gui.scroll_region_right);
     else
     {
 	gui_mch_delete_lines(row, count);
@@ -2790,12 +2820,12 @@
 
 		string[3] = CSI;
 		string[4] = KS_EXTRA;
-		string[5] = (int)button_char;
+		string[5] = (int) button_char;
 
 		/* Pass the pointer coordinates of the scroll event so that we
 		 * know which window to scroll. */
 		row = gui_xy2colrow(x, y, &col);
-		string[6] = (char_u)(col / 128 + ' ' + 1);
+        string[6] = (char_u)(col / 128 + ' ' + 1);
 		string[7] = (char_u)(col % 128 + ' ' + 1);
 		string[8] = (char_u)(row / 128 + ' ' + 1);
 		string[9] = (char_u)(row % 128 + ' ' + 1);
@@ -2808,11 +2838,11 @@
 		    string[1] = KS_MODIFIER;
 		    string[2] = 0;
 		    if (modifiers & MOUSE_SHIFT)
-			string[2] |= MOD_MASK_SHIFT;
+                string[2] |= MOD_MASK_SHIFT;
 		    if (modifiers & MOUSE_CTRL)
-			string[2] |= MOD_MASK_CTRL;
+                string[2] |= MOD_MASK_CTRL;
 		    if (modifiers & MOUSE_ALT)
-			string[2] |= MOD_MASK_ALT;
+                string[2] |= MOD_MASK_ALT;
 		    add_to_input_buf(string, 10);
 		}
 		return;
@@ -2823,8 +2853,8 @@
     /* If a clipboard selection is in progress, handle it */
     if (clip_star.state == SELECT_IN_PROGRESS)
     {
-	clip_process_selection(button, X_2_COL(x), Y_2_ROW(y), repeated_click);
-	return;
+        clip_process_selection(button, X_2_COL(x), Y_2_ROW(y), repeated_click);
+        return;
     }
 
     /* Determine which mouse settings to look for based on the current mode */
@@ -2894,7 +2924,7 @@
      * Use modeless selection when holding CTRL and SHIFT pressed.
      */
     if ((modifiers & MOUSE_CTRL) && (modifiers & MOUSE_SHIFT))
-	checkfor = MOUSE_NONEF;
+        checkfor = MOUSE_NONEF;
 
     /*
      * In Ex mode, always use modeless selection.
@@ -3120,7 +3150,6 @@
  * If "oldval" is not NULL, "oldval" is the previous value, the new value is
  * in p_go.
  */
-/*ARGSUSED*/
     void
 gui_init_which_components(oldval)
     char_u	*oldval;
@@ -3179,32 +3208,36 @@
 	switch (*p)
 	{
 	    case GO_LEFT:
-		gui.which_scrollbars[SBAR_LEFT] = TRUE;
-		break;
+            gui.which_scrollbars[SBAR_LEFT] = TRUE;
+//            gui.min_col = 1;
+            break;
 	    case GO_RIGHT:
-		gui.which_scrollbars[SBAR_RIGHT] = TRUE;
-		break;
+            gui.which_scrollbars[SBAR_RIGHT] = TRUE;
+            break;
 #ifdef FEAT_VERTSPLIT
 	    case GO_VLEFT:
-		if (win_hasvertsplit())
-		    gui.which_scrollbars[SBAR_LEFT] = TRUE;
-		break;
+            if (win_hasvertsplit())
+            {
+                gui.which_scrollbars[SBAR_LEFT] = TRUE;
+//                gui.min_col = 1;
+            }
+            break;
 	    case GO_VRIGHT:
-		if (win_hasvertsplit())
-		    gui.which_scrollbars[SBAR_RIGHT] = TRUE;
-		break;
+            if (win_hasvertsplit())
+                gui.which_scrollbars[SBAR_RIGHT] = TRUE;
+            break;
 #endif
 	    case GO_BOT:
-		gui.which_scrollbars[SBAR_BOTTOM] = TRUE;
-		break;
+            gui.which_scrollbars[SBAR_BOTTOM] = TRUE;
+            break;
 #ifdef FEAT_MENU
 	    case GO_MENUS:
-		gui.menu_is_active = TRUE;
-		break;
+            gui.menu_is_active = TRUE;
+            break;
 #endif
 	    case GO_GREY:
-		/* make menu's have grey items, ignored here */
-		break;
+            /* make menu's have grey items, ignored here */
+            break;
 #ifdef FEAT_TOOLBAR
 	    case GO_TOOLBAR:
 		using_toolbar = TRUE;
@@ -3241,7 +3274,7 @@
 	    i = Rows;
 	    gui_update_tabline();
 	    Rows = i;
-	    need_set_size = RESIZE_VERT;
+	    need_set_size |= RESIZE_VERT;
 	    if (using_tabline)
 		fix_size = TRUE;
 	    if (!gui_use_tabline())
@@ -3263,23 +3296,25 @@
 		    )
 	    {
 		if (i == SBAR_BOTTOM)
+        {
 		    gui_mch_enable_scrollbar(&gui.bottom_sbar,
 						     gui.which_scrollbars[i]);
+        }
 		else
 		{
 		    FOR_ALL_WINDOWS(wp)
 		    {
-			gui_do_scrollbar(wp, i, gui.which_scrollbars[i]);
+                gui_do_scrollbar(wp, i, gui.which_scrollbars[i]);
 		    }
 		}
 		if (gui.which_scrollbars[i] != prev_which_scrollbars[i])
 		{
 		    if (i == SBAR_BOTTOM)
-			need_set_size = RESIZE_VERT;
+                need_set_size |= RESIZE_VERT;
 		    else
-			need_set_size = RESIZE_HOR;
+                need_set_size |= RESIZE_HOR;
 		    if (gui.which_scrollbars[i])
-			fix_size = TRUE;
+                fix_size = TRUE;
 		}
 	    }
 #ifdef FEAT_WINDOWS
@@ -3297,7 +3332,7 @@
 	    gui_mch_enable_menu(gui.menu_is_active);
 	    Rows = i;
 	    prev_menu_is_active = gui.menu_is_active;
-	    need_set_size = RESIZE_VERT;
+	    need_set_size |= RESIZE_VERT;
 	    if (gui.menu_is_active)
 		fix_size = TRUE;
 	}
@@ -3308,7 +3343,7 @@
 	{
 	    gui_mch_show_toolbar(using_toolbar);
 	    prev_toolbar = using_toolbar;
-	    need_set_size = RESIZE_VERT;
+	    need_set_size |= RESIZE_VERT;
 	    if (using_toolbar)
 		fix_size = TRUE;
 	}
@@ -3318,7 +3353,7 @@
 	{
 	    gui_mch_enable_footer(using_footer);
 	    prev_footer = using_footer;
-	    need_set_size = RESIZE_VERT;
+	    need_set_size |= RESIZE_VERT;
 	    if (using_footer)
 		fix_size = TRUE;
 	}
@@ -3330,10 +3365,11 @@
 	    prev_tearoff = using_tearoff;
 	}
 #endif
-	if (need_set_size)
+	if (need_set_size != 0)
 	{
 #ifdef FEAT_GUI_GTK
-	    long    c = Columns;
+        long    prev_Columns = Columns;
+        long    prev_Rows = Rows;
 #endif
 	    /* Adjust the size of the window to make the text area keep the
 	     * same size and to avoid that part of our window is off-screen
@@ -3349,11 +3385,14 @@
 	     * If you remove this, please test this command for resizing
 	     * effects (with optional left scrollbar): ":vsp|q|vsp|q|vsp|q".
 	     * Don't do this while starting up though.
-	     * And don't change Rows, it may have be reduced intentionally
-	     * when adding menu/toolbar/tabline. */
-	    if (!gui.starting)
-		(void)char_avail();
-	    Columns = c;
+         * Don't change Rows when adding menu/toolbar/tabline.
+         * Don't change Columns when adding vertical toolbar. */
+        if (!gui.starting && need_set_size != (RESIZE_VERT | RESIZE_HOR))
+        (void)char_avail();
+        if ((need_set_size & RESIZE_VERT) == 0)
+        Rows = prev_Rows;
+        if ((need_set_size & RESIZE_HOR) == 0)
+        Columns = prev_Columns;
 #endif
 	}
 #ifdef FEAT_WINDOWS
@@ -3592,7 +3631,7 @@
 	{
 	    FOR_ALL_WINDOWS(wp)
 	    {
-		gui_do_scrollbar(wp, i, FALSE);
+            gui_do_scrollbar(wp, i, FALSE);
 	    }
 	}
 	curtab->tp_prev_which_scrollbars[i] = -1;
@@ -3879,6 +3918,21 @@
  * Scrollbar stuff:
  */
 
+/*
+ * Called when something in the window layout has changed.
+ */
+    void
+gui_may_update_scrollbars()
+{
+    if (gui.in_use && starting == 0)
+    {
+    out_flush();
+    gui_init_which_components(NULL);
+    gui_update_scrollbars(TRUE);
+    }
+    need_mouse_correct = TRUE;
+}
+
     void
 gui_update_scrollbars(force)
     int		force;	    /* Force all scrollbars to get updated */
@@ -3899,7 +3953,7 @@
     /* Return straight away if there is neither a left nor right scrollbar.
      * On MS-Windows this is required anyway for scrollwheel messages. */
     if (!gui.which_scrollbars[SBAR_LEFT] && !gui.which_scrollbars[SBAR_RIGHT])
-	return;
+        return;
 #endif
 
     /*
@@ -3977,9 +4031,9 @@
 	     */
 	    sb->height = 0;	    /* Force update next time */
 	    if (gui.which_scrollbars[SBAR_LEFT])
-		gui_do_scrollbar(wp, SBAR_LEFT, FALSE);
+            gui_do_scrollbar(wp, SBAR_LEFT, FALSE);
 	    if (gui.which_scrollbars[SBAR_RIGHT])
-		gui_do_scrollbar(wp, SBAR_RIGHT, FALSE);
+            gui_do_scrollbar(wp, SBAR_RIGHT, FALSE);
 	    continue;
 	}
 	if (force || sb->height != wp->w_height
@@ -4038,17 +4092,17 @@
 	    }
 	    if (gui.which_scrollbars[SBAR_LEFT])
 	    {
-		gui_mch_set_scrollbar_pos(&wp->w_scrollbars[SBAR_LEFT],
-					  gui.left_sbar_x, y,
-					  gui.scrollbar_width, h);
-		gui_do_scrollbar(wp, SBAR_LEFT, TRUE);
+            gui_mch_set_scrollbar_pos(&wp->w_scrollbars[SBAR_LEFT],
+                          gui.left_sbar_x, y,
+                          gui.scrollbar_width, h);
+            gui_do_scrollbar(wp, SBAR_LEFT, TRUE);
 	    }
 	    if (gui.which_scrollbars[SBAR_RIGHT])
 	    {
-		gui_mch_set_scrollbar_pos(&wp->w_scrollbars[SBAR_RIGHT],
-					  gui.right_sbar_x, y,
-					  gui.scrollbar_width, h);
-		gui_do_scrollbar(wp, SBAR_RIGHT, TRUE);
+            gui_mch_set_scrollbar_pos(&wp->w_scrollbars[SBAR_RIGHT],
+                          gui.right_sbar_x, y,
+                          gui.scrollbar_width, h);
+            gui_do_scrollbar(wp, SBAR_RIGHT, TRUE);
 	    }
 	}
 
@@ -4193,7 +4247,7 @@
 	if (p_so != 0)
 	{
 	    cursor_correct();		/* fix window for 'so' */
-	    update_topline();		/* avoid up/down jump */
+	    update_topline(TRUE);		/* avoid up/down jump */
 	}
 	if (old_cursor.lnum != wp->w_cursor.lnum)
 	    coladvance(wp->w_curswant);
@@ -4407,7 +4461,7 @@
     if (curwin->w_p_wrap)
 	return FALSE;
 
-    if (curwin->w_leftcol == scrollbar_value)
+    if ((long_u) curwin->w_leftcol == scrollbar_value)
 	return FALSE;
 
     curwin->w_leftcol = (colnr_T)scrollbar_value;
@@ -4420,7 +4474,7 @@
 	    && longest_lnum < curwin->w_botline
 	    && !virtual_active())
     {
-	if (scrollbar_value > scroll_line_len(curwin->w_cursor.lnum))
+	if (scrollbar_value > (long_u) scroll_line_len(curwin->w_cursor.lnum))
 	{
 	    curwin->w_cursor.lnum = longest_lnum;
 	    curwin->w_cursor.col = 0;
@@ -4438,9 +4492,9 @@
 {
     if (gui.norm_pixel == gui.back_pixel || gui.norm_pixel == INVALCOLOR)
     {
-	gui_set_bg_color((char_u *)"White");
-	if (gui.norm_pixel == gui.back_pixel || gui.norm_pixel == INVALCOLOR)
-	    gui_set_fg_color((char_u *)"Black");
+		gui_set_bg_color((char_u *) "White");
+		if (gui.norm_pixel == gui.back_pixel || gui.norm_pixel == INVALCOLOR)
+			gui_set_fg_color((char_u *) "Black");
     }
 }
 
@@ -4471,7 +4525,7 @@
     guicolor_T	t;
 
     if (*name == NUL)
-	return INVALCOLOR;
+        return INVALCOLOR;
     t = gui_mch_get_color(name);
 
     if (t == INVALCOLOR
@@ -4479,7 +4533,7 @@
 	    && gui.in_use
 #endif
 	    )
-	EMSG2(_("E254: Cannot allocate color %s"), name);
+        EMSG2(_("E254: Cannot allocate color %s"), name);
     return t;
 }
 
@@ -4509,8 +4563,8 @@
 
     FOR_ALL_WINDOWS(wp)
     {
-	gui_mch_set_scrollbar_colors(&(wp->w_scrollbars[SBAR_LEFT]));
-	gui_mch_set_scrollbar_colors(&(wp->w_scrollbars[SBAR_RIGHT]));
+        gui_mch_set_scrollbar_colors(&(wp->w_scrollbars[SBAR_LEFT]));
+        gui_mch_set_scrollbar_colors(&(wp->w_scrollbars[SBAR_RIGHT]));
     }
     gui_mch_set_scrollbar_colors(&gui.bottom_sbar);
 }
@@ -4666,7 +4720,6 @@
 /*
  * Find window where the mouse pointer "y" coordinate is in.
  */
-/*ARGSUSED*/
     static win_T *
 xy2win(x, y)
     int		x;
@@ -4739,7 +4792,7 @@
 	gui_start();
     }
     if (!ends_excmd(*eap->arg))
-	ex_next(eap);
+        ex_next(eap);
 }
 
 #if ((defined(FEAT_GUI_X11) || defined(FEAT_GUI_GTK) || defined(FEAT_GUI_W32) \
@@ -4860,15 +4913,15 @@
     void
 gui_update_screen()
 {
-    update_topline();
+    update_topline(TRUE);
     validate_cursor();
 #ifdef FEAT_AUTOCMD
     /* Trigger CursorMoved if the cursor moved. */
     if (!finish_op && has_cursormoved()
 	    && !equalpos(last_cursormoved, curwin->w_cursor))
     {
-	apply_autocmds(EVENT_CURSORMOVED, NULL, NULL, FALSE, curbuf);
-	last_cursormoved = curwin->w_cursor;
+        apply_autocmds(EVENT_CURSORMOVED, NULL, NULL, FALSE, curbuf);
+        last_cursormoved = curwin->w_cursor;
     }
 #endif
     update_screen(0);	/* may need to update the screen */
@@ -4990,6 +5043,19 @@
     char_u	*p;
     regmatch_T	regmatch;
     int		save_did_emsg = did_emsg;
+    static int  busy = FALSE;
+
+    /* When the screen is being updated we should not change buffers and
+     * windows structures, it may cause freed memory to be used.  Also don't
+     * do this recursively (pressing "Find" quickly several times. */
+    if (updating_screen || busy)
+    return FALSE;
+
+    /* refuse replace when text cannot be changed */
+    if ((type == FRD_REPLACE || type == FRD_REPLACEALL) && text_locked())
+    return FALSE;
+
+    busy = TRUE;
 
     ga_init2(&ga, 1, 100);
     if (type == FRD_REPLACEALL)
@@ -5080,6 +5146,7 @@
     }
 
     vim_free(ga.ga_data);
+    busy = FALSE;
     return (ga.ga_len > 0);
 }
 
@@ -5120,7 +5187,6 @@
  * of dropped files, they will be freed in this function, and caller can't use
  * fnames after call this function.
  */
-/*ARGSUSED*/
     void
 gui_handle_drop(x, y, modifiers, fnames, count)
     int		x;
diff -Naur vim72-orig/src/gui.h vim72/src/gui.h
--- vim72-orig/src/gui.h	2015-04-26 10:11:05.172298423 +0200
+++ vim72/src/gui.h	2015-04-26 10:12:03.585828220 +0200
@@ -134,7 +134,7 @@
 #define SBAR_HORIZ	    1
 
 /* Default size of scrollbar */
-#define SB_DEFAULT_WIDTH    16
+#define SB_DEFAULT_WIDTH    10
 
 /* Default height of the menu bar */
 #define MENU_DEFAULT_HEIGHT 1		/* figure it out at runtime */
@@ -209,6 +209,19 @@
     unsigned long handler_id;   /* Id of "value_changed" signal handler */
 #endif
 
+#if defined(AROS) || defined(FEAT_GUI_AMIGA)
+    struct Gadget *bargad;
+    int old_size;
+    int old_max;
+    int old_val;
+    int old_x;
+    int old_y;
+    int old_w;
+    int old_h;
+    int orientation;
+    int enabled;
+#endif
+
 #ifdef FEAT_GUI_MSWIN
     HWND	id;		/* Id of real scroll bar */
     int		scroll_shift;	/* The scrollbar stuff can handle only up to
@@ -277,6 +290,7 @@
     win_T	*dragged_wp;	    /* Which WIN's sb being dragged, if any? */
     int		pointer_hidden;	    /* Is the mouse pointer hidden? */
     int		col;		    /* Current cursor column in GUI display */
+    int     min_col;
     int		row;		    /* Current cursor row in GUI display */
     int		cursor_col;	    /* Physical cursor column in GUI display */
     int		cursor_row;	    /* Physical cursor row in GUI display */
@@ -464,6 +478,15 @@
     int		visibility;	    /* Is window partially/fully obscured? */
 #endif
 
+#if defined(FEAT_GUI_AMIGA) || defined(AROS)
+    struct Screen *screen;      /* a handle to the amiga screen */
+    struct Window *window;      /* a handle to the amiga window */
+    struct Menu   *menu;        /* a pointer to the first menu */
+    struct TextFont *textfont;      /* a pointer to the font structure */
+    scrollbar_T *sel_bargad;
+    GuiFont currFont;       /* Current font */
+#endif
+
 #ifdef RISCOS
     int		window_handle;
     char_u	*window_title;
diff -Naur vim72-orig/src/main.c vim72/src/main.c
--- vim72-orig/src/main.c	2015-04-26 10:11:05.164298487 +0200
+++ vim72/src/main.c	2015-04-26 10:12:03.586828212 +0200
@@ -290,7 +290,6 @@
     clip_init(FALSE);		/* Initialise clipboard stuff */
     TIME_MSG("clipboard setup");
 #endif
-
     /*
      * Check if we have an interactive window.
      * On the Amiga: If there is no window, we open one with a newcli command
@@ -305,9 +304,9 @@
      * Can't do anything without it, exit when it fails.
      */
     if (win_alloc_first() == FAIL)
-	mch_exit(0);
+		mch_exit(0);
 
-    init_yank();		/* init yank buffers */
+    init_yank();				/* init yank buffers */
 
     alist_init(&global_alist);	/* Init the argument list to empty. */
 
@@ -509,10 +508,10 @@
 
     if (params.want_full_screen && !silent_mode)
     {
-	termcapinit(params.term);	/* set terminal name and get terminal
+		termcapinit(params.term);	/* set terminal name and get terminal
 				   capabilities (will set full_screen) */
-	screen_start();		/* don't know where cursor is now */
-	TIME_MSG("Termcap init");
+		screen_start();		/* don't know where cursor is now */
+		TIME_MSG("Termcap init");
     }
 
     /*
@@ -564,11 +563,11 @@
     if (p_lpl)
     {
 # ifdef VMS	/* Somehow VMS doesn't handle the "**". */
-	source_runtime((char_u *)"plugin/*.vim", TRUE);
+		source_runtime((char_u *)"plugin/*.vim", TRUE);
 # else
-	source_runtime((char_u *)"plugin/**/*.vim", TRUE);
+		source_runtime((char_u *)"plugin/**/*.vim", TRUE);
 # endif
-	TIME_MSG("loading plugins");
+		TIME_MSG("loading plugins");
     }
 #endif
 
@@ -590,8 +589,8 @@
      */
     if (recoverymode && fname == NULL)
     {
-	recover_names(NULL, TRUE, 0);
-	mch_exit(0);
+        recover_names(NULL, TRUE, 0);
+        mch_exit(0);
     }
 
     /*
@@ -623,19 +622,19 @@
     if (gui.starting)
     {
 #if defined(UNIX) || defined(VMS)
-	/* When something caused a message from a vimrc script, need to output
-	 * an extra newline before the shell prompt. */
-	if (did_emsg || msg_didout)
-	    putchar('\n');
+        /* When something caused a message from a vimrc script, need to output
+         * an extra newline before the shell prompt. */
+        if (did_emsg || msg_didout)
+            putchar('\n');
 #endif
 
-	gui_start();		/* will set full_screen to TRUE */
-	TIME_MSG("starting GUI");
-
-	/* When running "evim" or "gvim -y" we need the menus, exit if we
-	 * don't have them. */
-	if (!gui.in_use && params.evim_mode)
-	    mch_exit(1);
+        gui_start();		/* will set full_screen to TRUE */
+        TIME_MSG("starting GUI");
+
+        /* When running "evim" or "gvim -y" we need the menus, exit if we
+         * don't have them. */
+        if (!gui.in_use && params.evim_mode)
+            mch_exit(1);
     }
 #endif
 
@@ -649,8 +648,8 @@
      */
     if (*p_viminfo != NUL)
     {
-	read_viminfo(NULL, TRUE, FALSE, FALSE);
-	TIME_MSG("reading viminfo");
+        read_viminfo(NULL, TRUE, FALSE, FALSE);
+        TIME_MSG("reading viminfo");
     }
 #endif
 
@@ -661,15 +660,15 @@
      */
     if (params.edit_type == EDIT_QF)
     {
-	if (params.use_ef != NULL)
-	    set_string_option_direct((char_u *)"ef", -1,
-					   params.use_ef, OPT_FREE, SID_CARG);
-	if (qf_init(NULL, p_ef, p_efm, TRUE) < 0)
-	{
-	    out_char('\n');
-	    mch_exit(3);
-	}
-	TIME_MSG("reading errorfile");
+        if (params.use_ef != NULL)
+            set_string_option_direct((char_u *) "ef", -1,
+                                     params.use_ef, OPT_FREE, SID_CARG);
+        if (qf_init(NULL, p_ef, p_efm, TRUE) < 0)
+        {
+            out_char('\n');
+            mch_exit(3);
+        }
+        TIME_MSG("reading errorfile");
     }
 #endif
 
@@ -681,7 +680,7 @@
     starting = NO_BUFFERS;
     no_wait_return = FALSE;
     if (!exmode_active)
-	msg_scroll = FALSE;
+        msg_scroll = FALSE;
 
 #ifdef FEAT_GUI
     /*
@@ -694,10 +693,10 @@
     if (gui.in_use)
     {
 # ifdef FEAT_SUN_WORKSHOP
-	if (!usingSunWorkShop)
+        if (!usingSunWorkShop)
 # endif
-	    gui_wait_for_chars(50L);
-	TIME_MSG("GUI delay");
+            gui_wait_for_chars(50L);
+        TIME_MSG("GUI delay");
     }
 #endif
 
@@ -711,8 +710,8 @@
     if (!gui.in_use)
 # endif
     {
-	setup_term_clip();
-	TIME_MSG("setup clipboard");
+        setup_term_clip();
+        TIME_MSG("setup clipboard");
     }
 #endif
 
@@ -729,13 +728,13 @@
      * Using autocommands here may cause trouble...
      */
     if (params.edit_type == EDIT_STDIN && !recoverymode)
-	read_stdin();
+        read_stdin();
 
 #if defined(UNIX) || defined(VMS)
     /* When switching screens and something caused a message from a vimrc
      * script, need to output an extra newline on exit. */
     if ((did_emsg || msg_didout) && *T_TI != NUL)
-	newline_on_exit = TRUE;
+        newline_on_exit = TRUE;
 #endif
 
     /*
@@ -751,8 +750,8 @@
 
     if (need_wait_return || msg_didany)
     {
-	wait_return(TRUE);
-	TIME_MSG("waiting for return");
+        wait_return(TRUE);
+        TIME_MSG("waiting for return");
     }
 
     starttermcap();	    /* start termcap if not done by wait_return() */
@@ -762,7 +761,7 @@
     setmouse();				/* may start using the mouse */
 #endif
     if (scroll_region)
-	scroll_region_reset();		/* In case Rows changed */
+        scroll_region_reset();		/* In case Rows changed */
     scroll_start();	/* may scroll the screen to the right position */
 
     /*
@@ -773,18 +772,18 @@
 			&& !gui.in_use
 #endif
 					)
-	must_redraw = CLEAR;
+        must_redraw = CLEAR;
     else
     {
-	screenclear();			/* clear screen */
-	TIME_MSG("clearing screen");
+        screenclear();			/* clear screen */
+        TIME_MSG("clearing screen");
     }
 
 #ifdef FEAT_CRYPT
     if (params.ask_for_key)
     {
-	(void)get_crypt_key(TRUE, TRUE);
-	TIME_MSG("getting crypt key");
+        (void) get_crypt_key(TRUE, TRUE);
+        TIME_MSG("getting crypt key");
     }
 #endif
 
@@ -804,7 +803,7 @@
 
     /* Ex starts at last line of the file */
     if (exmode_active)
-	curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
+        curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
 
 #ifdef FEAT_AUTOCMD
     apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);
@@ -818,8 +817,8 @@
      */
     if (params.edit_type == EDIT_QF)
     {
-	qf_jump(NULL, 0, 0, FALSE);
-	TIME_MSG("jump to first error");
+        qf_jump(NULL, 0, 0, FALSE);
+        TIME_MSG("jump to first error");
     }
 #endif
 
@@ -834,11 +833,11 @@
 #ifdef FEAT_DIFF
     if (params.diff_mode)
     {
-	win_T	*wp;
+        win_T	*wp;
 
 	/* set options in each window for "vimdiff". */
-	for (wp = firstwin; wp != NULL; wp = wp->w_next)
-	    diff_win_options(wp, TRUE);
+        for (wp = firstwin; wp != NULL; wp = wp->w_next)
+            diff_win_options(wp, TRUE);
     }
 #endif
 
@@ -870,7 +869,7 @@
 
     /* Execute any "+", "-c" and "-S" arguments. */
     if (params.n_commands > 0)
-	exe_commands(&params);
+        exe_commands(&params);
 
     RedrawingDisabled = 0;
     redraw_all_later(NOT_VALID);
@@ -885,7 +884,7 @@
 
     /* start in insert mode */
     if (p_im)
-	need_start_insertmode = TRUE;
+        need_start_insertmode = TRUE;
 
 #ifdef FEAT_AUTOCMD
     apply_autocmds(EVENT_VIMENTER, NULL, NULL, FALSE, curbuf);
@@ -897,9 +896,9 @@
      * scrollbind, sync the scrollbind now. */
     if (curwin->w_p_diff && curwin->w_p_scb)
     {
-	update_topline();
-	check_scrollbind((linenr_T)0, 0L);
-	TIME_MSG("diff scrollbinding");
+        update_topline(TRUE);
+        check_scrollbind((linenr_T)0, 0L);
+        TIME_MSG("diff scrollbinding");
     }
 #endif
 
@@ -912,9 +911,9 @@
      * scrollbars.  This is skipped while creating them. */
     if (first_tabpage->tp_next != NULL)
     {
-	out_flush();
-	gui_init_which_components(NULL);
-	gui_update_scrollbars(TRUE);
+        out_flush();
+        gui_init_which_components(NULL);
+        gui_update_scrollbars(TRUE);
     }
     need_mouse_correct = TRUE;
 #endif
@@ -922,12 +921,12 @@
     /* If ":startinsert" command used, stuff a dummy command to be able to
      * call normal_cmd(), which will then start Insert mode. */
     if (restart_edit != 0)
-	stuffcharReadbuff(K_NOP);
+        stuffcharReadbuff(K_NOP);
 
 #ifdef FEAT_NETBEANS_INTG
     if (usingNetbeans)
-	/* Tell the client that it can start sending commands. */
-	netbeans_startup_done();
+        /* Tell the client that it can start sending commands. */
+        netbeans_startup_done();
 #endif
 
     TIME_MSG("before starting main loop");
@@ -1059,8 +1058,8 @@
 	    if (!finish_op && has_cursormoved()
 			     && !equalpos(last_cursormoved, curwin->w_cursor))
 	    {
-		apply_autocmds(EVENT_CURSORMOVED, NULL, NULL, FALSE, curbuf);
-		last_cursormoved = curwin->w_cursor;
+            apply_autocmds(EVENT_CURSORMOVED, NULL, NULL, FALSE, curbuf);
+            last_cursormoved = curwin->w_cursor;
 	    }
 #endif
 
@@ -1069,8 +1068,8 @@
 	     * here.  Avoids doing it for every change. */
 	    if (diff_need_scrollbind)
 	    {
-		check_scrollbind((linenr_T)0, 0L);
-		diff_need_scrollbind = FALSE;
+            check_scrollbind((linenr_T)0, 0L);
+            diff_need_scrollbind = FALSE;
 	    }
 #endif
 #if defined(FEAT_FOLDING) && defined(FEAT_VISUAL)
@@ -1096,7 +1095,7 @@
 	     * Before redrawing, make sure w_topline is correct, and w_leftcol
 	     * if lines don't wrap, and w_skipcol if lines wrap.
 	     */
-	    update_topline();
+	    update_topline(TRUE);
 	    validate_cursor();
 
 #ifdef FEAT_VISUAL
@@ -1221,13 +1220,13 @@
      * code.  POSIX requires this, although it's not 100% clear from the
      * standard. */
     if (exmode_active)
-	exitval += ex_exitval;
+		exitval += ex_exitval;
 
     /* Position the cursor on the last screen line, below all the text */
 #ifdef FEAT_GUI
     if (!gui.in_use)
 #endif
-	windgoto((int)Rows - 1, 0);
+		windgoto((int)Rows - 1, 0);
 
 #if defined(FEAT_EVAL) || defined(FEAT_SYN_HL)
     /* Optionally print hashtable efficiency. */
@@ -1243,21 +1242,21 @@
 # if defined FEAT_WINDOWS
     for (tp = first_tabpage; tp != NULL; tp = next_tp)
     {
-	next_tp = tp->tp_next;
-	for (wp = (tp == curtab)
-		    ? firstwin : tp->tp_firstwin; wp != NULL; wp = wp->w_next)
-	{
-	    buf = wp->w_buffer;
-	    if (buf->b_changedtick != -1)
-	    {
-		apply_autocmds(EVENT_BUFWINLEAVE, buf->b_fname, buf->b_fname,
-								  FALSE, buf);
-		buf->b_changedtick = -1;    /* note that we did it already */
-		/* start all over, autocommands may mess up the lists */
-		next_tp = first_tabpage;
-		break;
-	    }
-	}
+		next_tp = tp->tp_next;
+		for (wp = (tp == curtab)
+				? firstwin : tp->tp_firstwin; wp != NULL; wp = wp->w_next)
+		{
+			buf = wp->w_buffer;
+			if (buf->b_changedtick != -1)
+			{
+			apply_autocmds(EVENT_BUFWINLEAVE, buf->b_fname, buf->b_fname,
+									  FALSE, buf);
+			buf->b_changedtick = -1;    /* note that we did it already */
+			/* start all over, autocommands may mess up the lists */
+			next_tp = first_tabpage;
+			break;
+			}
+		}
     }
 # else
     apply_autocmds(EVENT_BUFWINLEAVE, curbuf, curbuf->b_fname, FALSE, curbuf);
@@ -1295,9 +1294,9 @@
 #endif
 	    )
     {
-	/* give the user a chance to read the (error) message */
-	no_wait_return = FALSE;
-	wait_return(FALSE);
+		/* give the user a chance to read the (error) message */
+		no_wait_return = FALSE;
+		wait_return(FALSE);
     }
 
 #ifdef FEAT_AUTOCMD
@@ -1334,7 +1333,7 @@
 #endif
 #ifdef FEAT_EVAL
     if (garbage_collect_at_exit)
-	garbage_collect();
+		garbage_collect();
 #endif
 
     mch_exit(exitval);
@@ -1457,11 +1456,14 @@
 	++initstr;
     }
 
+/* Gui is the default mode under AROS */
+#ifndef AROS
     if (TOLOWER_ASC(initstr[0]) == 'g' || initstr[0] == 'k')
+#endif
     {
-	main_start_gui();
+        main_start_gui();
 #ifdef FEAT_GUI
-	++initstr;
+        ++initstr;
 #endif
     }
 
@@ -1926,7 +1928,7 @@
 #endif
 #ifdef FEAT_DIFF
 	    case 'd':		/* "-d"		'diff' */
-# ifdef AMIGA
+# if defined(AMIGA) || defined(AROS)
 		/* check for "-dev {device}" */
 		if (argv[0][argv_idx] == 'e' && argv[0][argv_idx + 1] == 'v')
 		    want_argument = TRUE;
@@ -2354,7 +2356,7 @@
 #if defined(HAS_SWAP_EXISTS_ACTION)
     check_swap_exists_action();
 #endif
-#if !(defined(AMIGA) || defined(MACOS))
+#if (!(defined(AMIGA) && !defined(AROS)) || defined(MACOS))
     /*
      * Close stdin and dup it from stderr.  Required for GPM to work
      * properly, and for running external commands.
@@ -2744,7 +2746,7 @@
     }
     else if (!silent_mode)
     {
-#ifdef AMIGA
+#if defined(AMIGA) || defined(AROS)
 	struct Process	*proc = (struct Process *)FindTask(0L);
 	APTR		save_winptr = proc->pr_WindowPtr;
 
@@ -2849,7 +2851,7 @@
 	if (secure == 2)
 	    need_wait_return = TRUE;
 	secure = 0;
-#ifdef AMIGA
+#if defined(AMIGA) || defined(AROS)
 	proc->pr_WindowPtr = save_winptr;
 #endif
     }
@@ -3053,7 +3055,7 @@
     main_msg(_("-r\t\t\tList swap files and exit"));
     main_msg(_("-r (with file name)\tRecover crashed session"));
     main_msg(_("-L\t\t\tSame as -r"));
-#ifdef AMIGA
+#if defined(AMIGA) || defined(AROS)
     main_msg(_("-f\t\t\tDon't use newcli to open window"));
     main_msg(_("-dev <device>\t\tUse <device> for I/O"));
 #endif
diff -Naur vim72-orig/src/Make_aros.mak vim72/src/Make_aros.mak
--- vim72-orig/src/Make_aros.mak	1970-01-01 01:00:00.000000000 +0100
+++ vim72/src/Make_aros.mak	2015-04-26 10:12:03.586828212 +0200
@@ -0,0 +1,31 @@
+# Makefile for AROS
+
+CFLAGS     = -pipe -O2 --no-strict-aliasing -Wall -Iproto \
+             -DUSE_TMPNAM -DFEAT_MBYTE -DFEAT_GUI -DFEAT_ASL -DFEAT_BROWSE \
+             -DFEAT_MOUSE -DHAVE_STDARG_H -DFEAT_HUGE
+
+PRG        = vim
+LIBS       =
+CC         = i386-aros-gcc
+LD         = i386-aros-gcc
+RM         = rm
+STRIP      = strip
+CP         = cp
+
+SRCS       = buffer.c charset.c diff.c digraph.c edit.c eval.c ex_cmds.c ex_cmds2.c \
+             ex_docmd.c ex_eval.c ex_getln.c fileio.c fold.c getchar.c hardcopy.c \
+             hashtab.c main.c mark.c memfile.c memline.c menu.c message.c misc1.c \
+             misc2.c move.c mbyte.c normal.c ops.c option.c os_aros.c popupmnu.c \
+             quickfix.c regexp.c screen.c search.c spell.c syntax.c tag.c term.c \
+             ui.c undo.c window.c version.c gui_aros.c gui.c
+
+OBJS       = $(SRCS:.c=.o)
+
+$(PRG): $(OBJS)
+	${LD} $(OBJS) -o $(PRG) $(LIBS)
+
+.c.o:
+	${CC} -c ${CFLAGS} $< -o $@
+
+clean:
+	$(RM) -fv $(OBJS) $(PRG)
diff -Naur vim72-orig/src/mbyte.c vim72/src/mbyte.c
--- vim72-orig/src/mbyte.c	2015-04-26 10:11:05.165298479 +0200
+++ vim72/src/mbyte.c	2015-04-26 10:12:03.586828212 +0200
@@ -45,19 +45,19 @@
  * text manipulation, buffers, etc.  Conversion has to be done when characters
  * in another encoding are received or send:
  *
- *		       clipboard
- *			   ^
- *			   | (2)
- *			   V
+ *		           clipboard
+ *			       ^
+ *			       | (2)
+ *			       V
  *		   +---------------+
- *	      (1)  |		   | (3)
- *  keyboard ----->|	 core	   |-----> display
- *		   |		   |
+ *	      (1)      |	   | (3)
+ *  keyboard ----->| core  |-----> display
+ *		   |		       |
  *		   +---------------+
- *			   ^
- *			   | (4)
- *			   V
- *			 file
+ *			       ^
+ *			       | (4)
+ *			       V
+ *			       file
  *
  * (1) Typed characters arrive in the current locale.  Conversion is to be
  *     done when 'encoding' is different from 'termencoding'.
@@ -2948,7 +2948,9 @@
 		    && dbcs_screen_head_off(ScreenLines + LineOffset[row],
 					 ScreenLines + LineOffset[row] + col))
 		|| (enc_utf8 && ScreenLines[LineOffset[row] + col] == 0)))
-	return col - 1;
+    {
+        return col - 1;
+    }
     return col;
 }
 #endif
@@ -4842,8 +4844,10 @@
 
 	    status_area.x = 0;
 	    status_area.y = gui.char_height * Rows + gui.border_offset;
+#ifndef AROS
 	    if (gui.which_scrollbars[SBAR_BOTTOM])
-		status_area.y += gui.scrollbar_height;
+            status_area.y += gui.scrollbar_height;
+#endif
 #ifdef FEAT_MENU
 	    if (gui.menu_is_active)
 		status_area.y += gui.menu_height;
@@ -4855,8 +4859,10 @@
 	{
 	    status_area.x = 0;
 	    status_area.y = gui.char_height * Rows + gui.border_offset;
+#ifndef AROS
 	    if (gui.which_scrollbars[SBAR_BOTTOM])
-		status_area.y += gui.scrollbar_height;
+            status_area.y += gui.scrollbar_height;
+#endif
 #ifdef FEAT_MENU
 	    if (gui.menu_is_active)
 		status_area.y += gui.menu_height;
@@ -4870,8 +4876,10 @@
 	    pre_area.x = status_area.x + status_area.width;
 	    pre_area.y = gui.char_height * Rows + gui.border_offset;
 	    pre_area.width = gui.char_width * Columns - pre_area.x;
+#ifndef AROS
 	    if (gui.which_scrollbars[SBAR_BOTTOM])
-		pre_area.y += gui.scrollbar_height;
+            pre_area.y += gui.scrollbar_height;
+#endif
 #ifdef FEAT_MENU
 	    if (gui.menu_is_active)
 		pre_area.y += gui.menu_height;
@@ -5847,7 +5855,7 @@
     return OK;
 }
 
-#if defined(FEAT_GUI) || defined(AMIGA) || defined(WIN3264) \
+#if defined(FEAT_GUI) || defined(AMIGA) || defined(AROS) || defined(WIN3264) \
 	|| defined(MSDOS) || defined(PROTO)
 /*
  * Do conversion on typed input characters in-place.
diff -Naur vim72-orig/src/memfile.c vim72/src/memfile.c
--- vim72-orig/src/memfile.c	2015-04-26 10:11:05.164298487 +0200
+++ vim72/src/memfile.c	2015-04-26 10:12:03.586828212 +0200
@@ -56,19 +56,6 @@
 # endif
 #endif
 
-/*
- * for Amiga Dos 2.0x we use Flush
- */
-#ifdef AMIGA
-# ifdef FEAT_ARP
-extern int dos2;			/* this is in os_amiga.c */
-# endif
-# ifdef SASC
-#  include <proto/dos.h>
-#  include <ios1.h>			/* for chkufb() */
-# endif
-#endif
-
 #define MEMFILE_PAGE_SIZE 4096		/* default page size */
 
 static long_u	total_mem_used = 0;	/* total memory used for memfiles */
@@ -130,24 +117,24 @@
 #endif
 
     if ((mfp = (memfile_T *)alloc((unsigned)sizeof(memfile_T))) == NULL)
-	return NULL;
+        return NULL;
 
     if (fname == NULL)	    /* no file for this memfile, use memory only */
     {
-	mfp->mf_fname = NULL;
-	mfp->mf_ffname = NULL;
-	mfp->mf_fd = -1;
+        mfp->mf_fname = NULL;
+        mfp->mf_ffname = NULL;
+        mfp->mf_fd = -1;
     }
     else
     {
-	mf_do_open(mfp, fname, flags);	/* try to open the file */
+        mf_do_open(mfp, fname, flags);	/* try to open the file */
 
-	/* if the file cannot be opened, return here */
-	if (mfp->mf_fd < 0)
-	{
-	    vim_free(mfp);
-	    return NULL;
-	}
+        /* if the file cannot be opened, return here */
+        if (mfp->mf_fd < 0)
+        {
+            vim_free(mfp);
+            return NULL;
+        }
     }
 
     mfp->mf_free_first = NULL;		/* free list is empty */
@@ -157,8 +144,8 @@
     mfp->mf_used_count = 0;
     for (i = 0; i < MEMHASHSIZE; ++i)
     {
-	mfp->mf_hash[i] = NULL;		/* hash lists are empty */
-	mfp->mf_trans[i] = NULL;	/* trans lists are empty */
+        mfp->mf_hash[i] = NULL;		/* hash lists are empty */
+        mfp->mf_trans[i] = NULL;	/* trans lists are empty */
     }
     mfp->mf_page_size = MEMFILE_PAGE_SIZE;
 
@@ -179,9 +166,9 @@
 
     if (mfp->mf_fd < 0 || (flags & (O_TRUNC|O_EXCL))
 		      || (size = lseek(mfp->mf_fd, (off_t)0L, SEEK_END)) <= 0)
-	mfp->mf_blocknr_max = 0;	/* no file or empty file */
+        mfp->mf_blocknr_max = 0;	/* no file or empty file */
     else
-	mfp->mf_blocknr_max = (blocknr_T)((size + mfp->mf_page_size - 1)
+        mfp->mf_blocknr_max = (blocknr_T)((size + mfp->mf_page_size - 1)
 							 / mfp->mf_page_size);
     mfp->mf_blocknr_min = -1;
     mfp->mf_neg_count = 0;
@@ -193,8 +180,8 @@
      * Avoid overflow by first reducing page size as much as possible.
      */
     {
-	int	    shift = 10;
-	unsigned    page_size = mfp->mf_page_size;
+	int shift = 10;
+	unsigned page_size = mfp->mf_page_size;
 
 	while (shift > 0 && (page_size & 1) == 0)
 	{
@@ -227,7 +214,7 @@
     mf_do_open(mfp, fname, O_RDWR|O_CREAT|O_EXCL); /* try to open the file */
 
     if (mfp->mf_fd < 0)
-	return FAIL;
+        return FAIL;
 
     mfp->mf_dirty = TRUE;
     return OK;
@@ -246,29 +233,29 @@
     int		i;
 
     if (mfp == NULL)		    /* safety check */
-	return;
+        return;
     if (mfp->mf_fd >= 0)
     {
-	if (close(mfp->mf_fd) < 0)
-	    EMSG(_(e_swapclose));
+        if (close(mfp->mf_fd) < 0)
+            EMSG(_(e_swapclose));
     }
     if (del_file && mfp->mf_fname != NULL)
-	mch_remove(mfp->mf_fname);
+        mch_remove(mfp->mf_fname);
 					    /* free entries in used list */
     for (hp = mfp->mf_used_first; hp != NULL; hp = nextp)
     {
-	total_mem_used -= hp->bh_page_count * mfp->mf_page_size;
-	nextp = hp->bh_next;
-	mf_free_bhdr(hp);
+        total_mem_used -= hp->bh_page_count * mfp->mf_page_size;
+        nextp = hp->bh_next;
+        mf_free_bhdr(hp);
     }
     while (mfp->mf_free_first != NULL)	    /* free entries in free list */
 	vim_free(mf_rem_free(mfp));
     for (i = 0; i < MEMHASHSIZE; ++i)	    /* free entries in trans lists */
-	for (tp = mfp->mf_trans[i]; tp != NULL; tp = tpnext)
-	{
-	    tpnext = tp->nt_next;
-	    vim_free(tp);
-	}
+        for (tp = mfp->mf_trans[i]; tp != NULL; tp = tpnext)
+        {
+            tpnext = tp->nt_next;
+            vim_free(tp);
+        }
     vim_free(mfp->mf_fname);
     vim_free(mfp->mf_ffname);
     vim_free(mfp);
@@ -287,16 +274,16 @@
 
     mfp = buf->b_ml.ml_mfp;
     if (mfp == NULL || mfp->mf_fd < 0)		/* nothing to close */
-	return;
+        return;
 
     if (getlines)
     {
-	/* get all blocks in memory by accessing all lines (clumsy!) */
-	mf_dont_release = TRUE;
-	for (lnum = 1; lnum <= buf->b_ml.ml_line_count; ++lnum)
-	    (void)ml_get_buf(buf, lnum, FALSE);
-	mf_dont_release = FALSE;
-	/* TODO: should check if all blocks are really in core */
+        /* get all blocks in memory by accessing all lines (clumsy!) */
+        mf_dont_release = TRUE;
+        for (lnum = 1; lnum <= buf->b_ml.ml_line_count; ++lnum)
+            (void)ml_get_buf(buf, lnum, FALSE);
+        mf_dont_release = FALSE;
+        /* TODO: should check if all blocks are really in core */
     }
 
     if (close(mfp->mf_fd) < 0)			/* close the file */
@@ -305,11 +292,11 @@
 
     if (mfp->mf_fname != NULL)
     {
-	mch_remove(mfp->mf_fname);		/* delete the swap file */
-	vim_free(mfp->mf_fname);
-	vim_free(mfp->mf_ffname);
-	mfp->mf_fname = NULL;
-	mfp->mf_ffname = NULL;
+        mch_remove(mfp->mf_fname);		/* delete the swap file */
+        vim_free(mfp->mf_fname);
+        vim_free(mfp->mf_ffname);
+        mfp->mf_fname = NULL;
+        mfp->mf_ffname = NULL;
     }
 }
 
@@ -358,52 +345,52 @@
     freep = mfp->mf_free_first;
     if (!negative && freep != NULL && freep->bh_page_count >= page_count)
     {
-	/*
-	 * If the block in the free list has more pages, take only the number
-	 * of pages needed and allocate a new bhdr_T with data
-	 *
-	 * If the number of pages matches and mf_release() did not return a
-	 * bhdr_T, use the bhdr_T from the free list and allocate the data
-	 *
-	 * If the number of pages matches and mf_release() returned a bhdr_T,
-	 * just use the number and free the bhdr_T from the free list
-	 */
-	if (freep->bh_page_count > page_count)
-	{
-	    if (hp == NULL && (hp = mf_alloc_bhdr(mfp, page_count)) == NULL)
-		return NULL;
-	    hp->bh_bnum = freep->bh_bnum;
-	    freep->bh_bnum += page_count;
-	    freep->bh_page_count -= page_count;
-	}
-	else if (hp == NULL)	    /* need to allocate memory for this block */
-	{
-	    if ((p = (char_u *)alloc(mfp->mf_page_size * page_count)) == NULL)
-		return NULL;
-	    hp = mf_rem_free(mfp);
-	    hp->bh_data = p;
-	}
-	else		    /* use the number, remove entry from free list */
-	{
-	    freep = mf_rem_free(mfp);
-	    hp->bh_bnum = freep->bh_bnum;
-	    vim_free(freep);
-	}
+        /*
+         * If the block in the free list has more pages, take only the number
+         * of pages needed and allocate a new bhdr_T with data
+         *
+         * If the number of pages matches and mf_release() did not return a
+         * bhdr_T, use the bhdr_T from the free list and allocate the data
+         *
+         * If the number of pages matches and mf_release() returned a bhdr_T,
+         * just use the number and free the bhdr_T from the free list
+         */
+        if (freep->bh_page_count > page_count)
+        {
+            if (hp == NULL && (hp = mf_alloc_bhdr(mfp, page_count)) == NULL)
+            return NULL;
+            hp->bh_bnum = freep->bh_bnum;
+            freep->bh_bnum += page_count;
+            freep->bh_page_count -= page_count;
+        }
+        else if (hp == NULL)	    /* need to allocate memory for this block */
+        {
+            if ((p = (char_u *)alloc(mfp->mf_page_size * page_count)) == NULL)
+            return NULL;
+            hp = mf_rem_free(mfp);
+            hp->bh_data = p;
+        }
+        else		    /* use the number, remove entry from free list */
+        {
+            freep = mf_rem_free(mfp);
+            hp->bh_bnum = freep->bh_bnum;
+            vim_free(freep);
+        }
     }
     else	/* get a new number */
     {
-	if (hp == NULL && (hp = mf_alloc_bhdr(mfp, page_count)) == NULL)
-	    return NULL;
-	if (negative)
-	{
-	    hp->bh_bnum = mfp->mf_blocknr_min--;
-	    mfp->mf_neg_count++;
-	}
-	else
-	{
-	    hp->bh_bnum = mfp->mf_blocknr_max;
-	    mfp->mf_blocknr_max += page_count;
-	}
+        if (hp == NULL && (hp = mf_alloc_bhdr(mfp, page_count)) == NULL)
+            return NULL;
+        if (negative)
+        {
+            hp->bh_bnum = mfp->mf_blocknr_min--;
+            mfp->mf_neg_count++;
+        }
+        else
+        {
+            hp->bh_bnum = mfp->mf_blocknr_max;
+            mfp->mf_blocknr_max += page_count;
+        }
     }
     hp->bh_flags = BH_LOCKED | BH_DIRTY;	/* new block is always dirty */
     mfp->mf_dirty = TRUE;
@@ -434,7 +421,7 @@
     bhdr_T    *hp;
 						/* doesn't exist */
     if (nr >= mfp->mf_blocknr_max || nr <= mfp->mf_blocknr_min)
-	return NULL;
+        return NULL;
 
     /*
      * see if it is in the cache
@@ -442,33 +429,33 @@
     hp = mf_find_hash(mfp, nr);
     if (hp == NULL)	/* not in the hash list */
     {
-	if (nr < 0 || nr >= mfp->mf_infile_count)   /* can't be in the file */
-	    return NULL;
+        if (nr < 0 || nr >= mfp->mf_infile_count)   /* can't be in the file */
+            return NULL;
 
-	/* could check here if the block is in the free list */
-
-	/*
-	 * Check if we need to flush an existing block.
-	 * If so, use that block.
-	 * If not, allocate a new block.
-	 */
-	hp = mf_release(mfp, page_count);
-	if (hp == NULL && (hp = mf_alloc_bhdr(mfp, page_count)) == NULL)
-	    return NULL;
+        /* could check here if the block is in the free list */
 
-	hp->bh_bnum = nr;
-	hp->bh_flags = 0;
-	hp->bh_page_count = page_count;
-	if (mf_read(mfp, hp) == FAIL)	    /* cannot read the block! */
-	{
-	    mf_free_bhdr(hp);
-	    return NULL;
-	}
+        /*
+         * Check if we need to flush an existing block.
+         * If so, use that block.
+         * If not, allocate a new block.
+         */
+        hp = mf_release(mfp, page_count);
+        if (hp == NULL && (hp = mf_alloc_bhdr(mfp, page_count)) == NULL)
+            return NULL;
+
+        hp->bh_bnum = nr;
+        hp->bh_flags = 0;
+        hp->bh_page_count = page_count;
+        if (mf_read(mfp, hp) == FAIL)	    /* cannot read the block! */
+        {
+            mf_free_bhdr(hp);
+            return NULL;
+        }
     }
     else
     {
-	mf_rem_used(mfp, hp);	/* remove from list, insert in front below */
-	mf_rem_hash(mfp, hp);
+        mf_rem_used(mfp, hp);	/* remove from list, insert in front below */
+        mf_rem_hash(mfp, hp);
     }
 
     hp->bh_flags |= BH_LOCKED;
@@ -502,8 +489,8 @@
     flags &= ~BH_LOCKED;
     if (dirty)
     {
-	flags |= BH_DIRTY;
-	mfp->mf_dirty = TRUE;
+        flags |= BH_DIRTY;
+        mfp->mf_dirty = TRUE;
     }
     hp->bh_flags = flags;
     if (infile)
@@ -523,8 +510,8 @@
     mf_rem_used(mfp, hp);	/* get *hp out of the used list */
     if (hp->bh_bnum < 0)
     {
-	vim_free(hp);		/* don't want negative numbers in free list */
-	mfp->mf_neg_count--;
+        vim_free(hp);		/* don't want negative numbers in free list */
+        mfp->mf_neg_count--;
     }
     else
 	mf_ins_free(mfp, hp);	/* put *hp in the free list */
@@ -568,8 +555,8 @@
 
     if (mfp->mf_fd < 0)	    /* there is no file, nothing to do */
     {
-	mfp->mf_dirty = FALSE;
-	return FAIL;
+        mfp->mf_dirty = FALSE;
+        return FAIL;
     }
 
     /* Only a CTRL-C while writing will break us here, not one typed
@@ -630,86 +617,48 @@
 	 * sync from the system itself).
 	 */
 #  if defined(__EMX__)
-   error "Dont use fsync with EMX! Read emxdoc.doc or emxfix01.doc for info."
+       error "Dont use fsync with EMX! Read emxdoc.doc or emxfix01.doc for info."
 #  endif
-	if (STRCMP(p_sws, "fsync") == 0)
-	{
-	    if (fsync(mfp->mf_fd))
-		status = FAIL;
-	}
-	else
-# endif
+        if (STRCMP(p_sws, "fsync") == 0)
+        {
+            if (fsync(mfp->mf_fd))
+            status = FAIL;
+        }
+        else
+# endif /* HAVE_FSYNC */
 	    /* OpenNT is strictly POSIX (Benzinger) */
 	    /* Tandem/Himalaya NSK-OSS doesn't have sync() */
 # if defined(__OPENNT) || defined(__TANDEM)
-	    fflush(NULL);
+            fflush(NULL);
 # else
-	    sync();
+        sync();
 # endif
-#endif
+#endif /* UNIX */
 #ifdef VMS
-	if (STRCMP(p_sws, "fsync") == 0)
-	{
-	    if (fsync(mfp->mf_fd))
-		status = FAIL;
-	}
+        if (STRCMP(p_sws, "fsync") == 0)
+        {
+            if (fsync(mfp->mf_fd))
+                status = FAIL;
+        }
 #endif
 #ifdef MSDOS
-	if (_dos_commit(mfp->mf_fd))
-	    status = FAIL;
+        if (_dos_commit(mfp->mf_fd))
+            status = FAIL;
 #else
 # ifdef SYNC_DUP_CLOSE
 	/*
 	 * Win32 is a bit more work: Duplicate the file handle and close it.
 	 * This should flush the file to disk.
 	 */
-	if ((fd = dup(mfp->mf_fd)) >= 0)
-	    close(fd);
+        if ((fd = dup(mfp->mf_fd)) >= 0)
+            close(fd);
 # endif
 #endif
-#ifdef AMIGA
-# if defined(__AROS__) || defined(__amigaos4__)
-	if (fsync(mfp->mf_fd) != 0)
-	    status = FAIL;
-# else
-	/*
-	 * Flush() only exists for AmigaDos 2.0.
-	 * For 1.3 it should be done with close() + open(), but then the risk
-	 * is that the open() may fail and lose the file....
-	 */
-#  ifdef FEAT_ARP
-	if (dos2)
-#  endif
-#  ifdef SASC
-	{
-	    struct UFB *fp = chkufb(mfp->mf_fd);
 
-	    if (fp != NULL)
-		Flush(fp->ufbfh);
-	}
-#  else
-#   if defined(_DCC) || defined(__GNUC__) || defined(__MORPHOS__)
-	{
-#    if defined(__GNUC__) && !defined(__MORPHOS__) && defined(__libnix__)
-	    /* Have function (in libnix at least),
-	     * but ain't got no prototype anywhere. */
-	    extern unsigned long fdtofh(int filedescriptor);
-#    endif
-#    if !defined(__libnix__)
-	    fflush(NULL);
-#    else
-	    BPTR fh = (BPTR)fdtofh(mfp->mf_fd);
-
-	    if (fh != 0)
-		Flush(fh);
-#    endif
-	}
-#   else /* assume Manx */
-	    Flush(_devtab[mfp->mf_fd].fd);
-#   endif
-#  endif
-# endif
-#endif /* AMIGA */
+#if defined(AMIGA) || defined(AROS)
+        if (fsync(mfp->mf_fd) != 0)
+            status = FAIL;
+#endif
     }
 
     got_int |= got_int_save;
@@ -729,8 +678,8 @@
     bhdr_T	*hp;
 
     for (hp = mfp->mf_used_last; hp != NULL; hp = hp->bh_prev)
-	if (hp->bh_bnum > 0)
-	    hp->bh_flags |= BH_DIRTY;
+        if (hp->bh_bnum > 0)
+            hp->bh_flags |= BH_DIRTY;
     mfp->mf_dirty = TRUE;
 }
 
@@ -750,7 +699,7 @@
     hp->bh_hash_next = hhp;
     hp->bh_hash_prev = NULL;
     if (hhp != NULL)
-	hhp->bh_hash_prev = hp;
+        hhp->bh_hash_prev = hp;
     mfp->mf_hash[hash] = hp;
 }
 
@@ -763,12 +712,12 @@
     bhdr_T	*hp;
 {
     if (hp->bh_hash_prev == NULL)
-	mfp->mf_hash[MEMHASH(hp->bh_bnum)] = hp->bh_hash_next;
+        mfp->mf_hash[MEMHASH(hp->bh_bnum)] = hp->bh_hash_next;
     else
-	hp->bh_hash_prev->bh_hash_next = hp->bh_hash_next;
+        hp->bh_hash_prev->bh_hash_next = hp->bh_hash_next;
 
     if (hp->bh_hash_next)
-	hp->bh_hash_next->bh_hash_prev = hp->bh_hash_prev;
+        hp->bh_hash_next->bh_hash_prev = hp->bh_hash_prev;
 }
 
 /*
@@ -844,7 +793,7 @@
 
     /* don't release while in mf_close_file() */
     if (mf_dont_release)
-	return NULL;
+        return NULL;
 
     /*
      * Need to release a block if the number of blocks for this memfile is
@@ -862,7 +811,7 @@
 	/* find for which buffer this memfile is */
 	for (buf = firstbuf; buf != NULL; buf = buf->b_next)
 	    if (buf->b_ml.ml_mfp == mfp)
-		break;
+            break;
 	if (buf != NULL && buf->b_may_swap)
 	    ml_open_file(buf);
     }
@@ -876,13 +825,13 @@
      *	total memory used is not up to 'maxmemtot'
      */
     if (mfp->mf_fd < 0 || !need_release)
-	return NULL;
+        return NULL;
 
     for (hp = mfp->mf_used_last; hp != NULL; hp = hp->bh_prev)
-	if (!(hp->bh_flags & BH_LOCKED))
-	    break;
+        if (!(hp->bh_flags & BH_LOCKED))
+            break;
     if (hp == NULL)	/* not a single one that can be released */
-	return NULL;
+        return NULL;
 
     /*
      * If the block is dirty, write it.
@@ -937,21 +886,21 @@
 	    /* only if there is a swapfile */
 	    if (mfp->mf_fd >= 0)
 	    {
-		for (hp = mfp->mf_used_last; hp != NULL; )
-		{
-		    if (!(hp->bh_flags & BH_LOCKED)
-			    && (!(hp->bh_flags & BH_DIRTY)
-				|| mf_write(mfp, hp) != FAIL))
-		    {
-			mf_rem_used(mfp, hp);
-			mf_rem_hash(mfp, hp);
-			mf_free_bhdr(hp);
-			hp = mfp->mf_used_last;	/* re-start, list was changed */
-			retval = TRUE;
-		    }
-		    else
-			hp = hp->bh_prev;
-		}
+            for (hp = mfp->mf_used_last; hp != NULL; )
+            {
+                if (!(hp->bh_flags & BH_LOCKED)
+                    && (!(hp->bh_flags & BH_DIRTY)
+                    || mf_write(mfp, hp) != FAIL))
+                {
+                mf_rem_used(mfp, hp);
+                mf_rem_hash(mfp, hp);
+                mf_free_bhdr(hp);
+                hp = mfp->mf_used_last;	/* re-start, list was changed */
+                retval = TRUE;
+                }
+                else
+                hp = hp->bh_prev;
+            }
 	    }
 	}
     }
@@ -970,13 +919,13 @@
 
     if ((hp = (bhdr_T *)alloc((unsigned)sizeof(bhdr_T))) != NULL)
     {
-	if ((hp->bh_data = (char_u *)alloc(mfp->mf_page_size * page_count))
+        if ((hp->bh_data = (char_u *)alloc(mfp->mf_page_size * page_count))
 								      == NULL)
-	{
-	    vim_free(hp);	    /* not enough memory */
-	    return NULL;
-	}
-	hp->bh_page_count = page_count;
+        {
+            vim_free(hp);	    /* not enough memory */
+            return NULL;
+        }
+        hp->bh_page_count = page_count;
     }
     return hp;
 }
@@ -1029,9 +978,9 @@
     memfile_T	*mfp;
     bhdr_T	*hp;
 {
-    off_t	offset;
-    unsigned	page_size;
-    unsigned	size;
+    off_t offset;
+    unsigned page_size;
+    unsigned size;
 
     if (mfp->mf_fd < 0)	    /* there is no file, can't read */
 	return FAIL;
@@ -1041,13 +990,13 @@
     size = page_size * hp->bh_page_count;
     if (lseek(mfp->mf_fd, offset, SEEK_SET) != offset)
     {
-	PERROR(_("E294: Seek error in swap file read"));
-	return FAIL;
+        PERROR(_("E294: Seek error in swap file read"));
+        return FAIL;
     }
     if ((unsigned)vim_read(mfp->mf_fd, hp->bh_data, size) != size)
     {
-	PERROR(_("E295: Read error in swap file"));
-	return FAIL;
+        PERROR(_("E295: Read error in swap file"));
+        return FAIL;
     }
     return OK;
 }
@@ -1070,11 +1019,11 @@
     unsigned	size;	    /* number of bytes written */
 
     if (mfp->mf_fd < 0)	    /* there is no file, can't write */
-	return FAIL;
+        return FAIL;
 
     if (hp->bh_bnum < 0)	/* must assign file block number */
-	if (mf_trans_add(mfp, hp) == FAIL)
-	    return FAIL;
+        if (mf_trans_add(mfp, hp) == FAIL)
+            return FAIL;
 
     page_size = mfp->mf_page_size;
 
@@ -1086,48 +1035,48 @@
      */
     for (;;)
     {
-	nr = hp->bh_bnum;
-	if (nr > mfp->mf_infile_count)		/* beyond end of file */
-	{
-	    nr = mfp->mf_infile_count;
-	    hp2 = mf_find_hash(mfp, nr);	/* NULL catched below */
-	}
-	else
-	    hp2 = hp;
-
-	offset = (off_t)page_size * nr;
-	if (lseek(mfp->mf_fd, offset, SEEK_SET) != offset)
-	{
-	    PERROR(_("E296: Seek error in swap file write"));
-	    return FAIL;
-	}
-	if (hp2 == NULL)	    /* freed block, fill with dummy data */
-	    page_count = 1;
-	else
-	    page_count = hp2->bh_page_count;
-	size = page_size * page_count;
-	if ((unsigned)vim_write(mfp->mf_fd,
-	     (hp2 == NULL ? hp : hp2)->bh_data, size) != size)
-	{
-	    /*
-	     * Avoid repeating the error message, this mostly happens when the
-	     * disk is full. We give the message again only after a successful
-	     * write or when hitting a key. We keep on trying, in case some
-	     * space becomes available.
-	     */
-	    if (!did_swapwrite_msg)
-		EMSG(_("E297: Write error in swap file"));
-	    did_swapwrite_msg = TRUE;
-	    return FAIL;
-	}
-	did_swapwrite_msg = FALSE;
-	if (hp2 != NULL)		    /* written a non-dummy block */
-	    hp2->bh_flags &= ~BH_DIRTY;
-					    /* appended to the file */
-	if (nr + (blocknr_T)page_count > mfp->mf_infile_count)
-	    mfp->mf_infile_count = nr + page_count;
-	if (nr == hp->bh_bnum)		    /* written the desired block */
-	    break;
+        nr = hp->bh_bnum;
+        if (nr > mfp->mf_infile_count)		/* beyond end of file */
+        {
+            nr = mfp->mf_infile_count;
+            hp2 = mf_find_hash(mfp, nr);	/* NULL catched below */
+        }
+        else
+            hp2 = hp;
+
+        offset = (off_t)page_size * nr;
+        if (lseek(mfp->mf_fd, offset, SEEK_SET) != offset)
+        {
+            PERROR(_("E296: Seek error in swap file write"));
+            return FAIL;
+        }
+        if (hp2 == NULL)	    /* freed block, fill with dummy data */
+            page_count = 1;
+        else
+            page_count = hp2->bh_page_count;
+        size = page_size * page_count;
+        if ((unsigned)vim_write(mfp->mf_fd,
+             (hp2 == NULL ? hp : hp2)->bh_data, size) != size)
+        {
+            /*
+             * Avoid repeating the error message, this mostly happens when the
+             * disk is full. We give the message again only after a successful
+             * write or when hitting a key. We keep on trying, in case some
+             * space becomes available.
+             */
+            if (!did_swapwrite_msg)
+            EMSG(_("E297: Write error in swap file"));
+            did_swapwrite_msg = TRUE;
+            return FAIL;
+        }
+        did_swapwrite_msg = FALSE;
+        if (hp2 != NULL)		    /* written a non-dummy block */
+            hp2->bh_flags &= ~BH_DIRTY;
+                            /* appended to the file */
+        if (nr + (blocknr_T)page_count > mfp->mf_infile_count)
+            mfp->mf_infile_count = nr + page_count;
+        if (nr == hp->bh_bnum)		    /* written the desired block */
+            break;
     }
     return OK;
 }
@@ -1139,20 +1088,20 @@
  */
     static int
 mf_trans_add(mfp, hp)
-    memfile_T	*mfp;
+    memfile_T *mfp;
     bhdr_T	*hp;
 {
-    bhdr_T	*freep;
-    blocknr_T	new_bnum;
-    int		hash;
-    NR_TRANS	*np;
-    int		page_count;
+    bhdr_T *freep;
+    blocknr_T new_bnum;
+    int	hash;
+    NR_TRANS *np;
+    int	page_count;
 
     if (hp->bh_bnum >= 0)		    /* it's already positive */
-	return OK;
+        return OK;
 
     if ((np = (NR_TRANS *)alloc((unsigned)sizeof(NR_TRANS))) == NULL)
-	return FAIL;
+        return FAIL;
 
 /*
  * get a new number for the block.
@@ -1163,26 +1112,26 @@
     page_count = hp->bh_page_count;
     if (freep != NULL && freep->bh_page_count >= page_count)
     {
-	new_bnum = freep->bh_bnum;
-	/*
-	 * If the page count of the free block was larger, recude it.
-	 * If the page count matches, remove the block from the free list
-	 */
-	if (freep->bh_page_count > page_count)
-	{
-	    freep->bh_bnum += page_count;
-	    freep->bh_page_count -= page_count;
-	}
-	else
-	{
-	    freep = mf_rem_free(mfp);
-	    vim_free(freep);
-	}
+        new_bnum = freep->bh_bnum;
+        /*
+         * If the page count of the free block was larger, recude it.
+         * If the page count matches, remove the block from the free list
+         */
+        if (freep->bh_page_count > page_count)
+        {
+            freep->bh_bnum += page_count;
+            freep->bh_page_count -= page_count;
+        }
+        else
+        {
+            freep = mf_rem_free(mfp);
+            vim_free(freep);
+        }
     }
     else
     {
-	new_bnum = mfp->mf_blocknr_max;
-	mfp->mf_blocknr_max += page_count;
+        new_bnum = mfp->mf_blocknr_max;
+        mfp->mf_blocknr_max += page_count;
     }
 
     np->nt_old_bnum = hp->bh_bnum;	    /* adjust number */
@@ -1196,7 +1145,7 @@
     np->nt_next = mfp->mf_trans[hash];
     mfp->mf_trans[hash] = np;
     if (np->nt_next != NULL)
-	np->nt_next->nt_prev = np;
+        np->nt_next->nt_prev = np;
     np->nt_prev = NULL;
 
     return OK;
@@ -1218,19 +1167,19 @@
 
     hash = MEMHASH(old_nr);
     for (np = mfp->mf_trans[hash]; np != NULL; np = np->nt_next)
-	if (np->nt_old_bnum == old_nr)
-	    break;
+        if (np->nt_old_bnum == old_nr)
+            break;
     if (np == NULL)		/* not found */
-	return old_nr;
+        return old_nr;
 
     mfp->mf_neg_count--;
     new_bnum = np->nt_new_bnum;
     if (np->nt_prev != NULL)		/* remove entry from the trans list */
-	np->nt_prev->nt_next = np->nt_next;
+        np->nt_prev->nt_next = np->nt_next;
     else
-	mfp->mf_trans[hash] = np->nt_next;
+        mfp->mf_trans[hash] = np->nt_next;
     if (np->nt_next != NULL)
-	np->nt_next->nt_prev = np->nt_prev;
+        np->nt_next->nt_prev = np->nt_prev;
     vim_free(np);
 
     return new_bnum;
@@ -1258,9 +1207,9 @@
 {
     if (mfp != NULL && mfp->mf_fname != NULL && mfp->mf_ffname != NULL)
     {
-	vim_free(mfp->mf_fname);
-	mfp->mf_fname = mfp->mf_ffname;
-	mfp->mf_ffname = NULL;
+        vim_free(mfp->mf_fname);
+        mfp->mf_fname = mfp->mf_ffname;
+        mfp->mf_ffname = NULL;
     }
 }
 
@@ -1312,8 +1261,8 @@
      */
     if ((flags & O_CREAT) && mch_lstat((char *)mfp->mf_fname, &sb) >= 0)
     {
-	mfp->mf_fd = -1;
-	EMSG(_("E300: Swap file already exists (symlink attack?)"));
+        mfp->mf_fd = -1;
+        EMSG(_("E300: Swap file already exists (symlink attack?)"));
     }
     else
 #endif
@@ -1344,8 +1293,8 @@
     else
     {
 #ifdef HAVE_SELINUX
-	mch_copy_sec(fname, mfp->mf_fname);
+        mch_copy_sec(fname, mfp->mf_fname);
 #endif
-	mch_hide(mfp->mf_fname);    /* try setting the 'hidden' flag */
+        mch_hide(mfp->mf_fname);    /* try setting the 'hidden' flag */
     }
 }
diff -Naur vim72-orig/src/memline.c vim72/src/memline.c
--- vim72-orig/src/memline.c	2015-04-26 10:11:05.167298463 +0200
+++ vim72/src/memline.c	2015-04-26 10:12:03.586828212 +0200
@@ -277,9 +277,9 @@
      * When 'updatecount' is non-zero swap file may be opened later.
      */
     if (p_uc && buf->b_p_swf)
-	buf->b_may_swap = TRUE;
+        buf->b_may_swap = TRUE;
     else
-	buf->b_may_swap = FALSE;
+        buf->b_may_swap = FALSE;
 
     /*
      * Open the memfile.  No swap file is created yet.
@@ -720,7 +720,7 @@
 	b0p->b0_fname[0] = NUL;
     else
     {
-#if defined(MSDOS) || defined(MSWIN) || defined(AMIGA) || defined(RISCOS)
+#if defined(MSDOS) || defined(MSWIN) || defined(AMIGA) || defined(AROS) || defined(RISCOS)
 	/* Systems that cannot translate "~user" back into a path: copy the
 	 * file name unmodified.  Do use slashes instead of backslashes for
 	 * portability. */
@@ -3803,7 +3803,7 @@
     char_u	*fname;
     int		n;
     char_u	*dir_name;
-#ifdef AMIGA
+#if defined(AMIGA) || defined(AROS)
     BPTR	fh;
 #endif
 #ifndef SHORT_FNAME
@@ -3965,7 +3965,7 @@
 	     */
 	    if (mch_lstat((char *)fname, &sb) < 0)
 #else
-# ifdef AMIGA
+# if defined(AMIGA) || defined(AROS)
 	    fh = Open((UBYTE *)fname, (long)MODE_NEWFILE);
 	    /*
 	     * on the Amiga mch_getperm() will return -1 when the file exists
diff -Naur vim72-orig/src/menu.c vim72/src/menu.c
--- vim72-orig/src/menu.c	2015-04-26 10:11:05.165298479 +0200
+++ vim72/src/menu.c	2015-04-26 10:12:03.586828212 +0200
@@ -16,7 +16,7 @@
 
 #if defined(FEAT_MENU) || defined(PROTO)
 
-#define MENUDEPTH   10		/* maximum depth of menus */
+#define MENUDEPTH   20		/* maximum depth of menus */
 
 #ifdef FEAT_GUI_W32
 static int add_menu_path __ARGS((char_u *, vimmenu_T *, int *, char_u *, int));
@@ -1818,11 +1818,13 @@
 	{
 	    if (menu->children != NULL)
 	    {
-		gui_mch_add_menu(menu, idx);
-		gui_create_initial_menus(menu->children);
+            gui_mch_add_menu(menu, idx);
+            gui_create_initial_menus(menu->children);
 	    }
 	    else
-		gui_mch_add_menu_item(menu, idx);
+        {
+            gui_mch_add_menu_item(menu, idx);
+        }
 	}
 	menu = menu->next;
 	++idx;
diff -Naur vim72-orig/src/misc1.c vim72/src/misc1.c
--- vim72-orig/src/misc1.c	2015-04-26 10:11:05.170298439 +0200
+++ vim72/src/misc1.c	2015-04-26 10:12:03.586828212 +0200
@@ -3789,7 +3789,7 @@
 		/* if var[] ends in a path separator and tail[] starts
 		 * with it, skip a character */
 		if (*var != NUL && after_pathsep(dst, dst + c)
-#if defined(BACKSLASH_IN_FILENAME) || defined(AMIGA)
+#if defined(BACKSLASH_IN_FILENAME) || defined(AMIGA) || defined(AROS)
 			&& dst[-1] != ':'
 #endif
 			&& vim_ispathsep(*tail))
@@ -4147,7 +4147,7 @@
     expand_T	*xp;
     int		idx;
 {
-# if defined(AMIGA) || defined(__MRC__) || defined(__SC__)
+# if defined(AMIGA) || defined(AROS) || defined(__MRC__) || defined(__SC__)
     /*
      * No environ[] on the Amiga and on the Mac (using MPW).
      */
@@ -4459,7 +4459,7 @@
     else
 	retval = path;
 #else
-# if defined(AMIGA)
+# if defined(AMIGA) || defined(AROS)
     /* may skip "label:" */
     retval = vim_strchr(path, ':');
     if (retval == NULL)
diff -Naur vim72-orig/src/misc2.c vim72/src/misc2.c
--- vim72-orig/src/misc2.c	2015-04-26 10:11:05.165298479 +0200
+++ vim72/src/misc2.c	2015-04-26 10:12:03.586828212 +0200
@@ -3502,47 +3502,47 @@
     if (mouse && (State == HITRETURN || State == ASKMORE))
     {
 # ifdef FEAT_GUI
-	int x, y;
-	gui_mch_getmouse(&x, &y);
-	if (Y_2_ROW(y) == Rows - 1)
-	    return SHAPE_IDX_MOREL;
+        int x, y;
+        gui_mch_getmouse(&x, &y);
+        if (Y_2_ROW(y) == Rows - 1)
+            return SHAPE_IDX_MOREL;
 # endif
-	return SHAPE_IDX_MORE;
+        return SHAPE_IDX_MORE;
     }
     if (mouse && drag_status_line)
-	return SHAPE_IDX_SDRAG;
+        return SHAPE_IDX_SDRAG;
 # ifdef FEAT_VERTSPLIT
     if (mouse && drag_sep_line)
-	return SHAPE_IDX_VDRAG;
+        return SHAPE_IDX_VDRAG;
 # endif
 #endif
     if (!mouse && State == SHOWMATCH)
-	return SHAPE_IDX_SM;
+        return SHAPE_IDX_SM;
 #ifdef FEAT_VREPLACE
     if (State & VREPLACE_FLAG)
-	return SHAPE_IDX_R;
+        return SHAPE_IDX_R;
 #endif
     if (State & REPLACE_FLAG)
-	return SHAPE_IDX_R;
+        return SHAPE_IDX_R;
     if (State & INSERT)
-	return SHAPE_IDX_I;
+        return SHAPE_IDX_I;
     if (State & CMDLINE)
     {
-	if (cmdline_at_end())
-	    return SHAPE_IDX_C;
-	if (cmdline_overstrike())
-	    return SHAPE_IDX_CR;
-	return SHAPE_IDX_CI;
+        if (cmdline_at_end())
+            return SHAPE_IDX_C;
+        if (cmdline_overstrike())
+            return SHAPE_IDX_CR;
+        return SHAPE_IDX_CI;
     }
     if (finish_op)
-	return SHAPE_IDX_O;
+        return SHAPE_IDX_O;
 #ifdef FEAT_VISUAL
     if (VIsual_active)
     {
-	if (*p_sel == 'e')
-	    return SHAPE_IDX_VE;
-	else
-	    return SHAPE_IDX_V;
+        if (*p_sel == 'e')
+            return SHAPE_IDX_VE;
+        else
+            return SHAPE_IDX_V;
     }
 #endif
     return SHAPE_IDX_N;
@@ -5389,7 +5389,7 @@
     char_u		*file_name = NULL;
     char_u		*buf = NULL;
     int			rel_to_curdir;
-#ifdef AMIGA
+#if defined(AMIGA) || defined(AROS)
     struct Process	*proc = (struct Process *)FindTask(0L);
     APTR		save_winptr = proc->pr_WindowPtr;
 
@@ -5429,7 +5429,7 @@
 	    /* handle "c:name" as absulute path */
 	    || (ff_file_to_find[0] != NUL && ff_file_to_find[1] == ':')
 #endif
-#ifdef AMIGA
+#if defined(AMIGA) || defined(AROS)
 	    /* handle ":tmp" as absolute path */
 	    || ff_file_to_find[0] == ':'
 #endif
@@ -5583,7 +5583,7 @@
     }
 
 theend:
-#ifdef AMIGA
+#if defined(AMIGA) || defined(AROS)
     proc->pr_WindowPtr = save_winptr;
 #endif
     return file_name;
diff -Naur vim72-orig/src/move.c vim72/src/move.c
--- vim72-orig/src/move.c	2015-04-26 10:11:05.171298431 +0200
+++ vim72/src/move.c	2015-04-26 10:12:03.586828212 +0200
@@ -66,13 +66,13 @@
     check_cursor_moved(wp);
     if (wp->w_valid & VALID_CROW)
     {
-	lnum = wp->w_cursor.lnum;
-	done = wp->w_cline_row;
+        lnum = wp->w_cursor.lnum;
+        done = wp->w_cline_row;
     }
     else
     {
-	lnum = wp->w_topline;
-	done = 0;
+        lnum = wp->w_topline;
+        done = 0;
     }
 
     for ( ; lnum <= wp->w_buffer->b_ml.ml_line_count; ++lnum)
@@ -130,7 +130,7 @@
     void
 update_topline_redraw()
 {
-    update_topline();
+    update_topline(TRUE);
     if (must_redraw)
 	update_screen(0);
 }
@@ -139,7 +139,7 @@
  * Update curwin->w_topline to move the cursor onto the screen.
  */
     void
-update_topline()
+update_topline(int bound_caret)
 {
     long	line_count;
     int		halfheight;
@@ -158,16 +158,16 @@
 #endif
 
     if (!screen_valid(TRUE))
-	return;
+        return;
 
     check_cursor_moved(curwin);
     if (curwin->w_valid & VALID_TOPLINE)
-	return;
+        return;
 
 #ifdef FEAT_MOUSE
     /* When dragging with the mouse, don't scroll that quickly */
     if (mouse_dragging > 0)
-	p_so = mouse_dragging - 1;
+        p_so = mouse_dragging - 1;
 #endif
 
     old_topline = curwin->w_topline;
@@ -180,16 +180,16 @@
      */
     if (bufempty())		/* special case - file is empty */
     {
-	if (curwin->w_topline != 1)
-	    redraw_later(NOT_VALID);
-	curwin->w_topline = 1;
+        if (curwin->w_topline != 1)
+            redraw_later(NOT_VALID);
+        curwin->w_topline = 1;
 #ifdef FEAT_DIFF
-	curwin->w_topfill = 0;
+        curwin->w_topfill = 0;
 #endif
-	curwin->w_botline = 2;
-	curwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;
+        curwin->w_botline = 2;
+        curwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;
 #ifdef FEAT_SCROLLBIND
-	curwin->w_scbind_pos = 1;
+        curwin->w_scbind_pos = 1;
 #endif
     }
 
@@ -199,59 +199,61 @@
      */
     else
     {
-	if (curwin->w_topline > 1)
-	{
-	    /* If the cursor is above topline, scrolling is always needed.
-	     * If the cursor is far below topline and there is no folding,
-	     * scrolling down is never needed. */
-	    if (curwin->w_cursor.lnum < curwin->w_topline)
-		check_topline = TRUE;
-	    else if (check_top_offset())
-		check_topline = TRUE;
-	}
+        if (curwin->w_topline > 1)
+        {
+            /* If the cursor is above topline, scrolling is always needed.
+             * If the cursor is far below topline and there is no folding,
+             * scrolling down is never needed. */
+            if (curwin->w_cursor.lnum < curwin->w_topline)
+            check_topline = TRUE;
+            else if (check_top_offset())
+            check_topline = TRUE;
+        }
+        if(!bound_caret) check_topline = FALSE;
 #ifdef FEAT_DIFF
 	    /* Check if there are more filler lines than allowed. */
-	if (!check_topline && curwin->w_topfill > diff_check_fill(curwin,
-							   curwin->w_topline))
-	    check_topline = TRUE;
-#endif
-
-	if (check_topline)
-	{
-	    halfheight = curwin->w_height / 2 - 1;
-	    if (halfheight < 2)
-		halfheight = 2;
-
-#ifdef FEAT_FOLDING
-	    if (hasAnyFolding(curwin))
-	    {
-		/* Count the number of logical lines between the cursor and
-		 * topline + p_so (approximation of how much will be
-		 * scrolled). */
-		n = 0;
-		for (lnum = curwin->w_cursor.lnum;
-				      lnum < curwin->w_topline + p_so; ++lnum)
-		{
-		    ++n;
-		    /* stop at end of file or when we know we are far off */
-		    if (lnum >= curbuf->b_ml.ml_line_count || n >= halfheight)
-			break;
-		    (void)hasFolding(lnum, NULL, &lnum);
-		}
-	    }
-	    else
+        if (!check_topline && curwin->w_topfill > diff_check_fill(curwin,
+                                   curwin->w_topline))
+            check_topline = TRUE;
+#endif
+
+        if(!bound_caret) check_topline = FALSE;
+        if (check_topline)
+        {
+            halfheight = curwin->w_height / 2 - 1;
+            if (halfheight < 2)
+                halfheight = 2;
+
+#ifdef FEAT_FOLDING
+            if (hasAnyFolding(curwin))
+            {
+                /* Count the number of logical lines between the cursor and
+                 * topline + p_so (approximation of how much will be
+                 * scrolled). */
+                n = 0;
+                for (lnum = curwin->w_cursor.lnum;
+                              lnum < curwin->w_topline + p_so; ++lnum)
+                {
+                    ++n;
+                    /* stop at end of file or when we know we are far off */
+                    if (lnum >= curbuf->b_ml.ml_line_count || n >= halfheight)
+                    break;
+                    (void) hasFolding(lnum, NULL, &lnum);
+                }
+            }
+            else
 #endif
-		n = curwin->w_topline + p_so - curwin->w_cursor.lnum;
+                n = curwin->w_topline + p_so - curwin->w_cursor.lnum;
 
 	    /* If we weren't very close to begin with, we scroll to put the
 	     * cursor in the middle of the window.  Otherwise put the cursor
 	     * near the top of the window. */
 	    if (n >= halfheight)
-		scroll_cursor_halfway(FALSE);
+            scroll_cursor_halfway(FALSE);
 	    else
 	    {
-		scroll_cursor_top(scrolljump_value(), FALSE);
-		check_botline = TRUE;
+            scroll_cursor_top(scrolljump_value(), FALSE);
+            check_botline = TRUE;
 	    }
 	}
 
@@ -273,6 +275,7 @@
      * cases, but we don't want to spend (a lot of) time recomputing w_botline
      * for every small change.
      */
+    if(!bound_caret) check_botline = FALSE;
     if (check_botline)
     {
 	if (!(curwin->w_valid & VALID_BOTLINE_AP))
@@ -318,6 +321,7 @@
 		    /* sufficient context, no need to scroll */
 		    check_botline = FALSE;
 	    }
+        if(!bound_caret) check_topline = FALSE;
 	    if (check_botline)
 	    {
 #ifdef FEAT_FOLDING
@@ -512,7 +516,7 @@
 #ifdef FEAT_DIFF
     wp->w_topfill = 0;
 #endif
-    wp->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_TOPLINE);
+    wp->w_valid &= ~(VALID_WROW | VALID_CROW | VALID_BOTLINE | VALID_TOPLINE);
     /* Don't set VALID_TOPLINE here, 'scrolloff' needs to be checked. */
     redraw_later(VALID);
 }
@@ -681,7 +685,7 @@
     /*
      * First make sure that w_topline is valid (after moving the cursor).
      */
-    update_topline();
+    update_topline(TRUE);
     check_cursor_moved(curwin);
     if (!(curwin->w_valid & VALID_CROW))
 	curs_rows(curwin, FALSE);
@@ -813,7 +817,7 @@
 	}
     }
 
-    wp->w_valid |= VALID_CROW|VALID_CHEIGHT;
+    wp->w_valid |= VALID_CROW | VALID_CHEIGHT;
 
     /* validate botline too, if update_screen doesn't do it */
     if (do_botline && all_invalid)
@@ -984,7 +988,7 @@
     /*
      * First make sure that w_topline is valid (after moving the cursor).
      */
-    update_topline();
+    update_topline(TRUE);
 
     /*
      * Next make sure that w_cline_row is valid.
diff -Naur vim72-orig/src/netbeans.c vim72/src/netbeans.c
--- vim72-orig/src/netbeans.c	2015-04-26 10:11:05.165298479 +0200
+++ vim72/src/netbeans.c	2015-04-26 10:12:03.586828212 +0200
@@ -2145,7 +2145,7 @@
 
 	    /* gui_update_cursor(TRUE, FALSE); */
 	    /* update_curbuf(NOT_VALID); */
-	    update_topline();		/* scroll to show the line */
+	    update_topline(TRUE);		/* scroll to show the line */
 	    update_screen(VALID);
 	    setcursor();
 	    out_flush();
diff -Naur vim72-orig/src/normal.c vim72/src/normal.c
--- vim72-orig/src/normal.c	2015-04-26 10:11:05.166298471 +0200
+++ vim72/src/normal.c	2015-04-26 10:12:03.587828204 +0200
@@ -7651,7 +7651,7 @@
 	    VIsual = curwin->w_cursor;
 	    curwin->w_cursor = tpos;
 	    check_cursor();
-	    update_topline();
+	    update_topline(TRUE);
 	    /*
 	     * When called from normal "g" command: start Select mode when
 	     * 'selectmode' contains "cmd".  When called for K_SELECT, always
diff -Naur vim72-orig/src/ops.c vim72/src/ops.c
--- vim72-orig/src/ops.c	2015-04-26 10:11:05.170298439 +0200
+++ vim72/src/ops.c	2015-04-26 10:12:03.587828204 +0200
@@ -2748,31 +2748,31 @@
 {
     if (y_current->y_array != NULL)
     {
-	long	    i;
+        long i;
 
-	for (i = n; --i >= 0; )
-	{
-#ifdef AMIGA	    /* only for very slow machines */
-	    if ((i & 1023) == 1023)  /* this may take a while */
-	    {
-		/*
-		 * This message should never cause a hit-return message.
-		 * Overwrite this message with any next message.
-		 */
-		++no_wait_return;
-		smsg((char_u *)_("freeing %ld lines"), i + 1);
-		--no_wait_return;
-		msg_didout = FALSE;
-		msg_col = 0;
-	    }
+        for (i = n; --i >= 0; )
+        {
+#if defined(AMIGA) || defined(AROS)	    /* only for very slow machines */
+            if ((i & 1023) == 1023)  /* this may take a while */
+            {
+                /*
+                 * This message should never cause a hit-return message.
+                 * Overwrite this message with any next message.
+                 */
+                ++no_wait_return;
+                smsg((char_u *)_("freeing %ld lines"), i + 1);
+                --no_wait_return;
+                msg_didout = FALSE;
+                msg_col = 0;
+            }
 #endif
-	    vim_free(y_current->y_array[i]);
-	}
-	vim_free(y_current->y_array);
-	y_current->y_array = NULL;
-#ifdef AMIGA
-	if (n >= 1000)
-	    MSG("");
+            vim_free(y_current->y_array[i]);
+        }
+        vim_free(y_current->y_array);
+        y_current->y_array = NULL;
+#if defined(AMIGA) || defined(AROS)
+        if (n >= 1000)
+            MSG("");
 #endif
     }
 }
diff -Naur vim72-orig/src/option.c vim72/src/option.c
--- vim72-orig/src/option.c	2015-04-26 10:11:05.165298479 +0200
+++ vim72/src/option.c	2015-04-26 10:12:03.587828204 +0200
@@ -1441,7 +1441,7 @@
 				 * ( and ) are used in text separating fnames */
 			    (char_u *)"@,48-57,/,\\,.,-,_,+,,,#,$,%,{,},[,],:,@-@,!,~,=",
 #else
-# ifdef AMIGA
+# if defined(AMIGA) || defined(AROS)
 			    (char_u *)"@,48-57,/,.,-,_,+,,,$,:",
 # else
 #  ifdef VMS
@@ -1863,7 +1863,7 @@
     {"path",	    "pa",   P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
 			    (char_u *)&p_path, PV_PATH,
 			    {
-#if defined AMIGA || defined MSDOS || defined MSWIN
+#if defined(AMIGA) || defined(AROS) || defined(MSDOS) || defined(MSWIN)
 			    (char_u *)".,,",
 #else
 # if defined(__EMX__)
@@ -2186,7 +2186,7 @@
 			    (char_u *)&p_stmp, PV_NONE,
 			    {(char_u *)FALSE, (char_u *)TRUE}},
     {"shelltype",   "st",   P_NUM|P_VI_DEF,
-#ifdef AMIGA
+#if defined(AMIGA) || defined(AROS)
 			    (char_u *)&p_st, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
@@ -2595,7 +2595,7 @@
 #if defined(MSDOS) || defined(MSWIN) || defined(OS2)
 			    {(char_u *)"", (char_u *)"'20,<50,s10,h,rA:,rB:"}
 #else
-# ifdef AMIGA
+# if defined(AMIGA) || defined(AROS)
 			    {(char_u *)"",
 				 (char_u *)"'20,<50,s10,h,rdf0:,rdf1:,rdf2:"}
 # else
diff -Naur vim72-orig/src/option.h vim72/src/option.h
--- vim72-orig/src/option.h	2015-04-26 10:11:05.169298447 +0200
+++ vim72/src/option.h	2015-04-26 10:12:03.587828204 +0200
@@ -15,7 +15,7 @@
  * The "%f|%l| %m" one is used for when the contents of the quickfix window is
  * written to a file.
  */
-#ifdef AMIGA
+#if defined(AMIGA) || defined(AROS)
 # define DFLT_EFM	"%f>%l:%c:%t:%n:%m,%f:%l: %t%*\\D%n: %m,%f %l %t%*\\D%n: %m,%*[^\"]\"%f\"%*\\D%l: %m,%f:%l:%m,%f|%l| %m"
 #else
 # if defined(MSDOS) || defined(WIN3264)
@@ -700,7 +700,7 @@
 EXTERN char_u	*p_shq;		/* 'shellquote' */
 EXTERN char_u	*p_sxq;		/* 'shellxquote' */
 EXTERN char_u	*p_srr;		/* 'shellredir' */
-#ifdef AMIGA
+#if defined(AMIGA) || defined(AROS)
 EXTERN long	p_st;		/* 'shelltype' */
 #endif
 EXTERN int	p_stmp;		/* 'shelltemp' */
diff -Naur vim72-orig/src/os_aros.c vim72/src/os_aros.c
--- vim72-orig/src/os_aros.c	1970-01-01 01:00:00.000000000 +0100
+++ vim72/src/os_aros.c	2015-04-26 20:11:11.916410099 +0200
@@ -0,0 +1,1167 @@
+/* vi:set ts=8 sts=4 sw=4:
+ *
+ * VIM - Vi IMproved	by Bram Moolenaar
+ *
+ * Do ":help uganda"  in Vim to read copying and usage conditions.
+ * Do ":help credits" in Vim to see a list of people who contributed.
+ * See README.txt for an overview of the Vim source code.
+ */
+
+/*
+ * os_aros.c
+ *
+ * AROS dependent routines.
+ */
+
+#include "vim.h"
+
+#ifdef Window
+# undef Window	/* AROS has its own Window definition */
+#endif
+
+#undef TRUE		/* will be redefined by exec/types.h */
+#undef FALSE
+
+#include <exec/types.h>
+#include <exec/exec.h>
+#include <libraries/dos.h>
+#include <intuition/intuition.h>
+#include <workbench/startup.h>
+
+#include <exec/memory.h>
+#include <libraries/dosextens.h>
+
+#include <dos/dostags.h>	    /* for 2.0 functions */
+#include <dos/dosasl.h>
+
+#define	free_fib(x) vim_free(fib)
+
+/*
+ * At this point TRUE and FALSE are defined as 1L and 0L, but we want 1 and 0.
+ */
+#undef	TRUE
+#define TRUE (1)
+#undef	FALSE
+#define FALSE (0)
+
+static long dos_packet __ARGS((struct MsgPort *, long, long));
+static int lock2name __ARGS((BPTR lock, char_u *buf, long   len));
+static void out_num __ARGS((long n));
+static struct FileInfoBlock *get_fib __ARGS((char_u *));
+static int sortcmp __ARGS((const void *a, const void *b));
+
+static BPTR raw_in = (BPTR)NULL;
+static BPTR raw_out = (BPTR)NULL;
+static int close_win = FALSE;  /* set if Vim opened the window */
+
+static struct Window *wb_window;
+static char_u		*oldwindowtitle = NULL;
+
+int size_set = FALSE;   /* set to TRUE if window size was set */
+
+void win_resize_on()
+{
+    OUT_STR_NF("\033[12{");
+}
+
+void win_resize_off()
+{
+    OUT_STR_NF("\033[12}");
+}
+
+void mch_write(char_u *p, int len)
+{
+    Write(raw_out, (char *) p, (long) len);
+}
+
+/*
+ * mch_inchar(): low level input funcion.
+ * Get a characters from the keyboard.
+ * If time == 0 do not wait for characters.
+ * If time == n wait a short time for characters.
+ * If time == -1 wait forever for characters.
+ *
+ * Return number of characters read.
+ */
+int mch_inchar(char_u *buf,
+               int maxlen,
+               long time,       /* milli seconds */
+               int tb_change_cnt)
+{
+    int len;
+    long utime;
+
+    if (time >= 0)
+    {
+        if (time == 0)
+            utime = 100L;	    /* time = 0 causes problems in DOS 1.2 */
+        else
+            utime = time * 1000L;   /* convert from milli to micro secs */
+        if (WaitForChar(raw_in, utime) == 0)	/* no character available */
+            return 0;
+    }
+    else    /* time == -1 */
+    {
+        /*
+         * If there is no character available within 2 seconds (default)
+         * write the autoscript file to disk.  Or cause the CursorHold event
+         * to be triggered.
+         */
+        if (WaitForChar(raw_in, p_ut * 1000L) == 0)
+        {
+#ifdef FEAT_AUTOCMD
+            if (trigger_cursorhold() && maxlen >= 3)
+            {
+                buf[0] = K_SPECIAL;
+                buf[1] = KS_EXTRA;
+                buf[2] = (int)KE_CURSORHOLD;
+                return 3;
+            }
+#endif
+            before_blocking();
+        }
+    }
+
+    for (;;)	    /* repeat until we got a character */
+    {
+#  ifdef FEAT_MBYTE
+        len = Read(raw_in, (char *) buf, (long) maxlen / input_conv.vc_factor);
+#  else
+        len = Read(raw_in, (char *) buf, (long) maxlen);
+#  endif
+        if (len > 0)
+        {
+#ifdef FEAT_MBYTE
+            /* Convert from 'termencoding' to 'encoding'. */
+            if (input_conv.vc_type != CONV_NONE)
+                len = convert_input(buf, len, maxlen);
+#endif
+            return len;
+        }
+    }
+}
+
+/*
+ * return non-zero if a character is available
+ */
+int mch_char_avail()
+{
+    return (WaitForChar(raw_in, 100L) != 0);
+}
+
+/*
+ * Return amount of memory still available.
+ */
+long_u mch_avail_mem(int special)
+{
+    return (long_u)AvailMem(special ? (long) MEMF_CHIP : (long) MEMF_ANY);
+}
+
+/*
+ * Waits a specified amount of time, or until input arrives if
+ * ignoreinput is FALSE.
+ */
+void mch_delay(long msec, int ignoreinput)
+{
+    if (msec > 0)
+    {
+        if (ignoreinput)
+            Delay(msec / 20L);	    /* Delay works with 20 msec intervals */
+        else
+            WaitForChar(raw_in, msec * 1000L);
+    }
+}
+
+/*
+ * We have no job control, fake it by starting a new shell.
+ */
+void mch_suspend()
+{
+    suspend_shell();
+}
+
+void mch_init()
+{
+    Columns = 80;
+    Rows = 24;
+
+    /*
+     * Set input and output channels, unless we have opened our own window
+     */
+    if (raw_in == (BPTR)NULL)
+    {
+		raw_in = Input();
+		raw_out = Output();
+		/*
+		 * If Input() is not interactive, then Output() will be (because of
+		 * check in mch_check_win()).  Used for "Vim -".
+		 * Also check the other way around, for "Vim -h | more".
+		 */
+		if (!IsInteractive(raw_in))
+			raw_in = raw_out;
+		else if (!IsInteractive(raw_out))
+			raw_out = raw_in;
+    }
+
+    out_flush();
+
+    wb_window = NULL;
+}
+
+/*
+ * Check_win checks whether we have an interactive window.
+ * If not, a new window is opened with the newcli command.
+ * If we would open a window ourselves, the :sh and :! commands would not
+ * work properly (Why? probably because we are then running in a background
+ * CLI). This also is the best way to assure proper working in a next
+ * Workbench release.
+ *
+ * For the -f option (foreground mode) we open our own window and disable :sh.
+ * Otherwise the calling program would never know when editing is finished.
+ */
+#define BUF2SIZE 320	    /* length of buffer for argument with complete path */
+
+int mch_check_win(int argc, char **argv)
+{
+    int i;
+    BPTR nilfh, fh;
+    char_u buf1[24];
+    char_u buf2[BUF2SIZE];
+    static char_u *(constrings[3]) =
+    {
+        (char_u *) "con:0/0/662/210/",
+        (char_u *) "con:0/0/640/200/",
+		(char_u *) "con:0/0/320/200/"
+    };
+    static char_u *winerr = (char_u *) N_("VIM: Can't open window!\n");
+    struct WBArg *argp;
+    int ac;
+    char *av;
+    char_u *device = NULL;
+    int exitval = 4;
+    int usewin = FALSE;
+
+    /*
+     * scan argv[] for the "-f" and "-d" arguments
+     */
+    for (i = 1; i < argc; ++i)
+    {
+		if (argv[i][0] == '-')
+		{
+			switch (argv[i][1])
+			{
+				case 'f':
+				usewin = TRUE;
+				break;
+
+				case 'd':
+				if (i < argc - 1
+#ifdef FEAT_DIFF
+				/* require using "-dev", "-d" means diff mode */
+				&& argv[i][2] == 'e' && argv[i][3] == 'v'
+#endif
+			)
+                device = (char_u *)argv[i + 1];
+                break;
+            }
+        }
+    }
+
+/*
+ * If we were not started from workbench, do not have a "-d" or "-dev"
+ * argument and we have been started with an interactive window, use that
+ * window.
+ */
+    if (argc != 0
+	    && device == NULL
+	    && (IsInteractive(Input()) || IsInteractive(Output())))
+	return OK;
+
+/*
+ * When given the "-f" argument, we open our own window. We can't use the
+ * newcli trick below, because the calling program (mail, rn, etc.) would not
+ * know when we are finished.
+ */
+    if (usewin)
+    {
+		/*
+		 * Try to open a window. First try the specified device.
+		 * Then try a 24 line 80 column window.
+		 * If that fails, try two smaller ones.
+		 */
+		for (i = -1; i < 3; ++i)
+		{
+			if (i >= 0)
+                device = constrings[i];
+			if (device != NULL &&
+                (raw_in = Open((UBYTE *) device,
+				 (long) MODE_NEWFILE)) != (BPTR) NULL)
+                break;
+		}
+		if (raw_in == (BPTR)NULL)	/* all three failed */
+		{
+			mch_errmsg(_(winerr));
+			goto exit;
+		}
+		raw_out = raw_in;
+		close_win = TRUE;
+		return OK;
+    }
+
+    if ((nilfh = Open((UBYTE *) "NIL:", (long) MODE_NEWFILE)) == (BPTR) NULL)
+    {
+		mch_errmsg(_("Cannot open NIL:\n"));
+		goto exit;
+    }
+
+    /*
+     * Make a unique name for the temp file (which we will not delete!).
+     * Use a pointer on the stack (nobody else will be using it).
+     * Under AmigaOS4, this assumption might change in the future, so
+     * we use a pointer to the current task instead. This should be a
+     * shared structure and thus globally unique.
+     */
+    sprintf((char *)buf1, "t:nc%ld", (long)buf1);
+    if ((fh = Open((UBYTE *)buf1, (long)MODE_NEWFILE)) == (BPTR)NULL)
+    {
+		mch_errmsg(_("Cannot create "));
+		mch_errmsg((char *)buf1);
+		mch_errmsg("\n");
+		goto exit;
+    }
+
+    /*
+     * Write the command into the file, put quotes around the arguments that
+     * have a space in them.
+     */
+    if (argc == 0)	/* run from workbench */
+		ac = ((struct WBStartup *) argv)->sm_NumArgs;
+    else
+		ac = argc;
+    for (i = 0; i < ac; ++i)
+    {
+		if (argc == 0)
+		{
+			*buf2 = NUL;
+			argp = &(((struct WBStartup *) argv)->sm_ArgList[i]);
+			if (argp->wa_Lock)
+                (void)lock2name(argp->wa_Lock, buf2, (long) (BUF2SIZE - 1));
+            AddPart((UBYTE *) buf2, (UBYTE *) argp->wa_Name, (long) (BUF2SIZE - 1));
+            av = (char *) buf2;
+        }
+        else
+            av = argv[i];
+
+        /* skip '-d' or "-dev" option */
+        if (av[0] == '-' && av[1] == 'd'
+#ifdef FEAT_DIFF
+            && av[2] == 'e' && av[3] == 'v'
+#endif
+           )
+        {
+            ++i;
+            continue;
+        }
+        if (vim_strchr((char_u *)av, ' '))
+            Write(fh, "\"", 1L);
+        Write(fh, av, (long)strlen(av));
+        if (vim_strchr((char_u *)av, ' '))
+            Write(fh, "\"", 1L);
+        Write(fh, " ", 1L);
+    }
+    Write(fh, "\nendcli\n", 8L);
+    Close(fh);
+
+    /*
+     * Try to open a new cli in a window. If "-d" or "-dev" argument was given try
+     * to open the specified device. Then try a 24 line 80 column window.  If that
+     * fails, try two smaller ones.
+     */
+    for (i = -1; i < 3; ++i)
+    {
+        if (i >= 0)
+            device = constrings[i];
+        else if (device == NULL)
+            continue;
+        sprintf((char *)buf2, "newcli <nil: >nil: %s from %s", (char *) device, (char *) buf1);
+        if (SystemTags((STRPTR) buf2,
+                        SYS_UserShell, TRUE,
+						TAG_DONE
+						) != -1
+            )
+            break;
+    }
+
+    if (i == 3)	    /* all three failed */
+    {
+        DeleteFile((UBYTE *)buf1);
+        mch_errmsg(_(winerr));
+        goto exit;
+    }
+    exitval = 0;    /* The Execute succeeded: exit this program */
+
+exit:
+
+    exit(exitval);
+    /* NOTREACHED */
+    return FAIL;
+}
+
+/*
+ * Return TRUE if the input comes from a terminal, FALSE otherwise.
+ * We fake there is a window, because we can always open one!
+ */
+int mch_input_isatty()
+{
+    return TRUE;
+}
+
+/*
+ * fname_case(): Set the case of the file name, if it already exists.
+ *		 This will cause the file name to remain exactly the same
+ *		 if the file system ignores, but preserves case.
+ */
+/*ARGSUSED*/
+void fname_case(char_u *name,
+                int len             /* buffer size, ignored here */
+               )
+{
+    struct FileInfoBlock    *fib;
+    size_t		    flen;
+
+    fib = get_fib(name);
+    if (fib != NULL)
+    {
+        flen = STRLEN(name);
+        if (flen == strlen((char *) fib->fib_FileName))	/* safety check */
+            mch_memmove(name, fib->fib_FileName, flen);
+        free_fib(fib);
+    }
+}
+
+/*
+ * Get the FileInfoBlock for file "fname"
+ * The returned structure has to be free()d.
+ * Returns NULL on error.
+ */
+static struct FileInfoBlock *get_fib(char_u *fname)
+{
+    BPTR flock;
+    struct FileInfoBlock *fib;
+
+    if (fname == NULL)	    /* safety check */
+        return NULL;
+    fib = (struct FileInfoBlock *)alloc(sizeof(struct FileInfoBlock));
+    if (fib != NULL)
+    {
+        flock = Lock((UBYTE *)fname, (long)ACCESS_READ);
+        if (flock == (BPTR)NULL || !Examine(flock, fib))
+        {
+            free_fib(fib);  /* in case of an error the memory is freed here */
+            fib = NULL;
+        }
+        if (flock)
+            UnLock(flock);
+    }
+    return fib;
+}
+
+#ifdef FEAT_TITLE
+/*
+ * set the title of our window
+ * icon name is not set
+ */
+    void
+mch_settitle(title, icon)
+    char_u  *title;
+    char_u  *icon;
+{
+    if (wb_window != NULL && title != NULL)
+	SetWindowTitles(wb_window, (UBYTE *)title, (UBYTE *) -1L);
+}
+
+/*
+ * Restore the window/icon title.
+ * which is one of:
+ *  1  Just restore title
+ *  2  Just restore icon (which we don't have)
+ *  3  Restore title and icon (which we don't have)
+ */
+void mch_restore_title(which)
+    int which;
+{
+    if (which & 1)
+        mch_settitle(oldwindowtitle, NULL);
+}
+
+int mch_can_restore_title()
+{
+    return (wb_window != NULL);
+}
+
+int mch_can_restore_icon()
+{
+    return FALSE;
+}
+#endif
+
+/*
+ * Insert user name in s[len].
+ */
+int mch_get_user_name(char_u  *s, int len)
+{
+    /* TODO: Implement this. */
+    *s = NUL;
+    return FAIL;
+}
+
+/*
+ * Insert host name is s[len].
+ */
+void mch_get_host_name(char_u  *s, int len)
+{
+    vim_strncpy(s, (unsigned char *) "Aros", len - 1);
+}
+
+/*
+ * return process ID
+ */
+long mch_get_pid()
+{
+    return (long) 0;
+}
+
+/*
+ * Get name of current directory into buffer 'buf' of length 'len' bytes.
+ * Return OK for success, FAIL for failure.
+ */
+int
+mch_dirname(char_u *buf, int len)
+{
+    return mch_FullName((char_u *)"", buf, len, FALSE);
+}
+
+/*
+ * get absolute file name into buffer 'buf' of length 'len' bytes
+ *
+ * return FAIL for failure, OK otherwise
+ */
+int mch_FullName(char_u *fname, char_u *buf, int len, int force)
+{
+    BPTR l;
+    int retval = FAIL;
+    int	i;
+
+    /* Lock the file.  If it exists, we can get the exact name. */
+    if ((l = Lock((UBYTE *)fname, (long)ACCESS_READ)) != (BPTR)0)
+    {
+        retval = lock2name(l, buf, (long)len - 1);
+        UnLock(l);
+    }
+    else if (force || !mch_isFullName(fname))	    /* not a full path yet */
+    {
+        /*
+         * If the file cannot be locked (doesn't exist), try to lock the
+         * current directory and concatenate the file name.
+         */
+        if ((l = Lock((UBYTE *)"", (long)ACCESS_READ)) != (BPTR)NULL)
+        {
+            retval = lock2name(l, buf, (long)len);
+            UnLock(l);
+            if (retval == OK)
+            {
+            i = STRLEN(buf);
+            /* Concatenate the fname to the directory.  Don't add a slash
+             * if fname is empty, but do change "" to "/". */
+            if (i == 0 || *fname != NUL)
+            {
+                if (i < len - 1 && (i == 0 || buf[i - 1] != ':'))
+                buf[i++] = '/';
+                vim_strncpy(buf + i, fname, len - i - 1);
+            }
+            }
+        }
+    }
+    if (*buf == 0 || *buf == ':')
+        retval = FAIL;	/* something failed; use the file name */
+    return retval;
+}
+
+/*
+ * Return TRUE if "fname" does not depend on the current directory.
+ */
+int mch_isFullName(char_u *fname)
+{
+    return (vim_strchr(fname, ':') != NULL && *fname != ':');
+}
+
+/*
+ * Get the full file name from a lock. Use 2.0 function if possible, because
+ * the arp function has more restrictions on the path length.
+ *
+ * return FAIL for failure, OK otherwise
+ */
+static int lock2name(BPTR lock, char_u *buf, long len)
+{
+    return ((int) NameFromLock(lock, (UBYTE *)buf, len) ? OK : FAIL);
+}
+
+/*
+ * get file permissions for 'name'
+ * Returns -1 when it doesn't exist.
+ */
+long mch_getperm(char_u *name)
+{
+    struct FileInfoBlock *fib;
+    long retval = -1;
+
+    fib = get_fib(name);
+    if (fib != NULL)
+    {
+        retval = fib->fib_Protection;
+        free_fib(fib);
+    }
+    return retval;
+}
+
+/*
+ * set file permission for 'name' to 'perm'
+ *
+ * return FAIL for failure, OK otherwise
+ */
+int mch_setperm(char_u  *name, long perm)
+{
+    perm &= ~FIBF_ARCHIVE;		/* reset archived bit */
+    return (SetProtection((UBYTE *)name, (long)perm) ? OK : FAIL);
+}
+
+/*
+ * Set hidden flag for "name".
+ */
+void mch_hide(char_u *name)
+{
+    /* can't hide a file */
+}
+
+/*
+ * return FALSE if "name" is not a directory
+ * return TRUE if "name" is a directory.
+ * return FALSE for error.
+ */
+int mch_isdir(char_u *name)
+{
+    struct FileInfoBlock *fib;
+    int retval = FALSE;
+
+    fib = get_fib(name);
+    if (fib != NULL)
+    {
+        retval = ((fib->fib_DirEntryType >= 0) ? TRUE : FALSE);
+        free_fib(fib);
+    }
+    return retval;
+}
+
+/*
+ * Create directory "name".
+ */
+int mch_mkdir(char_u *name)
+{
+    BPTR lock;
+
+    lock = CreateDir(name);
+    if (lock != NULL)
+    {
+        UnLock(lock);
+        return 0;
+    }
+    return -1;
+}
+
+/*
+ * Return 1 if "name" can be executed, 0 if not.
+ * Return -1 if unknown.
+ */
+int mch_can_exe(char_u *name)
+{
+    /* TODO */
+    return -1;
+}
+
+/*
+ * Check what "name" is:
+ * NODE_NORMAL: file or directory (or doesn't exist)
+ * NODE_WRITABLE: writable device, socket, fifo, etc.
+ * NODE_OTHER: non-writable things
+ */
+int mch_nodetype(char_u *name)
+{
+    /* TODO */
+    return NODE_NORMAL;
+}
+
+void mch_early_init()
+{
+}
+
+/*
+ * Careful: mch_exit() may be called before mch_init()!
+ */
+void mch_exit(int r)
+{
+	gui_exit(r);
+    if (raw_in)			    /* put terminal in 'normal' mode */
+    {
+		settmode(TMODE_COOK);
+		stoptermcap();
+    }
+    out_char('\n');
+    if (raw_out)
+    {
+		if (term_console)
+		{
+			win_resize_off();	    /* window resize events de-activated */
+			if (size_set)
+			OUT_STR("\233t\233u");	/* reset window size (CSI t CSI u) */
+		}
+		out_flush();
+    }
+
+#ifdef FEAT_TITLE
+    mch_restore_title(3);	    /* restore window title */
+#endif
+
+    ml_close_all(TRUE);		    /* remove all memfiles */
+
+    if (close_win)
+        Close(raw_in);
+    if (r)
+        printf(_("Vim exiting with %d\n"), r); /* somehow this makes :cq work!? */
+    exit(r);
+}
+
+#define MP(xx)	((struct MsgPort *)((struct FileHandle *) (BADDR(xx)))->fh_Type)
+
+/*
+ * Function mch_settmode() - Convert the specified file pointer to 'raw' or
+ * 'cooked' mode. This only works on TTY's.
+ *
+ * Raw: keeps DOS from translating keys for you, also (BIG WIN) it means
+ *	getch() will return immediately rather than wait for a return. You
+ *	lose editing features though.
+ *
+ * Cooked: This function returns the designate file pointer to it's normal,
+ *	wait for a <CR> mode. This is exactly like raw() except that
+ *	it sends a 0 to the console to make it back into a CON: from a RAW:
+ */
+void mch_settmode(int tmode)
+{
+    if (!SetMode(raw_in, tmode == TMODE_RAW ? 1 : 0))
+        mch_errmsg(_("cannot change console mode ?!\n"));
+}
+
+/*
+ * set screen mode, always fails.
+ */
+int mch_screenmode(char_u *arg)
+{
+    EMSG(_(e_screenmode));
+    return FAIL;
+}
+
+/*
+ * Code for this routine came from the following :
+ *
+ * ConPackets.c -  C. Scheppner, A. Finkel, P. Lindsay	CBM
+ *   DOS packet example
+ *   Requires 1.2
+ *
+ * Found on Fish Disk 56.
+ *
+ * Heavely modified by mool.
+ */
+
+#include <devices/conunit.h>
+
+/*
+ * try to get the real window size
+ * return FAIL for failure, OK otherwise
+ */
+int mch_get_shellsize()
+{
+    struct ConUnit *conUnit;
+    char id_a[sizeof(struct InfoData) + 3];
+    struct InfoData *id=0;
+
+    if (!term_console)	/* not an amiga window */
+        goto out;
+
+    /* insure longword alignment */
+    id = (struct InfoData *)(((long)id_a + 3L) & ~3L);
+
+    /*
+     * Should make console aware of real window size, not the one we set.
+     * Unfortunately, under DOS 2.0x this redraws the window and it
+     * is rarely needed, so we skip it now, unless we changed the size.
+     */
+    if (size_set)
+	OUT_STR("\233t\233u");	/* CSI t CSI u */
+    out_flush();
+
+#if 0
+    // FIXME: Info() crashes
+    if (!Info(raw_out, id)
+		 || (wb_window = (struct Window *) id->id_VolumeNode) == NULL)
+#else
+    if (dos_packet(MP(raw_out), (long)ACTION_DISK_INFO, MKBADDR(id)) == 0
+	    || (wb_window = (struct Window *)id->id_VolumeNode) == NULL)
+#endif
+    {
+        /* it's not an amiga window, maybe aux device */
+        /* terminal type should be set */
+        term_console = FALSE;
+        goto out;
+    }
+    if (oldwindowtitle == NULL)
+        oldwindowtitle = (char_u *)wb_window->Title;
+    if ((BPTR) id->id_InUse == (BPTR)NULL)
+    {
+        mch_errmsg(_("mch_get_shellsize: not a console??\n"));
+        return FAIL;
+    }
+    conUnit = (struct ConUnit *) ((struct IOStdReq *) id->id_InUse)->io_Unit;
+
+    /* get window size */
+    Rows = conUnit->cu_YMax + 1;
+    Columns = conUnit->cu_XMax + 1;
+    if (Rows < 0 || Rows > 200)	    /* cannot be an amiga window */
+    {
+        Columns = 80;
+        Rows = 24;
+        term_console = FALSE;
+        return FAIL;
+    }
+
+    return OK;
+out:
+    return FAIL;
+}
+
+/*
+ * Try to set the real window size to Rows and Columns.
+ */
+void mch_set_shellsize()
+{
+    if (term_console)
+    {
+        size_set = TRUE;
+        out_char(CSI);
+        out_num((long)Rows);
+        out_char('t');
+        out_char(CSI);
+        out_num((long)Columns);
+        out_char('u');
+        out_flush();
+    }
+}
+
+/*
+ * Rows and/or Columns has changed.
+ */
+void mch_new_shellsize()
+{
+    /* Nothing to do. */
+}
+
+/*
+ * out_num - output a (big) number fast
+ */
+static void out_num(long n)
+{
+    OUT_STR_NF(tltoa((unsigned long) n));
+}
+
+static long
+dos_packet(struct MsgPort *pid, long action, long arg)
+{
+    return DoPkt(pid, action, arg, 0L, 0L, 0L, 0L);	/* use 2.0 function */
+}
+
+
+/*
+ * Call shell.
+ * Return error number for failure, 0 otherwise
+ */
+/* SHELL_*, see vim.h */
+int mch_call_shell(char_u *cmd, int options)
+{
+    BPTR	mydir;
+    int		x;
+    int		tmode = cur_tmode;
+    int		retval = 0;
+
+    if (close_win)
+    {
+        /* if Vim opened a window: Executing a shell may cause crashes */
+        EMSG(_("E360: Cannot execute shell with -f option"));
+        return -1;
+    }
+
+    if (term_console)
+	win_resize_off();	    /* window resize events de-activated */
+    out_flush();
+
+    if (options & SHELL_COOKED)
+	settmode(TMODE_COOK);	    /* set to normal mode */
+    mydir = Lock((UBYTE *)"", (long)ACCESS_READ);   /* remember current dir */
+
+    if (cmd == NULL)
+    {
+	    x = SystemTags(p_sh, SYS_UserShell, TRUE, TAG_DONE);
+    }
+    else
+    {
+	    x = SystemTags((unsigned char *)cmd, SYS_UserShell, TRUE, TAG_DONE);
+    }
+    if (x < 0)
+    {
+        MSG_PUTS(_("Cannot execute "));
+        if (cmd == NULL)
+        {
+            MSG_PUTS(_("shell "));
+            msg_outtrans(p_sh);
+        }
+        else
+            msg_outtrans(cmd);
+        msg_putchar('\n');
+        retval = -1;
+    }
+    else if (x)
+    {
+        if ((x = IoErr()) != 0)
+        {
+            if (!(options & SHELL_SILENT))
+            {
+            msg_putchar('\n');
+            msg_outnum((long)x);
+            MSG_PUTS(_(" returned\n"));
+            }
+            retval = x;
+        }
+    }
+
+    if ((mydir = CurrentDir(mydir)) != 0) /* make sure we stay in the same directory */
+        UnLock(mydir);
+    if (tmode == TMODE_RAW)
+        settmode(TMODE_RAW);		/* set to raw mode */
+#ifdef FEAT_TITLE
+    resettitle();
+#endif
+    if (term_console)
+        win_resize_on();		/* window resize events activated */
+    return retval;
+}
+
+/*
+ * check for an "interrupt signal"
+ * We only react to a CTRL-C, but also clear the other break signals to avoid
+ * trouble with lattice-c programs.
+ */
+void mch_breakcheck()
+{
+    if (SetSignal(0L, (long) (SIGBREAKF_CTRL_C |
+                              SIGBREAKF_CTRL_D |
+                              SIGBREAKF_CTRL_E |
+                              SIGBREAKF_CTRL_F)) & SIGBREAKF_CTRL_C)
+        got_int = TRUE;
+}
+
+/* this routine causes manx to use this Chk_Abort() rather than it's own */
+/* otherwise it resets our ^C when doing any I/O (even when Enable_Abort */
+/* is zero).  Since we want to check for our own ^C's			 */
+long Chk_Abort(void)
+{
+    return(0L);
+}
+
+/*
+ * mch_expandpath() - this code does wild-card pattern matching using the arp
+ *		      routines.
+ *
+ * "pat" has backslashes before chars that are not to be expanded.
+ * Returns the number of matches found.
+ *
+ * This is based on WildDemo2.c (found in arp1.1 distribution).
+ * That code's copyright follows:
+ *	Copyright (c) 1987, Scott Ballantyne
+ *	Use and abuse as you please.
+ */
+
+# define ANCHOR_BUF_SIZE (512)
+# define ANCHOR_SIZE (sizeof(struct AnchorPath) + ANCHOR_BUF_SIZE)
+
+int mch_expandpath(garray_T *gap,
+                   char_u *pat,
+                   int flags        /* EW_* flags */
+                  )
+{
+    struct AnchorPath *Anchor;
+    LONG Result;
+    char_u *starbuf, *sp, *dp;
+    int	start_len;
+    int	matches = 0;
+
+    start_len = gap->ga_len;
+
+    /* Get our AnchorBase */
+    Anchor = (struct AnchorPath *)alloc_clear((unsigned)ANCHOR_SIZE);
+    if (Anchor == NULL)
+        return 0;
+
+    Anchor->ap_Strlen = ANCHOR_BUF_SIZE;  /* ap_Length not supported anymore */
+# ifdef APF_DODOT
+    Anchor->ap_Flags = APF_DODOT | APF_DOWILD;	/* allow '.' for current dir */
+# else
+    Anchor->ap_Flags = APF_DoDot | APF_DoWild;	/* allow '.' for current dir */
+# endif
+
+	/* hack to replace '*' by '#?' */
+	starbuf = alloc((unsigned)(2 * STRLEN(pat) + 1));
+	if (starbuf == NULL)
+	    goto Return;
+	for (sp = pat, dp = starbuf; *sp; ++sp)
+	{
+	    if (*sp == '*')
+	    {
+            *dp++ = '#';
+            *dp++ = '?';
+	    }
+	    else
+            *dp++ = *sp;
+	}
+	*dp = NUL;
+	Result = MatchFirst((UBYTE *)starbuf, Anchor);
+	vim_free(starbuf);
+
+    /*
+     * Loop to get all matches.
+     */
+    while (Result == 0)
+    {
+        addfile(gap, (char_u *)Anchor->ap_Buf, flags);
+        Result = MatchNext(Anchor);
+    }
+    matches = gap->ga_len - start_len;
+
+    if (Result == ERROR_BUFFER_OVERFLOW)
+        EMSG(_("ANCHOR_BUF_SIZE too small."));
+    else if (matches == 0 && Result != ERROR_OBJECT_NOT_FOUND
+			  && Result != ERROR_DEVICE_NOT_MOUNTED
+			  && Result != ERROR_NO_MORE_ENTRIES)
+        EMSG(_("I/O ERROR"));
+
+    /*
+     * Sort the files for this pattern.
+     */
+    if (matches)
+        qsort((void *)(((char_u **)gap->ga_data) + start_len),
+                      (size_t)matches, sizeof(char_u *), sortcmp);
+
+    MatchEnd(Anchor);
+
+Return:
+    vim_free(Anchor);
+    return matches;
+}
+
+static int sortcmp(const void *a, const void *b)
+{
+    char *s = *(char **)a;
+    char *t = *(char **)b;
+
+    return pathcmp(s, t, -1);
+}
+
+/*
+ * Return TRUE if "p" has wildcards that can be expanded by mch_expandpath().
+ */
+int mch_has_exp_wildcard(char_u *p)
+{
+    for ( ; *p; mb_ptr_adv(p))
+    {
+        if (*p == '\\' && p[1] != NUL)
+            ++p;
+        else if (vim_strchr((char_u *) "*?[(#", *p) != NULL)
+            return TRUE;
+    }
+    return FALSE;
+}
+
+int mch_has_wildcard(char_u *p)
+{
+    for ( ; *p; mb_ptr_adv(p))
+    {
+        if (*p == '\\' && p[1] != NUL)
+            ++p;
+        else
+            if (vim_strchr((char_u *)
+# ifdef VIM_BACKTICK
+				    "*?[(#$`"
+#else
+				    "*?[(#$"
+#endif
+						, *p) != NULL
+		    || (*p == '~' && p[1] != NUL))
+                return TRUE;
+    }
+    return FALSE;
+}
+
+/*
+ * With AmigaDOS 2.0 support for reading local environment variables
+ *
+ * Two buffers are allocated:
+ * - A big one to do the expansion into.  It is freed before returning.
+ * - A small one to hold the return value.  It is kept until the next call.
+ */
+char_u *mch_getenv(char_u *var)
+{
+    int		    len;
+    UBYTE	    *buf;		/* buffer to expand in */
+    char_u	    *retval;		/* return value */
+    static char_u   *alloced = NULL;	/* allocated memory */
+
+    vim_free(alloced);
+    alloced = NULL;
+    retval = NULL;
+
+    buf = alloc(IOSIZE);
+    if (buf == NULL)
+        return NULL;
+
+    len = GetVar((UBYTE *)var, buf, (long)(IOSIZE - 1), (long)0);
+    if (len >= 0)
+    {
+        retval = vim_strsave((char_u *)buf);
+        alloced = retval;
+    }
+
+    vim_free(buf);
+
+    /* if $VIM is not defined, use "PROGDIR:" instead */
+    if (retval == NULL && STRCMP(var, "VIM") == 0)
+        retval = (char_u *) "PROGDIR:";
+
+    return retval;
+}
+
+/*
+ * Amiga version of setenv() with AmigaDOS 2.0 support.
+ */
+/* ARGSUSED */
+int mch_setenv(char *var, char *value, int   x)
+{
+    if (SetVar((UBYTE *)var, (UBYTE *)value, (LONG)-1, (ULONG)GVF_LOCAL_ONLY))
+        return 0;   /* success */
+    return -1;	    /* failure */
+}
diff -Naur vim72-orig/src/os_aros.h vim72/src/os_aros.h
--- vim72-orig/src/os_aros.h	1970-01-01 01:00:00.000000000 +0100
+++ vim72/src/os_aros.h	2015-04-26 20:18:37.761393121 +0200
@@ -0,0 +1,183 @@
+/* vi:set ts=8 sts=4 sw=4:
+ *
+ * VIM - Vi IMproved	by Bram Moolenaar
+ *
+ * Do ":help uganda"  in Vim to read copying and usage conditions.
+ * Do ":help credits" in Vim to see a list of people who contributed.
+ */
+
+/*
+ * AROS dependent things
+ */
+
+#define CASE_INSENSITIVE_FILENAME   /* ignore case when comparing file names */
+#define SPACE_IN_FILENAME
+#define USE_FNAME_CASE		    /* adjust case of file names */
+#define USE_TERM_CONSOLE
+#define HAVE_AVAIL_MEM
+
+#ifndef HAVE_CONFIG_H
+# define HAVE_STDLIB_H
+# define HAVE_STRING_H
+# define HAVE_FCNTL_H
+# define HAVE_STRCSPN
+# define HAVE_STRICMP
+# define HAVE_STRNICMP
+# define HAVE_STRFTIME	    /* guessed */
+# define HAVE_SETENV
+# define HAVE_MEMSET
+# define HAVE_QSORT
+# if defined(__DATE__) && defined(__TIME__)
+#  define HAVE_DATE_TIME
+# endif
+
+#endif /* HAVE_CONFIG_H */
+
+#ifndef	DFLT_ERRORFILE
+# define DFLT_ERRORFILE		"AztecC.Err"	/* Should this change? */
+#endif
+
+#ifndef	DFLT_RUNTIMEPATH
+# define DFLT_RUNTIMEPATH "home:vimfiles,$VIM/vimfiles,$VIMRUNTIME,$VIM/vimfiles/after,home:vimfiles/after"
+#endif
+
+#ifndef	BASENAMELEN
+# define BASENAMELEN	26	/* Amiga */
+#endif
+
+#ifndef	TEMPNAME
+# define TEMPNAME	"t:v?XXXXXX"
+# define TEMPNAMELEN	12
+#endif
+
+#include <exec/types.h>
+#include <libraries/dos.h>
+#include <libraries/dosextens.h>
+
+# include <proto/exec.h>
+# include <proto/dos.h>
+# include <proto/intuition.h>
+
+#define FNAME_ILLEGAL ";*?`#%" /* illegal characters in a file name */
+
+#ifdef __GNUC__
+# include <sys/stat.h>
+# include <unistd.h>
+#endif
+
+/*
+ * This won't be needed if you have a version of Lattice 4.01 without broken
+ * break signal handling.
+ */
+#include <signal.h>
+
+/*
+ * Names for the EXRC, HELP and temporary files.
+ * Some of these may have been defined in the makefile.
+ */
+#ifndef SYS_VIMRC_FILE
+# define SYS_VIMRC_FILE "PROGDIR:vimrc"
+#endif
+#ifndef SYS_GVIMRC_FILE
+# define SYS_GVIMRC_FILE "PROGDIR:gvimrc"
+#endif
+#ifndef SYS_MENU_FILE
+# define SYS_MENU_FILE	"PROGDIR:runtime/menu.vim"
+#endif
+#ifndef DFLT_HELPFILE
+# define DFLT_HELPFILE	"PROGDIR:runtime/doc/help.txt"
+#endif
+#ifndef FILETYPE_FILE
+# define FILETYPE_FILE	"filetype.vim"
+#endif
+#ifndef FTPLUGIN_FILE
+# define FTPLUGIN_FILE	"ftplugin.vim"
+#endif
+#ifndef INDENT_FILE
+# define INDENT_FILE	"indent.vim"
+#endif
+#ifndef FTOFF_FILE
+# define FTOFF_FILE	"ftoff.vim"
+#endif
+#ifndef FTPLUGOF_FILE
+# define FTPLUGOF_FILE	"ftplugof.vim"
+#endif
+#ifndef INDOFF_FILE
+# define INDOFF_FILE	"indoff.vim"
+#endif
+#ifndef SYNTAX_FNAME
+# define SYNTAX_FNAME	"PROGDIR:runtime/syntax/%s.vim"
+#endif
+
+#ifndef USR_EXRC_FILE
+# define USR_EXRC_FILE	"S:exrc"
+#endif
+//#ifndef USR_EXRC_FILE2
+//# define USR_EXRC_FILE2	"home:.exrc"
+//#endif
+
+#ifndef USR_VIMRC_FILE
+# define USR_VIMRC_FILE	"S:vimrc"
+#endif
+//#ifndef USR_VIMRC_FILE2
+//# define USR_VIMRC_FILE2 "home:.vimrc"
+//#endif
+//#ifndef USR_VIMRC_FILE3
+//# define USR_VIMRC_FILE3 "$VIM/.vimrc"
+//#endif
+
+#ifndef EVIM_FILE
+# define EVIM_FILE	"PROGDIR:runtime/evim.vim"
+#endif
+
+#ifndef USR_GVIMRC_FILE
+# define USR_GVIMRC_FILE "S:gvimrc"
+#endif
+//#ifndef USR_GVIMRC_FILE2
+//# define USR_GVIMRC_FILE2 "home:.gvimrc"
+//#endif
+//#ifndef USR_GVIMRC_FILE3
+//# define USR_GVIMRC_FILE3 "$VIM/.gvimrc"
+//#endif
+
+#ifdef FEAT_VIMINFO
+# ifndef VIMINFO_FILE
+#  define VIMINFO_FILE	"PROGDIR:viminfo"
+# endif
+#endif /* FEAT_VIMINFO */
+
+#ifndef EXRC_FILE
+# define EXRC_FILE	".exrc"
+#endif
+
+#ifndef VIMRC_FILE
+# define VIMRC_FILE	".vimrc"
+#endif
+
+#ifndef GVIMRC_FILE
+# define GVIMRC_FILE	".gvimrc"
+#endif
+
+#ifndef DFLT_BDIR
+# define DFLT_BDIR	".,t:"		/* default for 'backupdir' */
+#endif
+
+#ifndef DFLT_DIR
+# define DFLT_DIR	".,t:"		/* default for 'directory' */
+#endif
+
+#ifndef DFLT_VDIR
+# define DFLT_VDIR	"PROGDIR:vimfiles/view"	/* default for 'viewdir' */
+#endif
+
+#ifndef DFLT_MAXMEM
+# define DFLT_MAXMEM	256		/* use up to 256Kbyte for buffer */
+#endif
+#ifndef DFLT_MAXMEMTOT
+# define DFLT_MAXMEMTOT	0		/* decide in set_init */
+#endif
+
+#define mch_remove(x) remove((char *)(x))
+#define mch_rename(src, dst) rename(src, dst)
+#define mch_chdir(s) chdir(s)
+#define vim_mkdir(x, y) mch_mkdir(x)
diff -Naur vim72-orig/src/popupmnu.c vim72/src/popupmnu.c
--- vim72-orig/src/popupmnu.c	2015-04-26 10:11:05.170298439 +0200
+++ vim72/src/popupmnu.c	2015-04-26 10:12:03.587828204 +0200
@@ -641,7 +641,7 @@
 			if (resized)
 			{
 			    win_enter(curwin_save, TRUE);
-			    update_topline();
+			    update_topline(TRUE);
 			}
 
 			/* Update the screen before drawing the popup menu.
diff -Naur vim72-orig/src/proto/gui_aros.pro vim72/src/proto/gui_aros.pro
--- vim72-orig/src/proto/gui_aros.pro	1970-01-01 01:00:00.000000000 +0100
+++ vim72/src/proto/gui_aros.pro	2015-04-26 10:12:03.588828195 +0200
@@ -0,0 +1,72 @@
+    /* gui_aros.c */
+void gui_mch_add_menu_item __ARGS((vimmenu_T *menu, int idx));
+void gui_mch_add_menu __ARGS((vimmenu_T *menu, int idx));
+void gui_mch_toggle_tearoffs __ARGS((int enable));
+int gui_mch_set_blinking __ARGS((long wait, long on, long off));
+void gui_mch_prepare __ARGS((int *argc, char **argv));
+void atexitDoThis __ARGS((void));
+int gui_mch_init_check __ARGS((void));
+int gui_mch_init __ARGS((void));
+void gui_mch_new_colors __ARGS((void));
+int gui_mch_open __ARGS((void));
+void gui_mch_exit __ARGS((int returnCode));
+int gui_mch_get_winpos __ARGS((int *x, int *y));
+void gui_mch_set_winpos __ARGS((int x, int y));
+void gui_mch_set_shellsize __ARGS((int width, int height, int min_width, int min_height, int base_width, int base_height, int direction));
+void gui_mch_get_screen_dimensions __ARGS((int *screen_w, int *screen_h));
+void gui_mch_set_text_area_pos __ARGS((int x, int y, int w, int h));
+void gui_mch_set_scrollbar_bottom __ARGS((int enable));
+void gui_mch_enable_scrollbar __ARGS((scrollbar_T *sb, int flag));
+void gui_mch_set_scrollbar_thumb __ARGS((scrollbar_T *sb, long val, long size, long max));
+void gui_mch_set_scrollbar_pos __ARGS((scrollbar_T *sb, int x, int y, int w, int h));
+void gui_mch_create_scrollbar __ARGS((scrollbar_T *sb, int orient));
+void gui_mch_destroy_scrollbar __ARGS((scrollbar_T *sb));
+char_u *gui_mch_browse __ARGS((int saving, char_u *title, char_u *dflt, char_u *ext, char_u *initdir, char_u *filter));
+int gui_mch_init_font __ARGS((char_u *font_name, int fontset));
+int gui_mch_adjust_charsize __ARGS((void));
+int gui_mch_adjust_charheight __ARGS((void));
+GuiFont gui_mch_get_font __ARGS((char_u *name, int giveErrorIfMissing));
+char *gui_mch_get_fontname __ARGS((GuiFont font, char *name));
+void gui_mch_set_font __ARGS((GuiFont font));
+void gui_mch_free_font __ARGS((GuiFont font));
+guicolor_T gui_mch_get_color __ARGS((char_u *name));
+void gui_mch_set_colors __ARGS((guicolor_T fg, guicolor_T bg));
+void gui_mch_set_fg_color __ARGS((guicolor_T color));
+void gui_mch_set_bg_color __ARGS((guicolor_T color));
+void gui_mch_set_sp_color __ARGS((guicolor_T color));
+void gui_mch_draw_string __ARGS((int row, int col, char_u *s, int len, int flags));
+int gui_mch_haskey __ARGS((char_u *name));
+void gui_mch_beep __ARGS((void));
+void gui_mch_flash __ARGS((int msec));
+void gui_mch_invert_rectangle __ARGS((int r, int c, int nr, int nc));
+void gui_mch_iconify __ARGS((void));
+void gui_mch_set_foreground __ARGS((void));
+void gui_mch_settitle __ARGS((char_u *title, char_u *icon));
+void gui_mch_stop_blink __ARGS((void));
+void gui_mch_start_blink __ARGS((void));
+void gui_mch_draw_hollow_cursor __ARGS((guicolor_T color));
+void gui_mch_draw_part_cursor __ARGS((int w, int h, guicolor_T color));
+void gui_mch_update __ARGS((void));
+int gui_mch_wait_for_chars __ARGS((int wtime));
+void gui_mch_flush __ARGS((void));
+void gui_mch_clear_block __ARGS((int row1, int col1, int row2, int col2));
+void gui_mch_clear_all __ARGS((void));
+void gui_mch_delete_lines __ARGS((int row, int num_lines));
+void gui_mch_insert_lines __ARGS((int row, int num_lines));
+void gui_mch_enable_menu __ARGS((int flag));
+void gui_mch_set_menu_pos __ARGS((int x, int y, int w, int h));
+void gui_mch_destroy_menu __ARGS((vimmenu_T *menu));
+void gui_mch_menu_grey __ARGS((vimmenu_T *menu, int grey));
+void gui_mch_menu_hidden __ARGS((vimmenu_T *menu, int hidden));
+void gui_mch_draw_menubar __ARGS((void));
+int clip_mch_own_selection __ARGS((VimClipboard *cbd));
+void gui_mch_getmouse __ARGS((int *x, int *y));
+int gui_mch_get_mouse_x __ARGS((void));
+int gui_mch_get_mouse_y __ARGS((void));
+void gui_mch_setmouse __ARGS((int x, int y));
+void gui_mch_show_popupmenu __ARGS((vimmenu_T *menu));
+void clip_mch_lose_selection __ARGS((VimClipboard *cbd));
+void clip_mch_request_selection __ARGS((VimClipboard *cbd));
+void clip_mch_set_selection __ARGS((VimClipboard *cbd));
+long_u gui_mch_get_rgb __ARGS((guicolor_T pixel));
+/* vim: set ft=c : */
diff -Naur vim72-orig/src/proto/move.pro vim72/src/proto/move.pro
--- vim72-orig/src/proto/move.pro	2015-04-26 10:11:05.171298431 +0200
+++ vim72/src/proto/move.pro	2015-04-26 10:12:03.588828195 +0200
@@ -1,6 +1,6 @@
 /* move.c */
 void update_topline_redraw __ARGS((void));
-void update_topline __ARGS((void));
+void update_topline __ARGS((int bound_caret));
 void update_curswant __ARGS((void));
 void check_cursor_moved __ARGS((win_T *wp));
 void changed_window_setting __ARGS((void));
diff -Naur vim72-orig/src/proto/os_aros.pro vim72/src/proto/os_aros.pro
--- vim72-orig/src/proto/os_aros.pro	1970-01-01 01:00:00.000000000 +0100
+++ vim72/src/proto/os_aros.pro	2015-04-26 10:12:03.588828195 +0200
@@ -0,0 +1,46 @@
+/* os_aros.c */
+void win_resize_on __ARGS((void));
+void win_resize_off __ARGS((void));
+void mch_write __ARGS((char_u *p, int len));
+int mch_inchar __ARGS((char_u *buf, int maxlen, long time, int tb_change_cnt));
+int mch_char_avail __ARGS((void));
+long_u mch_avail_mem __ARGS((int special));
+void mch_delay __ARGS((long msec, int ignoreinput));
+void mch_suspend __ARGS((void));
+void mch_init __ARGS((void));
+int mch_check_win __ARGS((int argc, char **argv));
+int mch_input_isatty __ARGS((void));
+void fname_case __ARGS((char_u *name, int len));
+void mch_settitle __ARGS((char_u *title, char_u *icon));
+void mch_restore_title __ARGS((int which));
+int mch_can_restore_title __ARGS((void));
+int mch_can_restore_icon __ARGS((void));
+int mch_get_user_name __ARGS((char_u *s, int len));
+void mch_get_host_name __ARGS((char_u *s, int len));
+long mch_get_pid __ARGS((void));
+int mch_dirname __ARGS((char_u *buf, int len));
+int mch_FullName __ARGS((char_u *fname, char_u *buf, int len, int force));
+int mch_isFullName __ARGS((char_u *fname));
+long mch_getperm __ARGS((char_u *name));
+int mch_setperm __ARGS((char_u *name, long perm));
+void mch_hide __ARGS((char_u *name));
+int mch_isdir __ARGS((char_u *name));
+int mch_mkdir __ARGS((char_u *name));
+int mch_can_exe __ARGS((char_u *name));
+int mch_nodetype __ARGS((char_u *name));
+void mch_early_init __ARGS((void));
+void mch_exit __ARGS((int r));
+void mch_settmode __ARGS((int tmode));
+int mch_screenmode __ARGS((char_u *arg));
+int mch_get_shellsize __ARGS((void));
+void mch_set_shellsize __ARGS((void));
+void mch_new_shellsize __ARGS((void));
+int mch_call_shell __ARGS((char_u *cmd, int options));
+void mch_breakcheck __ARGS((void));
+long Chk_Abort __ARGS((void));
+int mch_expandpath __ARGS((garray_T *gap, char_u *pat, int flags));
+int mch_has_exp_wildcard __ARGS((char_u *p));
+int mch_has_wildcard __ARGS((char_u *p));
+char_u *mch_getenv __ARGS((char_u *var));
+int mch_setenv __ARGS((char *var, char *value, int x));
+/* vim: set ft=c : */
diff -Naur vim72-orig/src/proto.h vim72/src/proto.h
--- vim72-orig/src/proto.h	2015-04-26 10:11:05.172298423 +0200
+++ vim72/src/proto.h	2015-04-26 10:12:03.588828195 +0200
@@ -32,9 +32,12 @@
 #  define XImage int
 # endif
 
-# ifdef AMIGA
+# if defined(AMIGA)
 #  include "os_amiga.pro"
 # endif
+# if defined(AROS)
+#  include "os_aros.pro"
+# endif
 # if defined(UNIX) || defined(__EMX__) || defined(VMS)
 #  include "os_unix.pro"
 # endif
@@ -151,7 +154,7 @@
 # include "syntax.pro"
 # include "tag.pro"
 # include "term.pro"
-# if defined(HAVE_TGETENT) && (defined(AMIGA) || defined(VMS))
+# if defined(HAVE_TGETENT) && (defined(AMIGA) || defined(AROS) || defined(VMS))
 #  include "termlib.pro"
 # endif
 # include "ui.pro"
diff -Naur vim72-orig/src/quickfix.c vim72/src/quickfix.c
--- vim72-orig/src/quickfix.c	2015-04-26 10:11:05.166298471 +0200
+++ vim72/src/quickfix.c	2015-04-26 10:12:03.589828187 +0200
@@ -2363,7 +2363,7 @@
     curwin->w_cursor.lnum = qi->qf_lists[qi->qf_curlist].qf_index;
     curwin->w_cursor.col = 0;
     check_cursor();
-    update_topline();		/* scroll to show the line */
+    update_topline(TRUE);		/* scroll to show the line */
 }
 
 /*
@@ -2420,7 +2420,7 @@
 	}
 	curwin->w_cursor.lnum = qf_index;
 	curwin->w_cursor.col = 0;
-	update_topline();		/* scroll to show the line */
+	update_topline(TRUE);		/* scroll to show the line */
 	redraw_later(VALID);
 	curwin->w_redr_status = TRUE;	/* update ruler */
 	curwin = old_curwin;
@@ -2773,7 +2773,7 @@
     /* let the shell know if we are redirecting output or not */
     do_shell(cmd, *p_sp != NUL ? SHELL_DOOUT : 0);
 
-#ifdef AMIGA
+#if defined(AMIGA) || defined(AROS)
     out_flush();
 		/* read window status report and redraw before message */
     (void)char_avail();
diff -Naur vim72-orig/src/screen.c vim72/src/screen.c
--- vim72-orig/src/screen.c	2015-04-26 10:11:05.170298439 +0200
+++ vim72/src/screen.c	2015-04-26 10:12:03.589828187 +0200
@@ -1935,7 +1935,7 @@
 	{
 	    recursive = TRUE;
 	    curwin->w_valid &= ~VALID_TOPLINE;
-	    update_topline();	/* may invalidate w_botline again */
+	    update_topline(TRUE);	/* may invalidate w_botline again */
 	    if (must_redraw != 0)
 	    {
 		/* Don't update for changes in buffer again. */
@@ -8664,7 +8664,7 @@
 					&& (line_count == 1 || *T_CDL == NUL))
 #else
     else if (row == 0 && (
-#ifndef AMIGA
+#if !defined(AMIGA) && !defined(AROS)
 	/* On the Amiga, somehow '\n' on the last line doesn't always scroll
 	 * up, so use delete-line command */
 			    line_count == 1 ||
diff -Naur vim72-orig/src/structs.h vim72/src/structs.h
--- vim72-orig/src/structs.h	2015-04-26 10:11:05.166298471 +0200
+++ vim72/src/structs.h	2015-04-26 10:12:03.589828187 +0200
@@ -10,6 +10,9 @@
  * This file contains various definitions of structures that are used by Vim
  */
 
+#ifndef _STRUCTS_H_
+#define _STRUCTS_H_
+
 /*
  * There is something wrong in the SAS compiler that makes typedefs not
  * valid in include files.  Has been fixed in version 6.58.
@@ -86,6 +89,12 @@
 # define guicolor_T int		/* avoid error in prototypes */
 #endif
 
+#ifdef AROS
+#include <sys/types.h>
+#include <stdio.h>
+#include <stdlib.h>
+#endif
+
 /*
  * marks: positions in a file
  * (a normal mark is a lnum/col pair, the same as a file position)
@@ -2366,3 +2375,5 @@
 #define CPT_KIND    2	/* "kind" */
 #define CPT_INFO    3	/* "info" */
 #define CPT_COUNT   4	/* Number of entries */
+
+#endif
diff -Naur vim72-orig/src/tag.c vim72/src/tag.c
--- vim72-orig/src/tag.c	2015-04-26 10:11:05.164298487 +0200
+++ vim72/src/tag.c	2015-04-26 10:12:03.590828179 +0200
@@ -3397,7 +3397,7 @@
 simplify_filename(filename)
     char_u	*filename;
 {
-#ifndef AMIGA	    /* Amiga doesn't have "..", it uses "/" */
+#if !defined(AMIGA) && !defined(AROS)	    /* Amiga OSes don't have "..", they use "/" */
     int		components = 0;
     char_u	*p, *tail, *start;
     int		stripping_disabled = FALSE;
@@ -3597,7 +3597,7 @@
 	    p = getnextcomp(p);
 	}
     } while (*p != NUL);
-#endif /* !AMIGA */
+#endif /* !AMIGA && !AROS */
 }
 
 /*
diff -Naur vim72-orig/src/term.c vim72/src/term.c
--- vim72-orig/src/term.c	2015-04-26 10:11:05.165298479 +0200
+++ vim72/src/term.c	2015-04-26 10:12:03.590828179 +0200
@@ -10,7 +10,7 @@
  *
  * term.c: functions for controlling the terminal
  *
- * primitive termcap support for Amiga, MSDOS, and Win32 included
+ * primitive termcap support for Amiga, AROS, MSDOS, and Win32 included
  *
  * NOTE: padding and variable substitution is not performed,
  * when compiling without HAVE_TGETENT, we use tputs() and tgoto() dummies.
@@ -265,11 +265,15 @@
 # endif	/* Acorn terminal */
 
 
-# if defined(AMIGA) || defined(ALL_BUILTIN_TCAPS)
+# if defined(AMIGA) || defined(AROS) || defined(ALL_BUILTIN_TCAPS)
 /*
  * Amiga console window, default for Amiga
  */
-    {(int)KS_NAME,	"amiga"},
+#ifdef AROS
+    {(int)KS_NAME,	"aros"},
+#else
+    {(int)KS_NAME,  "amiga"},
+#endif
     {(int)KS_CE,	"\033[K"},
     {(int)KS_CD,	"\033[J"},
     {(int)KS_AL,	"\033[L"},
@@ -296,7 +300,7 @@
     {(int)KS_UE,	"\033[0m"},
     {(int)KS_CZH,	"\033[3m"},
     {(int)KS_CZR,	"\033[0m"},
-#if defined(__MORPHOS__) || defined(__AROS__)
+#if defined(__MORPHOS__) || defined(AROS)
     {(int)KS_CCO,	"8"},		/* allow 8 colors */
 #  ifdef TERMINFO
     {(int)KS_CAB,	"\033[4%p1%dm"},/* set background color */
@@ -1404,7 +1408,11 @@
 #endif
 
 #ifdef AMIGA
-# define DEFAULT_TERM	(char_u *)"amiga"
+# define DEFAULT_TERM   (char_u *)"amiga"
+#endif
+
+#ifdef AROS
+# define DEFAULT_TERM   (char_u *)"aros"
 #endif
 
 #ifdef MSWIN
@@ -1964,7 +1972,7 @@
     else
     {
 	term_console = TRUE;
-# ifdef AMIGA
+# if defined(AMIGA) || defined(AROS)
 	win_resize_on();	/* enable window resizing reports */
 # endif
     }
@@ -2389,7 +2397,7 @@
 }
 #endif
 
-#if !defined(HAVE_TGETENT) || defined(AMIGA) || defined(PROTO)
+#if !defined(HAVE_TGETENT) || defined(AMIGA) || defined(AROS) || defined(PROTO)
 
     char_u *
 tltoa(i)
@@ -2577,7 +2585,7 @@
 out_char(c)
     unsigned	c;
 {
-#if defined(UNIX) || defined(VMS) || defined(AMIGA) || defined(MACOS_X_UNIX)
+#if defined(UNIX) || defined(VMS) || defined(AMIGA) || defined(AROS) || defined(MACOS_X_UNIX)
     if (c == '\n')	/* turn LF into CR-LF (CRMOD doesn't seem to do this) */
 	out_char('\r');
 #endif
@@ -2598,7 +2606,7 @@
 out_char_nf(c)
     unsigned	c;
 {
-#if defined(UNIX) || defined(VMS) || defined(AMIGA) || defined(MACOS_X_UNIX)
+#if defined(UNIX) || defined(VMS) || defined(AMIGA) || defined(AROS) || defined(MACOS_X_UNIX)
     if (c == '\n')	/* turn LF into CR-LF (CRMOD doesn't seem to do this) */
 	out_char_nf('\r');
 #endif
@@ -3088,7 +3096,7 @@
 
     ++busy;
 
-#ifdef AMIGA
+#if defined(AMIGA) || defined(AROS)
     out_flush();	    /* must do this before mch_get_shellsize() for
 			       some obscure reason */
 #endif
@@ -3149,7 +3157,7 @@
 	    }
 	    else
 	    {
-		update_topline();
+		update_topline(TRUE);
 #if defined(FEAT_INS_EXPAND)
 		if (pum_visible())
 		{
diff -Naur vim72-orig/src/termlib.c vim72/src/termlib.c
--- vim72-orig/src/termlib.c	2015-04-26 10:11:05.169298447 +0200
+++ vim72/src/termlib.c	2015-04-26 10:12:03.590828179 +0200
@@ -13,7 +13,7 @@
 #include "vim.h"
 #include "termlib.pro"
 
-#if !defined(AMIGA) && !defined(VMS) && !defined(MACOS) && !defined(RISCOS)
+#if !defined(AMIGA) && !defined(AROS) && !defined(VMS) && !defined(MACOS) && !defined(RISCOS)
 # include <sgtty.h>
 #endif
 
@@ -54,7 +54,7 @@
  */
 
 #ifndef TERMCAPFILE
-# ifdef AMIGA
+# if defined(AMIGA) || defined(AROS)
 #  define TERMCAPFILE "s:termcap"
 # else
 #  ifdef VMS
@@ -83,7 +83,7 @@
 	if (*tmp == '/')		/* TERMCAP = name of termcap file */
 	{
 	    tcap = tmp ;
-#if defined(AMIGA)
+#if defined(AMIGA) || defined(AROS)
 	    /* Convert /usr/share/lib/termcap to usr:share/lib/termcap */
 	    tcap++;
 	    tmp = strchr(tcap, '/');
diff -Naur vim72-orig/src/ui.c vim72/src/ui.c
--- vim72-orig/src/ui.c	2015-04-26 10:11:05.165298479 +0200
+++ vim72/src/ui.c	2015-04-26 10:12:03.590828179 +0200
@@ -1691,13 +1691,13 @@
     long    maxlen;
 {
     if (inbufcount == 0)	/* if the buffer is empty, fill it */
-	fill_input_buf(TRUE);
+        fill_input_buf(TRUE);
     if (maxlen > inbufcount)
-	maxlen = inbufcount;
+        maxlen = inbufcount;
     mch_memmove(buf, inbuf, (size_t)maxlen);
     inbufcount -= maxlen;
     if (inbufcount)
-	mch_memmove(inbuf, inbuf + maxlen, (size_t)inbufcount);
+        mch_memmove(inbuf, inbuf + maxlen, (size_t)inbufcount);
     return (int)maxlen;
 }
 
@@ -1726,8 +1726,8 @@
 # endif
        )
     {
-	gui_mch_update();
-	return;
+        gui_mch_update();
+        return;
     }
 #endif
 #if defined(UNIX) || defined(OS2) || defined(VMS) || defined(MACOS_X_UNIX)
diff -Naur vim72-orig/src/undo.c vim72/src/undo.c
--- vim72-orig/src/undo.c	2015-04-26 10:11:05.165298479 +0200
+++ vim72/src/undo.c	2015-04-26 10:12:03.590828179 +0200
@@ -576,7 +576,7 @@
 	 * then u_alloc_line would have to allocate a block larger than 32K
 	 */
     if (size >= 8000)
-	goto nomem;
+        goto nomem;
 #endif
 
     /*
diff -Naur vim72-orig/src/version.c vim72/src/version.c
--- vim72-orig/src/version.c	2015-04-26 10:11:05.170298439 +0200
+++ vim72/src/version.c	2015-04-26 10:12:03.590828179 +0200
@@ -9,7 +9,7 @@
 
 #include "vim.h"
 
-#ifdef AMIGA
+#if defined(AMIGA) || defined(AROS)
 # include <time.h>	/* for time() */
 #endif
 
@@ -1102,19 +1102,19 @@
     /* blanklines = screen height - # message lines */
     blanklines = (int)Rows - ((sizeof(lines) / sizeof(char *)) - 1);
     if (!p_cp)
-	blanklines += 4;  /* add 4 for not showing "Vi compatible" message */
+        blanklines += 4;  /* add 4 for not showing "Vi compatible" message */
 #if defined(WIN3264) && !defined(FEAT_GUI_W32)
     if (mch_windows95())
-	blanklines -= 3;  /* subtract 3 for showing "Windows 95" message */
+        blanklines -= 3;  /* subtract 3 for showing "Windows 95" message */
 #endif
 
 #ifdef FEAT_WINDOWS
     /* Don't overwrite a statusline.  Depends on 'cmdheight'. */
     if (p_ls > 1)
-	blanklines -= Rows - topframe->fr_height;
+        blanklines -= Rows - topframe->fr_height;
 #endif
     if (blanklines < 0)
-	blanklines = 0;
+        blanklines = 0;
 
     /* Show the sponsor and register message one out of four times, the Uganda
      * message two out of four times. */
@@ -1191,10 +1191,10 @@
 
     if (*mesg == ' ')
     {
-	vim_strncpy(modby, (char_u *)_("Modified by "), MODBY_LEN - 1);
-	l = STRLEN(modby);
-	vim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);
-	mesg = modby;
+        vim_strncpy(modby, (char_u *)_("Modified by "), MODBY_LEN - 1);
+        l = STRLEN(modby);
+        vim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);
+        mesg = modby;
     }
 #endif
 
@@ -1202,23 +1202,23 @@
     col = vim_strsize(mesg);
     if (add_version)
     {
-	STRCPY(vers, mediumVersion);
-	if (highest_patch())
-	{
-	    /* Check for 9.9x or 9.9xx, alpha/beta version */
-	    if (isalpha((int)mediumVersion[3]))
-	    {
-		if (isalpha((int)mediumVersion[4]))
-		    sprintf((char *)vers + 5, ".%d%s", highest_patch(),
-							   mediumVersion + 5);
-		else
-		    sprintf((char *)vers + 4, ".%d%s", highest_patch(),
-							   mediumVersion + 4);
-	    }
-	    else
-		sprintf((char *)vers + 3, ".%d", highest_patch());
-	}
-	col += (int)STRLEN(vers);
+        STRCPY(vers, mediumVersion);
+        if (highest_patch())
+        {
+            /* Check for 9.9x or 9.9xx, alpha/beta version */
+            if (isalpha((int)mediumVersion[3]))
+            {
+                if (isalpha((int)mediumVersion[4]))
+                    sprintf((char *)vers + 5, ".%d%s", highest_patch(),
+                                       mediumVersion + 5);
+                else
+                    sprintf((char *)vers + 4, ".%d%s", highest_patch(),
+                                       mediumVersion + 4);
+            }
+            else
+            sprintf((char *)vers + 3, ".%d", highest_patch());
+        }
+        col += (int)STRLEN(vers);
     }
     col = (Columns - col) / 2;
     if (col < 0)
@@ -1227,22 +1227,22 @@
     /* Split up in parts to highlight <> items differently. */
     for (p = mesg; *p != NUL; p += l)
     {
-	clen = 0;
-	for (l = 0; p[l] != NUL
-			 && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)
-	{
+        clen = 0;
+        for (l = 0; p[l] != NUL
+                 && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)
+        {
 #ifdef FEAT_MBYTE
-	    if (has_mbyte)
-	    {
-		clen += ptr2cells(p + l);
-		l += (*mb_ptr2len)(p + l) - 1;
-	    }
-	    else
-#endif
-		clen += byte2cells(p[l]);
-	}
-	screen_puts_len(p, l, row, col, *p == '<' ? hl_attr(HLF_8) : attr);
-	col += clen;
+            if (has_mbyte)
+            {
+                clen += ptr2cells(p + l);
+                l += (*mb_ptr2len)(p + l) - 1;
+            }
+            else
+#endif
+                clen += byte2cells(p[l]);
+        }
+        screen_puts_len(p, l, row, col, *p == '<' ? hl_attr(HLF_8) : attr);
+        col += clen;
     }
 
     /* Add the version number to the version line. */
diff -Naur vim72-orig/src/version.h vim72/src/version.h
--- vim72-orig/src/version.h	2015-04-26 10:11:05.164298487 +0200
+++ vim72/src/version.h	2015-04-26 10:12:03.590828179 +0200
@@ -13,19 +13,19 @@
  * This doesn't use string concatenation, some compilers don't support it.
  */
 
-#define VIM_VERSION_MAJOR		 7
-#define VIM_VERSION_MAJOR_STR		"7"
-#define VIM_VERSION_MINOR		 2
-#define VIM_VERSION_MINOR_STR		"2"
-#define VIM_VERSION_100	    (VIM_VERSION_MAJOR * 100 + VIM_VERSION_MINOR)
+#define VIM_VERSION_MAJOR 7
+#define VIM_VERSION_MAJOR_STR "7"
+#define VIM_VERSION_MINOR 2
+#define VIM_VERSION_MINOR_STR "2"
+#define VIM_VERSION_100	(VIM_VERSION_MAJOR * 100 + VIM_VERSION_MINOR)
 
-#define VIM_VERSION_BUILD		 269
-#define VIM_VERSION_BUILD_BCD		0x10d
-#define VIM_VERSION_BUILD_STR		"269"
-#define VIM_VERSION_PATCHLEVEL		 0
-#define VIM_VERSION_PATCHLEVEL_STR	"0"
+#define VIM_VERSION_BUILD 269
+#define VIM_VERSION_BUILD_BCD 0x10d
+#define VIM_VERSION_BUILD_STR "269"
+#define VIM_VERSION_PATCHLEVEL 0
+#define VIM_VERSION_PATCHLEVEL_STR "0"
 /* Used by MacOS port should be one of: development, alpha, beta, final */
-#define VIM_VERSION_RELEASE		final
+#define VIM_VERSION_RELEASE	final
 
 /*
  * VIM_VERSION_NODOT is used for the runtime directory name.
@@ -33,8 +33,8 @@
  * VIM_VERSION_MEDIUM is used for the startup-screen.
  * VIM_VERSION_LONG is used for the ":version" command and "Vim -h".
  */
-#define VIM_VERSION_NODOT	"vim72"
-#define VIM_VERSION_SHORT	"7.2"
-#define VIM_VERSION_MEDIUM	"7.2"
-#define VIM_VERSION_LONG	"VIM - Vi IMproved 7.2 (2008 Aug 9)"
-#define VIM_VERSION_LONG_DATE	"VIM - Vi IMproved 7.2 (2008 Aug 9, compiled "
+#define VIM_VERSION_NODOT "vim72"
+#define VIM_VERSION_SHORT "7.2"
+#define VIM_VERSION_MEDIUM "7.2"
+#define VIM_VERSION_LONG "VIM - Vi IMproved 7.2 (2009 Dec 3)"
+#define VIM_VERSION_LONG_DATE "VIM - Vi IMproved 7.2 (2009 Dec 3, compiled "
diff -Naur vim72-orig/src/vim48x48.png vim72/src/vim48x48.png
--- vim72-orig/src/vim48x48.png	1970-01-01 01:00:00.000000000 +0100
+++ vim72/src/vim48x48.png	2015-04-26 10:12:03.590828179 +0200
@@ -0,0 +1,5 @@
+PNG
+
+   IHDR   0   0   ,   gAMA  a   PLTE         h,w   tRNS @f  `IDATxuK @y"	`P	I`>X^!Z*cK	1HO)~yaS,*wmu@%x+zH]%_b6"	t@/0Y8\`"<}SkM4B){jBRR@0!M_fpeyBl$VY	T*S^1 y4@Xt
+T8
+`\6s!dnn@WNxvB*F2lkA++![,==1cX!ewlCmk ?v.|]K!_4H    IENDB`
\ No newline at end of file
diff -Naur vim72-orig/src/vim.h vim72/src/vim.h
--- vim72-orig/src/vim.h	2015-04-26 10:11:05.169298447 +0200
+++ vim72/src/vim.h	2015-04-26 14:45:20.515120107 +0200
@@ -95,6 +95,7 @@
     || defined(FEAT_GUI_MAC) \
     || defined(FEAT_GUI_W32) \
     || defined(FEAT_GUI_W16) \
+    || defined(FEAT_GUI_AMIGA) \
     || defined(FEAT_GUI_PHOTON)
 # if !defined(FEAT_GUI) && !defined(NO_X11_INCLUDES)
 #  define FEAT_GUI
@@ -141,7 +142,7 @@
 # endif
 #endif
 
-#ifdef AMIGA
+#if defined(AMIGA) || defined(AROS)
   /* Be conservative about sizeof(int). It could be 4 too. */
 # ifndef FEAT_GUI_GTK	/* avoid problems when generating prototypes */
 #  ifdef __GNUC__
@@ -163,9 +164,16 @@
 # define SIZEOF_INT 4
 #endif
 
-
 #include "feature.h"	/* #defines for optionals and features */
 
+#ifdef AROS
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#endif
+
 /* +x11 is only enabled when it's both available and wanted. */
 #if defined(HAVE_X11) && defined(WANT_X11)
 # define FEAT_X11
@@ -284,6 +292,10 @@
 # include "os_amiga.h"
 #endif
 
+#ifdef AROS
+ #include "os_aros.h"
+#endif
+
 #ifdef MSDOS
 # include "os_msdos.h"
 #endif
@@ -1328,7 +1340,7 @@
 # define MSG_BUF_CLEN  MSG_BUF_LEN	    /* cell length */
 #endif
 
-#if defined(AMIGA) || defined(__linux__) || defined(__QNX__) || defined(__CYGWIN32__) || defined(_AIX)
+#if defined(AMIGA) || defined(AROS) || defined(__linux__) || defined(__QNX__) || defined(__CYGWIN32__) || defined(_AIX)
 # define TBUFSZ 2048		/* buffer size for termcap entry */
 #else
 # define TBUFSZ 1024		/* buffer size for termcap entry */
@@ -1862,12 +1874,20 @@
 #  define BROWSE_FILTER_DEFAULT \
 	(char_u *)"All Files (*.*)\t*.*\nC source (*.c, *.h)\t*.c;*.h\nC++ source (*.cpp, *.hpp)\t*.cpp;*.hpp\nVB code (*.bas, *.frm)\t*.bas;*.frm\nVim files (*.vim, _vimrc, _gvimrc)\t*.vim;_vimrc;_gvimrc\n"
 # else
+# if defined(AROS) || defined(AMIGA)
+#  define BROWSE_FILTER_MACROS \
+    (char_u *)"#?.vim"
+#  define BROWSE_FILTER_DEFAULT \
+    (char_u *)"#?"
+#  define BROWSE_FILTER_ALL_FILES BROWSE_FILTER_DEFAULT
+# else
 #  define BROWSE_FILTER_MACROS \
 	(char_u *)"Vim macro files (*.vim)\t*.vim\nAll Files (*)\t*\n"
 #  define BROWSE_FILTER_ALL_FILES (char_u *)"All Files (*)\t*\n"
 #  define BROWSE_FILTER_DEFAULT \
 	(char_u *)"All Files (*)\t*\nC source (*.c, *.h)\t*.c;*.h\nC++ source (*.cpp, *.hpp)\t*.cpp;*.hpp\nVim files (*.vim, _vimrc, _gvimrc)\t*.vim;_vimrc;_gvimrc\n"
 # endif
+#endif
 # define BROWSE_SAVE 1	    /* flag for do_browse() */
 # define BROWSE_DIR 2	    /* flag for do_browse() */
 #endif
@@ -2054,4 +2074,14 @@
 #define DOSO_VIMRC	1	/* loading vimrc file */
 #define DOSO_GVIMRC	2	/* loading gvimrc file */
 
+#ifdef FEAT_GUI_AMIGA
+#include "gui_amiga.h"
+#include "proto/gui_amiga.pro"
+#endif
+
+#ifdef AROS
+#include "gui_aros.h"
+#include "proto/gui_aros.pro"
+#endif
+
 #endif /* VIM__H */
diff -Naur vim72-orig/src/window.c vim72/src/window.c
--- vim72-orig/src/window.c	2015-04-26 10:11:05.166298471 +0200
+++ vim72/src/window.c	2015-04-26 10:12:03.590828179 +0200
@@ -3178,7 +3178,7 @@
 win_alloc_first()
 {
     if (win_alloc_firstwin(NULL) == FAIL)
-	return FAIL;
+        return FAIL;
 
 #ifdef FEAT_WINDOWS
     first_tabpage = alloc_tabpage();
@@ -4294,8 +4294,8 @@
 #ifdef FEAT_GUI
     if (gui.in_use)
     {
-	gui_mch_destroy_scrollbar(&wp->w_scrollbars[SBAR_LEFT]);
-	gui_mch_destroy_scrollbar(&wp->w_scrollbars[SBAR_RIGHT]);
+        gui_mch_destroy_scrollbar(&wp->w_scrollbars[SBAR_LEFT]);
+        gui_mch_destroy_scrollbar(&wp->w_scrollbars[SBAR_RIGHT]);
     }
 #endif /* FEAT_GUI */
 
@@ -5445,9 +5445,9 @@
 
     if (wp == curwin)
     {
-	if (p_so)
-	    update_topline();
-	curs_columns(FALSE);	/* validate w_wrow */
+        if (p_so)
+            update_topline(TRUE);
+        curs_columns(FALSE);	/* validate w_wrow */
     }
     wp->w_prev_fraction_row = wp->w_wrow;
 
@@ -5474,8 +5474,8 @@
     invalidate_botline_win(wp);
     if (wp == curwin)
     {
-	update_topline();
-	curs_columns(TRUE);	/* validate w_wrow */
+        update_topline(TRUE);
+        curs_columns(TRUE);	/* validate w_wrow */
     }
     redraw_win_later(wp, NOT_VALID);
     wp->w_redr_status = TRUE;
