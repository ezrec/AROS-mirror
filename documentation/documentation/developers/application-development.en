===================================
AROS Application Development Manual
===================================

:Authors:   Staf Verhaegen. Sebastian Rittau, Stefan Rieken, Matt Parsons, Adam Chodorowski,
            Fabio Alemagna
:Copyright: Copyright © 1995-2002, The AROS Development Team
:Version:   $Revision$
:Date:      $Date$
:Status:    Unfinished; integration started (looong way left to go).
:ToDo:      Integrate the various parts. Update and revise. Complete... 

.. Warning::

   This document is not finished! It is highly likely that many parts are
   out-of-date, contain incorrect information or are simply missing 
   altogether. If you want to help rectify this, please contact us.

.. Contents::


----------------------------------
Quick guide to developing for AROS
----------------------------------

Developing for the AROS platform
================================

This chapter explains how to develop programs that will run on the AROS platform.
It also tells you how to compile them on the different machines that AROS runs on.
It assumes that you have an average knowledge of the C language and basic concepts like `linking`.

How AROS libraries work
-----------------------

The term `library` usually refers to an object whose purpose is to collect in a
single place functions that programs may want to use more often than others,
and usually such functions all serve one common purpose, so that there can be
libraries to parse configuration files, to handle localization, and other kind
of tasks which a program might want to perform.

There generally are 2 kinds of libraries: link-time libraries, and run-time
libraries. The link time libraries, as the name suggests, are used only at
program linking stage: the linker simply takes note of which functions the main
program references and tries to take them from the provided libraries. The
run-time ones, instead, are only used when the program is run, that is the
operating system, the program itself or even a link-time library, take care, at
run-time, of `resolving` the references to library functions.

Whilst link-time libraries are handled more or less the same way across all
operating systems, since they're independent from the OS itself, run-time
libraries may be handled differently by different OSs. In particular, AROS
run-time libraries are quite different than unix-style run-time libraries, and
both are different than Windows (TM) run-time libraries. Since run-time
libraries implementation and use differs among the various OS's, such libraries
also get a more `specialized` name depending on which OS they are meant to run
on and on which specific feature such name wants to enphatize. In fact,
unix-style run-time libraries are also named `shared objects`, because such
libraries preserve the semantics of link-time objects, although they're used at
run-time and shared among many programs. Windows (TM) run-time libraries are
instead named `Dynamic Link Libraries`, or DLL's, to enphatize that they're
mainly a collection of functions which a `dynamic` or runtime linker takes care
of resolving references to, and the way user programs can access such functions
differs from the way user programs can access link-time library functions.
Finally, AROS run-time libraries are simply named `shared libraries`, and
they're totally different than link-time libraries, in a way which will be
explained below.

AROS `shared` libraries are collections of functions indexed in the library by
a `function vectors table`. This table is simply an array of pointers [#]_ to
the library's functions, and user programs access these functions by knowing
their address' index in the table. Every function in the library gets passed a
parameter [#]_ which points to a zone of memory that both holds the function
vectors and the library's own data [#]_. Such memory area is named `library
base`, and libraries are free to chose, trough a particular implementation of
some of their mandatory functions, whether the library base is to be shared
among various instances of the library or if it's to be used by all of its
instances. User programs are generally not invited to access this area
directly, but rather trough the use of accessor functions, but again this is
not a mandatory policy, rather it's up to the library to decide how to do
certain things.

Libraries can of course `open` other libraries and use their funtions and data
the way described above, but since the main program is not a library, libraries
have no means to access the program's data and functions other than the program
itself telling the interested library how to do so, in a way that is
library-dependent. In contrast, unix-style run-time libraries, being at all
effects `compiler objects`, can share functions and data with both other
libraries and the main program: basically all symbols, be them functions or
data identifiers, are resolved just like if the program were linked with those
libraries at link-time, rather than at run-time.

Both approaches have their pros and cons, and it may be possible to make one
kind of library appear as the other kind provided that certain rules are
established and met by all elements involved. Currently, in AROS, when a shared
object would be needed, a special wrapper around a shared library is built -
and certain tools used by the AROS build system can do this automatically - so
that programs can transparently use the shared version of what they think are
link-time, or `static` libraries. This approach only works in part, since it
doesn't replicate all functionalities of the shared objects, but it's
sufficient in many cases.

.. [#] In reality, on certain flavours, this table may hold more than just
       function pointers. On AROS for 68k, in fact, where binary compatibility 
       with AmigaOS (TM) is an issue, every entry in the table contains a JMP
       instruction followed by the function address (which is thus part of the
       JMP opcode), and the user programs don't jump to the address in the
       vector, they jump to the vector itself, and then the JMP instruction
       redirects the program's flow to the right function.

.. [#] Such a parameter may be explicit or implicit, depending on the ABI
       chosen for a particular AROS flavour.

.. [#] If you know C++, you might think of the vectors table as the `VTable`
       used for virtual methods, and the library base pointer as the `this` 
       pointer.


The AROS "Hello, World!" program
--------------------------------

Below is an AROS program that shows a "Hello, World!" message - a programmer's 
tradition since ages. But to keep up the Amiga spirit, this message won't show 
up on the command line, but as the title of a window instead.

(LINK TO HELLOWORLD.C)

The first thing you will have to do in an AROS program, is #include the 
necessary header files. These header files contain specifications for the 
library functions and variable types. Which header you have to include for what 
function or type, is still a mystery to me (FIXME: Scooby Doo, solve this! 
What's the diff between protos/library.h and library/library_protos.h?). After 
some declarations comes the "main" function, as usual in standard C (Note: 
wbenchmain(?) is an alternative but not important here).

The first thing the program does, is opening a library - this finally proves 
the difference with Linux libraries. The library is called "intuition.library". 
Intuition is AROS' (Amiga's) Graphical User Interface (GUI). The function 
OpenLibrary will look on a few standard places for this library, and load it in. 
All Intuition functions are now available to the user, until the library is 
closed again. Now we call OpenWindow - an Intuition function. OpenWindow has a 
NewWindow structure as an argument. This structure is filled with all kind of 
information that the system needs to build the window, including the title, 
gadgets and events. You can see, for instance, that our window title will be 
"Hello, World!". After an event has occured (the strange "Wait" line), we 
close everything we opened and exit. If something goes wrong, we close 
everything we opened (but not what we haven't opened yet!) and exit too, but 
under protest this time.


Compiling on Amiga
------------------

On Amiga, AROS can handle Amiga binaries. What you need is your favorite 
compiler (DCC, GCC, SAS/C, VBCC - an Amiga is a box of choices!) and the 
neccessary header files. The original AmigaOS header files may have legal 
usage restrictions, therefore they are not easy to get online. But I have heard 
that (link: www.schatzruhe.de) sells Amiga Developer CD's that contain these 
headers and more nice info. But because of your interest in AROS, you might 
also use the AROS headers instead (FIXME: is this possible?). You'll have to 
read your compiler documentation if you don't know where to place your includes, 
or how to compile a program. Once you compiled successfully, run your newly-born 
executable as any other Amiga program.


Compiling on Linux with GCC
---------------------------

(Note: this includes linux-m68k and BSD(?).) Once your executable is there, 
place it somewhere where you can see it from within AROS. Start AROS, and 
invoke your executable from the command line.


Compiling for native-i386
-------------------------

This is quite a complex precedure and more details will be added later, for now
just down load the binary from `AhSoDiT Productions` and enjoy the hard work 
which has gone into making it happen.

.. _`AhSoDiT Productions`: http://www.ahsodit.com/aros/


Writing somewhat more useful programs
-------------------------------------

"Hello, World!" is not a Museum of Programmer's Talent, so you might wonder if 
there is more to AROS than that. Why dear, of course there is. But this User's 
Guide is not a Programmer's Guide nor a Programmer's Reference Guide. Such 
guides might be written in the future, but for now, the best AROS Programmer's 
Guides you can find are the books that have been written for the Amiga, and 
the best reference for AROS are the AROS autodocs (autodocs are descriptions of 
AROS library functions that are created by parsing the AROS sources). The 
autodocs are available from the `home page`.
But they are mainly useful to advanced Amiga programmers: they only provide a 
very short explanation for each function. If you have to learn AROS programming 
from the beginning, you really should try to find that old Amiga book, or else 
mail-bomb me until I'll write some Guide.

--------------------------------------------------
Developing Software for AROS (aka "Quick Start II"
--------------------------------------------------

AROS extensions
===============

AROS makes a few extensions to the original AmigaOS. Some of them are
transparent and compatible, others are only compatible and some or not.

Macros
------

AROS defines a couple of macros in various header files. All macros
cast their parameters to the correct type, so you must provide a
valid input but can safe the casts (macros are meant to make life
more simple).

``NEWLIST(list)``
    :Compatible: Yes
    :Location:   exec/lists.h

    Initializes a list. You must not use any list before you have 
    initialized it.

``GetHead(list)``
    :Compatible: Yes
    :Location:   exec/lists.h

    Returns a pointer to the first node of a list or ``NULL`` if the list
    is empty.

``GetTail(list)``
    :Compatible: Yes
    :Location:   exec/lists.h

    Returns a pointer to the last node of a list or ``NULL`` if the list
    is empty.

``GetSucc(node)``
    :Compatible: Yes
    :Location:   exec/lists.h

    Returns a pointer to the next node of a list or ``NULL`` if there is none.

``GetPred(list)``
    :Compatible: Yes
    :Location:   exec/lists.h

    Returns a pointer to the previous node of a list or ``NULL`` if there is none.

``ForeachNode(list,node)``
    :Compatible: Yes
    :Location:   exec/lists.h

    Iterates through a list. A block of code must follow this macro. The
    block doesn't get executed if the list is empty. When the list terminates
    `node` doesn't contain ``NULL`` but ``node->ln_Succ`` will be ``NULL``. You
    cannot use this macro if you want to delete the nodes in the list (ie.
    you must not call `Remove()` inside the block of code following the
    macro). Use `ForeachNodeSafe()` if you have to delete nodes.

    Example::

        /* Iterate through a list with complete nodes and print their names */
        t = 1;
        ForeachNode(list,node)
        {
            if (node->ln_Name)
            {
                printf ("Node %d: %s\n", t++, node->ln_Name);

                if (!strcmp (node->ln_Name, "end"))
                    break;
            }
        }

        if (node->ln_Succ)
            printf ("Not all nodes have been processed\n");
        else
            printf ("The list doesn't contain a node with the name \"end\"\n");

``ForeachNodeSafe(list,node,tmpNode)``
    :Compatible: Yes
    :Location:   exec/lists.h

    Iterates through a list. A block of code must follow this macro. The
    block doesn't get executed if the list is empty. When the list terminates
    `node` doesn't contain ``NULL`` but ``node->ln_Succ`` will be ``NULL``. You
    can use this macro with code that deletes nodes in the list.

``SetNodeName(node,name)``
    :Compatible: Yes
    :Location:   exec/lists.h

    Sets a new name for a node. The name is not copied, the macro will just
    make `ln_Name` point to ``name``.
    The macro casts `node` to ``struct Node *``
    so you better make sure that `node` is a full featured node.

``GetNodeName(node)``
    :Compatible: Yes
    :Location:   exec/lists.h

    Return the current name of a node.
    The macro casts `node` to ``struct Node *``
    so you better make sure that `node` is a full featured node.

``ListLength(list,count)``
    :Compatible: Yes
    :Location:   exec/lists.h

    This puts the number of nodes in `list` into `count`.

``INTUITIONNAME``
    :Compatible: Yes
    :Location:   intuition/intuition.h

    Contains the name of the Intuition library. You should use this in
    `OpenLibrary()`, for example, to avoid typos.


Resource Tracking (RT)
----------------------

Everyone talks about RT but what's it anyway? RT means three things:

1. The OS takes notes about allocated resources (eg. memory, windows,
   libraries, devices, screens, etc).

2. The OS checks the usage of those resources (ie. Did you open
   that window you want to render into? Is it still open? Is that a
   window anyway?)

3. The OS closes resources if they are no longer used (either because your
   program crashed or because it exited without freeing them).

The current implementation can do all three things but to enable it,
you must make some modifications to your code. The only disadvantage of
the current implementation is that the resources won't be freed if the
program crashes.

1. Add the following lines to your code. It should be the first thing 
   seen by the compiler::
   
       #define ENABLE_RT  1

   If you replace the 1 by 0, then RT will be silently disabled.

2. Add ``#include <aros/rt.h>`` after the last include from ``proto/``

3. Add ``RT_Init();`` as the first command in ``main()``.

4. Call ``RT_Exit()`` before you terminate your program.

5. Recompile.

The advantages are that you will get errors if you try to access
resources which you didn't allocate and that you will get a list
of resources which you didn't free at the end of your program.
All messages will contain the position in the code where the error
happened (if available) and the position in the code where the
resource was allocated (this is the reason why RT has to be compiled
in. It could be built into the OS, too, but it would be hard
to gather the information where an error occurred).

A good example about how to use RT and what it can do can be
found in ``AROS/workbench/demos/rtdemo.c``.

The following resources are tracked:

+ Memory in AllocMem()``, ``FreeMem()``,``AllocVec()`` and ``FreeVec()``

+ MsgPorts in ``CreateMsgPort()``, ``DeleteMsgPort()``, ``CreatePort()``,
  ``DeletePort()`` and ``PutMsg()``

+ Files in ``Open()``, ``Close()``, ``Read()`` and ``Write()``. ``Read()`` and
  ``Write()`` also check their buffers.

+ Windows in ``OpenWindow()``, ``OpenWindowTags()``, ``OpenWindowTagList()``,
  ``CloseWindow()``, ``WindowToFront()``, ``WindowToBack()``

+ Screens in ``OpenScreen()``, ``OpenScreenTags()``, ``OpenScreenTagList()``,
  ``CloseScreen()``, ``ScreenToFront()``, ``ScreenToBack()``. ``CloseScreen()`` also
  checks for open windows on the screen before closing.


---------------------
The AROS build system
---------------------

Development tools used by AROS
==============================

AROS uses several development tools in it's building system. A short list of
the most important ones is:

+ GNU make: the GNU version of the make program. It is assumed that the AROS
  programmers are familiar with this program. Also the GNU specific extension
  are used heavily throughout the source code. The GNU info pages about the
  make program are a good way to look at the sources.
+ MetaMake: A make supervisor program. It can keep track of targets
  available in makefiles available in subdirectories a certain root directory.
  A more in depth explanation is given below.
+ genmf: (generate makefile) A macro language for makefiles. It allows to 
  combine several make rules into one macro which can simplify writing
  makefiles
+ Several AROS specific tools that will be explained more when appropriate
  during the rest of this documentation.


MetaMake
--------

Introduction
""""""""""""

MetaMake is a version of make which allows to recursively build targets in the
various directories of a project or even another project. It searches
a directory tree for makefiles and all makefiles it finds for "metatargets" and
then tries to build all metatargets. You can also specify a program which
converts "source" makefiles into makefiles before MetaMake will invoke make.

Syntax of the makefile
""""""""""""""""""""""

MetaMake uses normal makefile syntax but gives a special meaning to a
comment line that start with #MM. This line is used to define so called
metatargets. The name of the makefile itself is defined in the MetaMake
config file that is discussed in one of the following sections.

There exist three ways of defining a metatarget in a makefile:

+ This defines a metatarget with it's metaprerquisites::

      #MM metatarget : metaprerequisites

  When a user asks to build this metatarget first the metaprerequisites will 
  be build as metatargets and afterwards the given metatarget.
  
  This form also indicates that in this makefile also a makefile target is
  present with the same.
  
+ This is the same definition as in the previous paragraph only now no
  normal make target is present in the makefile with the same name as the
  metatarget::
  
      #MM- metatarget : metaprerequisites
  
+ This form indicates the the make target on the next line is also a
  metatarget but the prerequisites are no metaprerequisites::
  
      #MM
      metatarget : prerequisites

The line for the definition of a metatarget can be spread over several lines
if one end every line with the \ character and start the next line with 
``#MM.``

How MetaMake works
""""""""""""""""""

When MetaMake is run a metamake target to build is specified on the command
line.

In a first MetaMake will build up a tree of all the makefiles present in
a root directory and all subdirectories. At the same time it will also build
a tree of all the metatargets and their dependencies.

Next it will build all the metaprerequisites needed for this metatarget and
then finally the metatarget itself. Actually one can look at it that every
metaprerequisite becomes a metatarget when it needs to be build. For each of
these metatarget a walk through of all the directories is done and in every
makefile where the metatarget is defined by the first or third way from the
previous section make is called with the name of the target as a make
target.

When MetaMake calls normal make also two variables are defined. $(TOP) has
the value of the rootdirectory and $(CURDIR) the path relative to this root
directory.

Autogenerated makefiles
"""""""""""""""""""""""

Another feature of MetaMake is automatic generating a makefile from a source
makefile. When the directory tree is scanned for all the makefiles in every
directory it is checked if a makefile is present with a .src suffix added.
If it is there and is newer then the makefile present in that directory a
script will be called to regenerate the makefile from the source makefile.
What script that has to be called is defined in the configuration file.

Examples
""""""""

The next few examples are taken from the AROS project.

Example 1: normal dependencies
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

::

    #MM contrib-regina-module : setup linklibs includes contrib-regina-includes

This example says that in this makefile a contrib-regina-module is present
that has to be build but the before building this metatarget first the
metatargets setup, linklibs, ... has to be build; e.g. that the includes
linklibs etc have to be present before that this module can be build.

Example 2: metatarget consisting of submetatargets
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

::

   #MM- contrib-freetype : contrib-freetype-linklib \
   #MM      contrib-freetype-graph \
   #MM      contrib-freetype-fonts \
   #MM      contrib-freetype-demos

Here actually is said that the contrib-freetype metatarget consists of
building linklib, graph, fonts and demos of freetype. If some extra work
needs to be done in the makefile where this metatarget the definition can
start with '#MM ' and a normal make target 'contrib-freetype' has to be
present in the makefile.

Also the use of the line continuation for the metatarget definition is shown
here.

Example 3: Quick building of a target
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

::

    #MM workbench-utilities : includes linklibs setup-clock-catalogs
    #MM
    workbench-utilities-quick : workbench-utilities

When a user executes MetaMake with as argument workbench-utilities make will
be called in all the directories where the metaprerequisites are present in
the makefile. This can become quite annoying when debugging programs. When
now the second metatarget workbench-utilities-quick is defined as shown
above only that target will be build in this directory. Of course the user
has then to be sure that the metatargets on which workbench-utilities depend
are up-to-date.


Usage and configuration files
"""""""""""""""""""""""""""""

``Usage: mmake [options] [metatargets]``

To build mmake, just compile ``mmake.c``. It doesn't need any other files.

mmake looks for a config file ``mmake.config`` or ``.mmake.config`` in the 
current directory for a file in the environment variable ``$MMAKE_CONFIG`` 
or a file ``.mmake.config`` in the directory ``$HOME``.

This file can contain the following things:

    ``#``
        This must be the first character in a line and begins a comment.
        Comments are completely ignored my mmake (as are empty lines).
    
    ``text="[<name>]"``
        This begins a config section for the project ``name``.
        You can build targets for this project by saying ``name.target``.
    
    ``maketool <tool options...>``
        Specifies the name of the tool to build a target. The
        default is ``make "TOP=$(TOP)" "CURDIR=$(CURDIR)"``.
    
    ``top <dir>`` 
        Specifies the root directory for a project. You
        will later find this config option in the variable ``$(TOP)``.
        The default is the current directory.
    
    ``defaultmakefilename <filename>``
        Specifies the basename for
        makefiles in your project. Basename means that mmake will consider
        other files which have this stem and an extension, too. See the
        items to generate makefiles for details. The default
        is ``Makefile``.
    
    ``defaulttarget <target>`` 
        The name of the default target which
        mmake will try to make if you call it with the name of the
        project alone. The default is ``all``.
    
    ``genmakefilescript <cmdline...>`` 
        mmake will check for files
        with the basename as specified in ``defaultmakefilename``
        with the extension ``.src``. If such a file is found, the
        following conditions are checked: Whether this file is newer
        than the makefile, whether the makefile doesn't exist and
        whether the file ``genmakefiledeps`` is newer than the
        makefile. If any of these is true, mmake will call this script
        the the name of the source file as an extra option and the
        stdout of this script will be redirected to ``defaultmakefilename``.
        If this is missing, mmake will not try to regenerate makefiles.
    
    ``genmakefiledeps <path>``
        This is the name of a file which is
        considered when mmake tries to decide whether a makefile must
        be regenerated. Currently, only one such file can be specified.
    
    ``globalvarfile <path>``
        This is a file which contains more
        variables in the normal make(1) syntax. mmake doesn't
        know about any special things like line continuation, so
        be careful not to use such variables later (but they
        don't do any harm if they exist in the file. You should
        just not use them anywhere in mmake).
        
    ``add <path>`` 
        Adds a nonstandard makefile to the list of
        makefiles for this project. mmake will apply the standard
        rules to it as if the ``defaultmakefilename`` was
        like this filename.
        
    ``ignoredir <path>``
        Will tell mmake to ignore directories
        with this name. Try ``ignore CVS`` if you use CVS to
        manage your projects' sources.

Any option which is not recognised will be added to the list of known 
variables (ie. ``foo bar`` will create a variable ``$(foo)`` which is 
expanded to ``bar``).


Example
^^^^^^^

Here is an example::

    # This is a comment
    # Options before the first [name] are defaults. Use them for global
    # defaults
    defaultoption value
    
    # Special options for the project name. You can build targets for this
    # project with "mmake name.target"
    [AROS]
    
    # The root dir of the project. This can be accessed as $(TOP) in every
    # makefile or when you have to specify a path in mmake. The default is
    # the current directory
    top /home/digulla/AROS
    
    # This is the default name for Makefiles. The default is "Makefile"
    defaultmakefilename makefile
    
    # If you just say "mmake AROS", then mmake will go for this target
    defaulttarget AROS
    
    # mmake allows to generate makefiles with a script. The makefile
    # will be regenerated if it doesn't exist, if the source file is
    # newer or if the file specified with genmakefiledeps is newer.
    # The name of the source file is generated by concatenating
    # defaultmakefilename and ".src"
    genmakefilescript gawk -f $(TOP)/scripts/genmf.gawk --assign "TOP=$(TOP)"
    
    # If this file is newer than the makefile, the script
    # genmakefilescript will be executed.
    genmakefiledeps $(TOP)/scripts/genmf.gawk
    
    # mmake will read this file and every variable in this file will
    # be available everywhere where you can use a variable.
    globalvarfile $(TOP)/config/host.cfg
    
    # Some makefiles must have a different name than
    # defaultmakefilename. You can add them manually here.
    #add compiler/include/makefile
    #add makefile

A metatarget look like so: ``project.target``. Example:
``AROS.setup``. If nothing is specified, mmake will make the default
target of the first project in the config file. If the project is specified
but no target, mmake will make the default target of this project.


Genmf
-----

Introduction
""""""""""""

Genmf uses two files for generating a makefile. First is the macro
definition file and finally the source makefile where these macro's can be
used.

Syntax
""""""

In general the ``%`` character is used as the special character for genmf
source makefiles.


Macro definition
^^^^^^^^^^^^^^^^

A macro definition has the following syntax::

    %define macroname option1[=[default][\A][\M]] option2[=[default][\A][\M]] ...
    ...
    %end

macroname is the name of the macro. option1, option2, ... are the arguments
for the macro. These options can be used in the body of this template by
typing %(option1). This will be replaced be the value of option1.

The macro can be followed by a default value. If no default value is
specified an empty string is taken. Normally no space are allowed in the
default value of an argument. If this is needed this can be done by
surrounding the value with double quotes (``"``).

Also two switches can be given:
    
    ``\A``
        Is the switch to always need a value for this. When the macro is
        instantiated always a value need to be assigned to this argument.
    
    ``\M``
        Is the switch to turn on multi words. This means that all the words
        following this argument will be assigned to this argument. This also
        means that after the use of such an argument no other argument can be
        present because it will become part of this argument.

  
Macro instantiation
^^^^^^^^^^^^^^^^^^^

The instantiation of the macro is done by using the '%' character followed
by the name of the macro to instantiate (without a round brackets around it)::

    %macro_name [option1=]value [option2=]value

Two ways are possible to specify value for arguments to a macro:

    ``value`` 
        This will assign the value to the argument defined as the first 
        argument to this macro. The time this format is used it will be 
        assigned to the second argument and so on.
    
    ``option1=value``
        This will assign the given value to the option with the specified 
        name.

When giving values to arguments also double quotes need to be used if one
wants to include spaces in the values of the arguments.

Macro instantiation may be used inside the body of a macro, even macro's
that will only be defined later on in the macro definition file.

Examples
""""""""

FIXME (whole rules to be shown as well as action to be used in make rules)


AROS usage and configuration of the build tool
==============================================

AROS metamake configuration file
--------------------------------

FIXME

AROS standard metamake targets
------------------------------

FIXME

High level mmakefile.src macro's
--------------------------------

FIXME: Other high level macro's ?

.. Note:: In the definition of the genmf rules sometimes mmake variables are
   	  used as default variables for an argument (e.g. ``dflags=%(cflags)``).
	  This is not really possible in the definition file but is done by
	  using text that has the same effect.

Building programs
"""""""""""""""""

There are two macro's for building programs. One macro ``%build_progs``
that will compile every input file to a separate executable and one macro
``%build_prog`` that will compile and link all the input files into one
executable.

%build_progs
^^^^^^^^^^^^

This macro will compile and link every input file to a separate executable
and has the following definition::

    %define build_progs mmake=/A files=/A \
        objdir=$(GENDIR)/$(CURDIR) targetdir=$(AROSDIR)/$(CURDIR) \
    	cflags=$(CFLAGS) dflags=$(BD_CFLAGS$(BDID)) ldflags=$(LDFLAGS) \
    	uselibs= usehostlibs= usestartup=yes detach=no

With the following arguments:

    ``mmake=/A``
        This is the name of the metatarget that will build the programs.
    
    ``files=/A``
        The basenames of the C source files that will be compiled and linked
	to executables. For every name present in this list an executable
	with the same name will be generated.
    
    ``objdir=$(GENDIR)/$(CURDIR)``
        The directory where the compiled object files will be put.
    
    ``targetdir=$(AROSDIR)/$(CURDIR)``
        The directory where the executables will be placed.
    
    ``cflags=$(CFLAGS)``
        The flags to add when compiling the .c files. By default the standard
        AROS cflags (the ``$(CFLAGS)`` make variables are taken. This also 
        means that some flags can be added by assigning these to the 
        USER_CFLAGS and USER_INCLUDES make variables before using this macro.
    
    ``dflags=%(cflags)``
        The flags to add when doing the dependency check. Default is the same 
        as the ``cflags``.
    
    ``ldflags=$(LDFLAGS)``
        The flags to use when linking the executables. By default the
	standard AROS link flags will be used.
    
    ``uselibs=``
        A list of static libraries to add when linking the executables. This is the
        name of the library without the lib prefix or the .a suffix and
	without the -l prefix for the use in the flags for the C compiler.
        
        By default no libraries are used when linking the executables.

    ``usehostlibs=``
        A list of static libraries of the host to add when linking the
	executables. This is the name of the library without the lib prefix or the
	.a suffix and without the -l prefix for the use in the flags for the C
	compiler.
        
        By default no libraries are used when linking the executables.

    ``usestartup=yes``
        Use the standard startup code for the executables. By default this
	is yes and this is also what one wants most of the time. Only disable
	this if you know what you are doing.
	
    ``detach=no``
        Wether the executables will run detached. Defaults to no.

%build_prog
^^^^^^^^^^^

This macro will compile and link the input files to an executable
and has the following definition::

    %define build_prog mmake=/A progname=/A files=%(progname) asmfiles= \
        objdir=$(GENDIR)/$(CURDIR) targetdir=$(AROSDIR)/$(CURDIR) \
        cflags=$(CFLAGS) dflags=$(BD_CFLAGS$(BDID)) ldflags=$(LDFLAGS) \
        aflags=$(AFLAFS) uselibs= usehostlibs= usestartup=yes detach=no

With the following arguments:

    ``mmake=/A``
        This is the name of the metatarget that will build the program.
    
    ``progname=/A``
        The name of the executable.
    
    ``files=``
        The basenames of the C source files that will be compiled and linked
	into the executable. By default just the name of the executable is taken.
    
    ``asmfiles=``
        The assembler files to assemble and include in the executable. By
	default no asm files are included in the executable.
    
    ``objdir=$(GENDIR)/$(CURDIR)``
        The directory where the compiled object files will be put.
    
    ``targetdir=$(AROSDIR)/$(CURDIR)``
        The directory where the executables will be placed.
    
    ``cflags=$(CFLAGS)``
        The flags to add when compiling the .c files. By default the standard
        AROS cflags (the ``$(CFLAGS)`` make variable) are taken. This also 
        means that some flags can be added by assigning these to the 
        USER_CFLAGS and USER_INCLUDES make variables before using this macro.
    
    ``dflags=%(cflags)``
        The flags to add when doing the dependency check. Default is the same 
        as the ``cflags``.
    
    ``aflags=$(AFLAGS)``
        The flags to add when compiling the asm files. By default the standard
        AROS aflags (e.g. ``$(AFLAGS)``) are taken. This also 
        means that some flags can be added by assigning these to the 
        SPECIAL_AFLAGS make variable before using this macro.
    
    ``ldflags=$(LDFLAGS)``
        The flags to use when linking the executable. By default the
	standard AROS link flags will be used.
    
    ``uselibs=``
        A list of static libraries to add when linking the executable. This is the
        name of the library without the lib prefix or the .a suffix and
	without the -l prefix for the use in the flags for the C compiler.
        
        By default no libraries are used when linking the executable.

    ``usehostlibs=``
        A list of static libraries of the host to add when linking the
	executable. This is the name of the library without the lib prefix or the
	.a suffix and without the -l prefix for the use in the flags for the C compiler.
        
        By default no libraries are used when linking the executable.

    ``usestartup=yes``
        Use the standard startup code for the executables. By default this
	is yes and this is also what one wants most of the time. Only disable
	this if you know what you are doing.
	
    ``detach=no``
        Wether the executable will run detached. Defaults to no.

Building static linklibraries
"""""""""""""""""""""""""""""

Building link libraries is straight forward. A list of files will be
compiled or assembled and collected in a link library into a specified 
target directory.

The definition of the macro is as follows::

    %define build_linklib mmake=/A libname=/A files="$(basename $(wildcard *.c)) \
      asmfiles= cflags=$(CFLAGS) dflags=%(cflags) aflags=$(AFLAGS) \
      objdir=$(OBJDIR) libdir=$(LIBDIR)

With the meaning of the arguments as follows:

    ``mmake=/A``
        This is the name of the metatarget that will build the linklib.
    
    ``libname=/A``
        The base name of the library to generate. The file that will be
	generated will be called lib%(libname).a
    
    ``files=$(basename $(wildcard *.c))``
    	The C files to compile and include in the library. By default all
	the files ending in .c in the source directory will be used.
    
    ``asmfiles=``
        The assembler files to assemble and include in the library. By
	default no asm files are included in the library.
    
    ``cflags=$(CFLAGS)``
        The flags to use when compiling the .c files. By default the standard
        AROS cflags (e.g. ``$(CFLAGS)``) are taken. This also 
        means that some flags can be added by assigning these to the 
        USER_CFLAGS and USER_INCLUDES make variables before using this macro.
    
    ``dflags=%(cflags)``
        The flags to add when doing the dependency check. Default is the same 
        as the ``cflags``.

    ``aflags=$(AFLAGS)``
        The flags to add when compiling the asm files. By default the standard
        AROS aflags (e.g. ``$(AFLAGS)``) are taken. This also 
        means that some flags can be added by assigning these to the 
        SPECIAL_AFLAGS make variable before using this macro.
    
    ``objdir=$(OBJDIR)``
        The directory where to generate all the intermediate files. The 
        default value is ``$(OBJDIR)`` which in itself is by default equal to
        ``$(GENDIR)/$(CURDIR)``.
    
    ``libdir=$(LIBDIR)``
        The directory to put the library in. By default the standard lib
	directory ``$(LIBDIR)`` will be used.

Building modules
""""""""""""""""

Building modules consists of two parts. First is a macro to use in
mmakefile.src files. Another is a configuration file that describes the
contents of the module.

The mmakefile.src macro
^^^^^^^^^^^^^^^^^^^^^^^

This is the definition header of the build_module macro::

    %define build_module mmake=/A modname=/A modtype=/A            \
      conffile=%(modname).conf files="$(basename $(wildcard *.c))" \
      cflags=$(CFLAGS) dflags=%(cflags) objdir=$(OBJDIR)           \
      linklibname=%(modname) uselibs=

Here is a list of the arguments for this macro:

    ``mmake=/A``
        This is the name of the metatarget that will build the module. Also a
	``%(mmake)-quick`` and ``%(mmake)-clean`` metatarget will be defined.
        
    ``modname=/A``
        This is the name of the module without the suffix.
        
    ``modtype=/A``
        This is the type of the module and corresponds with the suffix of the
        module. At the moment only library, mcc, mui and mcp are supported.
	Support for other modules is planned in the future.
        
    ``conffile=%(modname).conf``
        The name of the configuration file. Default is modname.conf.
    
    ``files="$(basename $(wildcard *.c))"``
        A list of all the C source files without the .c suffix that contain the 
        code for this module. By default all the .c files in the current 
        directory will be taken.
        
    ``cflags=$(CFLAGS)``
        The flags to use when compiling the .c files. By default the standard
        AROS cflags (e.g. ``$(CFLAGS)``) are taken. This also 
        means that some flags can be added by assigning these to the 
        USER_CFLAGS and USER_INCLUDES make variables before using this macro.
    
    ``dflags=%(cflags)``
        The flags to add when doing the dependency check. Default is the same 
        as the ``cflags``.
    
    ``objdir=$(OBJDIR)``
        The directory where to generate all the intermediate files. The 
        default value is ``$(OBJDIR)`` which in itself is by default equal to
        ``$(GENDIR)/$(CURDIR)``.
    
    ``linklibname=%(modname)``
        The name to be used for the static link library that contains the
        library autoinit code and the stubs converting C stack calling
        convention to a call off the function from the library functable with
        the appropriate calling mechanism. These stubs are normally not needed
        when the AROS defines for module functions are not disabled.
        
        There will always be a file generated with the name
        ``$(LIBDIR)/lib%(linklibname).a`` and by default linklibname will be 
        the same as modname.
        
    ``uselibs=``
        A list of static libraries to add when linking the module. This is the
        name of the library without the lib prefix or the .a suffix and
	without the -l prefix for the use in the flags for the C compiler.
        
        By default no libraries are used when linking the module.


The module configuration file
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The module configuration file is subdived in several sections. A section is
defined with the following lines::

    ## begin sectionname
    ...
    ## end sectionname
    
The interpretation of the lines between the ``##begin`` and ``##end`` 
statement is different for every section. The following sections are defined:

+ ``config``

  The lines in this section have all the same format::
  
      optionname string
  
  with the string starting from the first non white space after optionname
  to the last non white space character on that line.
  
  A list of all the options available:
  
  ``basename``
      Followed by the base name for this module. This will be used as a
      prefix for a lot of symbols. By default the modname specified in the
      makefile is taken with the first letter capitalized.
      
  ``libbase``
      The name of the variable to the library base in. By default the
      basename will be taken with Base added to the end.
  
  ``libbasetype``
      The type to use for the libbase for use internally for the library code.
      E.g. the sizeof operator applied to this type has to yield the real
      size of the object. Be aware that it may not be specified as a pointer.
      By default 'struct LibHeader' is taken.
  
  ``libbasetypeextern``
      The type to use for the libbase for code using the library externally.
      By default 'struct Library' is taken.
      
  ``version``
      The version to compile into the module. This has to be specified as
      major.minor. By default 0.0 will be used.
  
  ``date``
      The date that this library was made. This has to have the format of
      DD.MM.YYYY. As a default 00.00.0000 is taken.
  
  ``libcall``
      The argument passing mechanism used for the functions in this module.
      It can be either 'stack' or 'register'. By default 'stack' will be used.
  
  ``forcebase``
      This will force the use of a certain base variable in the static
      link library for auto opening the module. Thus it is only valid for
      module that support auto opening. This option can be present more then
      once in the config section and then all these base will be in the link
      library. By default no base variable will be present in the link
      library.

+ ``cdef``

  In this section all the C code has to be written that will declare all the
  type of the arguments of the function listed in the function. All valid C
  code is possible including the use of #include.
  
+ ``functionlist``

  In this section all the functions externally accessible by programs.
  
  For stack based argument passing only a list of the functions has to be
  given. For register based argument passing the names of the register have
  to be given between rounded brackets. If you have function foo with the
  first argument in D0 and the second argument in A0 it gives the following
  line in in the list::

      foo(D0,A0)


Building modules (the legacy way)
"""""""""""""""""""""""""""""""""

Before the %build_module macro was developed already a lot of code was
written. There a mixture of macro's was usedin the mmakefile and they were
quite complicated. To clean up these mmakefiles without needing to rewrite
too much of the code itself a second genmf macro was created to build
modules that were written using the older methodology. This macro is called
build_module_macro. For writing new modules people should consider this
macro as depricated and only use this macro when the %build_module doesn't
support the module yet they want to create.

The mmakefile.src macro
^^^^^^^^^^^^^^^^^^^^^^^

This is the definition header of the build_module_macro macro::

    %define build_module_macro mmake=/A modname=/A modtype=/A \
      conffile=%(modname).conf initfile=%(modname)_init \
      funcs= files= linklibfiles= cflags=$(CFLAGS) dflags=%(cflags) \
      objdir=$(OBJDIR) linklibname=%(modname) uselibs= usehostlibs= \
      genfunctable= genincludes= compiler=target

Here is a list of the arguments for this macro:

    ``mmake=/A``
        This is the name of the metatarget that will build the module. It will
        define that metatarget but won't include any metaprerequisites. If you
        need these you can add by yourself with an extra 
        ``#MM metatargets : ...`` line. Also a ``%(mmake)-quick`` and 
        ``%(mmake)-clean`` metatarget will be defined.
        
    ``modname=/A``
        This is the name of the module without the suffix.
        
    ``modtype=/A``
        This is the type of the module and corresponds with the suffix of the
        module. It can be one of the following : library gadget datatype
	handler device resource mui mcc hidd.
        
    ``conffile=%(modname).conf``
        The name of the configuration file. Default is modname.conf.
    
    ``funcs=``
        A list of all the source files with the .c suffix that contain the
        code for the function of a module. Only one function per C file is
	allowed and the function has to be defined using the AROS_LHA
	macro's.
        
    ``files=``
        A list of all the extra files with the .c suffix that contain the 
        extra code for this module.

    ``initfile=%(modname)_init``
        The file with the init code of the module.
	
    ``cflags=$(CFLAGS)``
        The flags to add when compiling the .c files. By default the standard
        AROS cflags (the ``$(CFLAGS)`` make variables are taken. This also 
        means that some flags can be added by assigning these to the 
        USER_CFLAGS and USER_INCLUDES make variables before using this macro.
    
    ``dflags=%(cflags)``
        The flags to add when doing the dependency check. Default is the same 
        as the ``cflags``.
    
    ``objdir=$(OBJDIR)``
        The directory where to generate all the intermediate files. The 
        default value is ``$(OBJDIR)`` which in itself is by default equal to
        ``$(GENDIR)/$(CURDIR)``.
    
    ``linklibname=%(modname)``
        The name to be used for the static link library that contains the
        library autoinit code and the stubs converting C stack calling
        convention to a call off the function from the library functable with
        the appropriate calling mechanism. These stubs are normally not needed
        when the AROS defines for module function are not disabled.
        
        There will always be a file generated with the name
        ``$(LIBDIR)/lib%(linklibname).a`` and by default linklibname will be 
        the same as modname.
        
    ``uselibs=``
        A list of static libraries to add when linking the module. This is the
        name of the library without the lib prefix or the .a suffix and
	without the -l prefix for the use in the flags for the C compiler.
        
        By default no libraries are used when linking the module.

    ``usehostlibs=``
        A list of static libraries of the host to add when linking the module. This
	is the name of the library without the lib prefix or the .a suffix
	and without the -l  prefix for the use in the flags for the C compiler.
        
        By default no libraries are used when linking the module.

    ``genfunctable=``
        Bool that has to have a value of yes or no or left empty. This
        indicates if the functable needs to be generated. If empty the
        functable will only be generated when funcs is not empty.

    ``genincludes=``
        Bool that has to have a value of yes or no or left empty. This
        indicates if the includes needs to be generated. If empty the
        includes will only be generated for a library, a gadget or a device.

    ``compiler=target``
        Indicates which compiler to use during compilation. Can be either
        target or host to use the target compiler or the host compiler.
	By default the target compiler is used.


The module configuration file
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For the build_module_macro two files are used. First is the module
configuration file (modname.conf or lib.conf) and second is the headers.tmpl
file.

+ The modules config file is file with a number of lines with the following
  syntax:

    ``name <string>``
        Init the various fields with reasonable defaults. If <string> is XXX, then
    	this is the result::

            libname         xxx
            basename        Xxx
            libbase         XxxBase
            libbasetype     XxxBase
            libbasetypeptr  XxxBase *

        Variables will only be changed if they have not yet been specified.
    
    ``libname <string>``
        Set libname to <string>. This is the name of the library (ie. you can
        open it with <string>.library). It will show up in the version string, too.

    ``basename <string>``
        Set basename to <string>. The basename is used in the AROS-LHx macros in the
    	location part (last parameter) and to specify defaults for libbase and
    	libbasetype in case they have no value yet. If <string> is xXx, then
    	libbase will become xXxBase and libbasetype will become	xXxBase.

    ``libbase <string>``
        Defines the name of the library base (ie. SysBase, DOSBase, IconBase, etc).
    	If libbasetype is not set, then it is set to <string>, too.

    ``libbasetype <string>``
        The type of libbase (with struct), ie. struct ExecBase, struct DosLibrary,
    	struct IconBase, etc).

    ``libbasetypeptr <string>``
        Type of a pointer to the libbase. (eg. ``struct ExecBase *``).

    ``version <version>.<revision>``
        Specifies the version and revision of the library. 41.0103 means version 41
        and revision 103.

    ``copyright <string>``
        Copyright string.

    ``define <string>``
        The define to use to protect the resulting file	against double inclusion
        (ie. #ifndef <string>...). The default is _LIBDEFS_H.

    ``type <string>``
        What kind of library is this ? Valid values for <string> are: device, library,
    	resource and hidd.

    ``option <string>...``
        Specify an option. Valid values for <string> are:

	+ ``noexpunge``

	  Once the lib/dev is loaded, it can't be removed from memory.
          Be careful with this option.

    	+ ``rom``

	  For ROM based libraries. Implies noexpunge and unique.

	+ ``unique``

	  Generate unique names for all external symbols.

        + ``nolibheader``

	  We don't want to use the LibHeader prefixed functions in the
          function table.

        + ``hasrt``

	  This library has resource tracking.

        You can specify more than one option in a config file and
    	more than one option per option line. Separate options by
    	space.

The header.tmpl file
^^^^^^^^^^^^^^^^^^^^

Contrary to the %build_module macro for %build_module_macro the C header
information is not included in the configuration file but an additional
files is used with the name headers.tmpl. This file has different section
where each of the sections will be copied in a certain include file that is
generated when the module is build. A section has a structure as follows::

    ##begin sectionname
    ...
    ##end sectionname
    
With sectionname one of the following choices:

+ defines
+ clib
+ proto


Compiling arch and/or CPU specific files
""""""""""""""""""""""""""""""""""""""""

In the previous paragraph the method was explained how a module can be build
with the AROS genmf macro's. Sometimes one wants to replace certain files in
a module with an implementation only valid for a certain arch or a certain
CPU.

The macro definition
^^^^^^^^^^^^^^^^^^^^

Arch specific files are handled by the macro called %build_archspecific and it
has the following header::

    %define build_archspecific mainmmake=/A maindir=/A arch=/A files= asmfiles= \
    cflags=$(CFLAGS) dflags=%(cflags) aflags=$(AFLAGS) compiler=target

And the explanation of the argument to this macro:

    ``mainmmake=/A``
        The mmake of the module from which one wants to replace files or to
	wich to add additional files.
	
    ``maindir=/A``
        The directory where the object files of the main module are stored.
	The is only the path relative to $(GENDIR). Most of the time this is the
	directory where the source files of the module are stored.
        
    ``arch=/A``
        The architecture for which these files needs to be build. It can
	have three different forms ARCH-CPU, ARCH or CPU. For example when
	linux-i386 is specified these files will only be build for the linux
	port on i386. With ppc it will be build for all ppc processors and
	with linux it will be build for all linux ports.
	
    ``files=``
        The basenames of the C source files to replace add to the module.
	
    ``asmfiles=``
        The basenames of the asm source files to replace or add to the module.
        
    ``cflags=$(CFLAGS)``
        The flags to add when compiling the .c files. By default the standard
        AROS cflags (the ``$(CFLAGS)`` make variables are taken. This also 
        means that some flags can be added by assigning these to the 
        USER_CFLAGS and USER_INCLUDES make variables before using this macro.
    
    ``dflags=%(cflags)``
        The flags to add when doing the dependency check. Default is the same 
        as the ``cflags``.
    
    ``aflags=$(AFLAGS)``
        The flags to add when assembling the asm files. By default the standard
        AROS cflags (the ``$(AFLAGS)`` make variable) are taken. This also 
        means that some flags can be added by assigning these to the 
        SPECIAL_AFLAGS make variable before using this macro.
    
    ``compiler=target``
        Indicates which compiler to use during compiling C source files.
	Can be either target or host to use the target compiler or the
	host compiler. By default the target compiler is used.

Code shared by different ports
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A second macro called %rule_archalias allows to create a virtual
architecture. And code for that virtual architecture is shared between
several architectures. Most likely this is used for code that uses an
API that is shared between several architecture but not all of them.

The macro has the following header::

    %define rule_archalias mainmmake=/A arch=/A alias=/A

With the following arguments

    ``mainmmake=/A``
        The mmake of the module from which one wants to replace files or to
	wich to add additional files.

    ``arch=/A``
        The arch one wants to make alias from.
	
    ``alias=/A``
        The arch one wants to alias to.
	
Examples
^^^^^^^^

1. This is an extract from the file config/linex/exec/mmakefile.src that
   replaces the main init.c file from exec with a linux specialized one::

       %build_archspecific \
         mainmmake=kernel-exec maindir=rom/exec arch=linux \
         files=init compiler=host

2. For the dos.library some arch specific files are grouped together in the
   unix arch. The following lines are present in the several mmakefiles to
   make this possible
  
   In config/linux/mmakefile.src::
  
       %rule_archalias mainmmake=kernel-dos arch=linux alias=unix

   In config/freebsd/mmakefile.src::
  
       %rule_archalias mainmmake=kernel-dos arch=freebsd alias=unix

   And finally in config/unix/dos/mmakefile.src::
  
       %build_archspecific \
         mainmmake=kernel-dos maindir=rom/dos \
  	 arch=unix \
  	 files=boot \
  	 compiler=host


Lower level mmakefile.src macro's
---------------------------------

FIXME

AROS portable makefile variables
--------------------------------

FIXME


-----------------------
The Multitasking Kernel
-----------------------

Background
==========

There are two kinds of multitasking: Preemptive and Non-preemptive (also known
as cooperative). Preemptive means that you get a certain amount of CPU time
and then another task gets the CPU. Non-preemptive means that a task has to
call a function which allows another task to run. Preemptive multitasking
(PMT) has these advantages:

+ It's simple to understand
+ There is no need to make sure that your task doesn't keep the CPU forever.

and these disadvantages:

+ It's complicated to exchange data with other tasks
+ You never know how long you will stay awake
+ The OS must decide which task to run next in a clever way

Cooperative Multitasking (CMT) has these advantages:

+ It's very simple to implement
+ It's easy to exchange data
+ You know exactly how long you will stay awake
+ You get most of the CPU

and these disadvantages:

+ If a task behaves badly, there is no way to stop it (for example
  if it keeps the CPU forever, all you can do is turn the computer off).
+ It's hard to make sure that every task gets the CPU now and then

It seems obvious that CMT is better than PMT but that's not true. CMT is
better when you have only a few tasks and a single user. Powerful OSes
like Unix and AmigaOS have PMT because it's more simple to use.


How does it work?
=================

The idea is pretty simple. Every computer has a clock and this clock can
generate interrupts. An interrupt means that the CPU saves its current
state on the stack of the current task and starts a special routine
called the interrupt handler. Basically this handler now checks for
other tasks which might want to run, selects one of them and switches
the stack to the one of the newly chosen task. It then finishes and
tells the CPU to continue where it was before the interrupt. Since the
CPU is quite dumb, it will just load it's state from the new stack (ie.
the one of the new task) and so the new task will run and
the old one will be sleeping.

Now let's have a look at the details. The life of a task looks like this:
birth, waiting, running and dying. In computer terms, the task is
created, then waits that it gets the CPU, does its work while it has
the CPU (this might happen more than once) and at some stage, it
terminates (or is terminated). It's more easy to understand how it
all works when we begin with the time when one task loses the CPU
and another one gets it.


----------
MAIN GUIDE
----------

Abstract
========

AROS - The Amiga Research Operating System tries to port the API of the 
Amiga Operating System to different hardware platform. This document
provides an introduction to programming AROS by describing how AROS works 
and by describing its API.


Concepts
========

Includes, definitions and general programming issues
----------------------------------------------------

Include files 
"""""""""""""

AROS comes with a variety of include files. As AROS is a pointer- and 
structure-rich operating system, these files are mainly used for defining 
these structures.

Types
"""""

In `exec/types.h` the following short-cuts are typedef'd. They are used often 
in AROS, so you should nearly always include `exec/types.h`.


`APTR`
    A generic pointer for multiple purposes.
    
`STRPTR`
    A pointer to a null-terminated string.
    
`UQUAD`
    Unsigned 64 bit integer variable.
    
`QUAD`
    Signed 64 bit integer variable.
    
`DOUBLE`
    64bit IEEE floating point variable.
    
`ULONG`
    Unsigned 32 bit integer variable (longword).
    
`LONG`
    Signed 32 bit integer variable (longword).
    
`FLOAT`
    32 bit IEEE floating point variable.

`UWORD`
    Unsigned 16 bit integer variable (word).

`WORD`
    Signed 16 bit integer variable (word).

`UBYTE`
    Unsigned 8 bit integer variable (byte).

`BYTE`
    Signed 8 bit integer variable (byte).

`BOOL`
    Boolean variable, `TRUE` and `FALSE` are also defined in `exec/types.h`.

`VOID`
    Void.


IPTR
^^^^

There is another important typedef, `IPTR`. It is really important in AROS, 
as it the only way to declare a field that can contain both: an integer or 
a pointer.

.. Note:: AmigaOS does not know this typedef. If you are porting a program 
          from AmigaOS to AROS, you have to search your source for occurences 
          of `ULONG`s that can also contain pointers, and change them into 
          `IPTR`s. If you don't do this, your program will not work on systems 
          which have pointers with more than 32 bits (for example DEC Alphas
          that have 64bit pointers).


BPTR
^^^^

The so-called `BPTR`s were always a problem in AmigaOS and this problem was 
inherited by AROS. In binary-compatible AROS versions a `BPTR` is in fact the 
fourth of the real pointer. If, for example, a pointer points to address
``$80000`` the `BPTR` pointing to the same address would contain ``$20000``.
On systems without binary-compatibility, a `BPTR` is equal to an `APTR`.
          
To convert between a normal pointer and a `BPTR` use the macros::

    #include <dos/bptr.h>

    APTR MKBADDR( BPTR bptr );
    BPTR BADDR( APTR ptr );
          
There also exists something called `BSTR` which is a special kind of string. 
We will not dicuss this here, though, because it is used only very rarely.


History
^^^^^^^

When the development of the Amiga started, it was designed as a pure 
module-based games-console. As such it didn't need any means of filesystem 
handling. The OS was created without it in mind. But Commodore, who bought 
the Amiga, wanted a full-fletched home-computer instead of another 
games-platform. So, a short time before the Amiga's initial presentation, 
a filesystem was needed. Instead of wasting time in developing a custom one, 
the filesystem of an operating systm called TRIPOS was ported to the Amiga. 
Unfortunately TRIPOS was written in BCPL, a programming language with a quite
eccentric pointer handling. This pointer handling was inherited by the 
AmigaDOS and later by AROS (even though later versions of AmigaOS and also 
AROS are written in C).
          

Program execution
"""""""""""""""""

All AROS programs must return a program execution status. This status 
expresses, if the program was executed successful, and if not, how serious 
the case of failure was. In `dos/dos.h` the following constants are defined, 
which represent the standard return states:

+ `RETURN_OK` is returned, if the program executed successfully.

+ `RETURN_WARN` means that the program executed successfully, but there was 
  something not quite right. This could be returned, if for example a temporary 
  file could not be deleted after use.
  
  `RETURN_WARN` is also returned to express a boolean state. In this case 
  `RETURN_WARN` means true, while `RETURN_OK` means false.
  
+ `RETURN_ERROR` is returned on errors that caused the execution of the program 
   to fail partly.

+ `RETURN_FAIL` is returned if the execution of the program failed completely.


Libraries and taglists
----------------------

Introduction to libraries
"""""""""""""""""""""""""

Shared libraries are the magic that make AROS work. Every library is
a collection of functions that fulfill a certain purpose. Normally functions
with a similar purpose are contained in one library. For example all the basic
memory handling functions are contained in `exec.library`.

Libraries are normally found in the `LIBS:` directory, but can also be stored at
other places. Some important libraries are not stored as a separate file, but
are contained in the kernel. Note that this the kernel libraries are different
from installation to installation, so don't depend on a specific library being
part of the kernel.

Here is a list of some important libraries and their function.
You don't have to remember all of these, as they will be discussed
later in detail.

+ `exec.library` is the most important library. It is responsible for handling
  the most basic things like managing `tasks` (ie programs), `memory`,
  `libraries` and many other  things.

+ `utility.library` implements very important mechanisms for "talking" to
  libraries: `taglists` that will be dicussed later in this chapter and `hooks`.
  Apart from that, utility contains miscellaneous small utility functions.

+ `dos.library` is responsible for file-handling and some basic I/O functions.
  Without dos, AROS would not be able to access files.

+ `intuition.library` handles `graphical user interfaces (GUIs)`. With intuition
  you can create `windows` and `gadgets` and handle them accordingly. There are
  other libraries, which work on top of intuition and provide more sophisticated
  and more specialized GUI functions. Examples are `gadtools.library`, which
  implements some more complicated gadgets and `asl.library`, which provides
  file- and other `requesters`.


Usage of libraries
""""""""""""""""""

To use the functions of a library, you have to open the library
first. The only library that doesn't have to be opened first is
`exec.library`. Exec is always open and your compiler
knows how to access it. Your compiler may addtionally open some
libraries for you, so you don't have to open them manually. Read your
compiler's manual to learn about such features.

To open a library you have to use a function of `exec.library`::

    #include <proto/exec.h>

    struct Library *OpenLibrary( STRPTR name, ULONG version );

`OpenLibrary()` takes two arguments:

name 
    points to the name of the library. Normally this is just the plain name, but
    this can also be a complete (absolute or relative) path to the library.
    
    .. Note:: Paths do not work with kernel-based libraries
              (ie. libraries that are included in the kernel).
              Use absolute path only, if you know exactly, what you 
              are doing!

version
    is the minimal version of the library to open. If the named library is
    found, but its version is lower than `version`, the library will not be
    opened, but an error will be returned. Versions are important, because
    libraries are supposed to be expandable. Some functions are only available
    from a certain version of a library on. For example the function
    `AllocVec()` of `exec.library` was introduced in version 36 of the library.
    If you try to call this function with lower versions of `exec.library`
    installed, unexpected things will happen (most likely the application will
    crash).

The following procedure is used to load the library to open:

1. First, the name of the library is searched for in the list of already loaded 
   libraries. If this library was loaded into memory before (eg. by a different 
   program) and still is there, everything is fine and `OpenLibrary()` returns 
   now.

   Libraries in the kernel are always on list of loaded libraries.

   .. Note:: Comparisons in this list are case sensitive! Be sure to use the 
             right case in `name`. Normally all characters in a library name 
             are lower-case.

2. If the library was not found in the resident list and a path was supplied 
   with `name`, the given file is tried to be opened. If this fails, 
   `OpenLibrary()` returns an error.

3. If only the plain library-name was given, the library is searched for in the 
   `current directory` first. If it's not found there, it is searched for in 
   the directory `LIBS:`.


`OpenLibrary()` returns either a pointer to
a structure, describing the library (`struct Library *`
defined in `exec/libraries.h`)
or `NULL`, meaning that opening the library failed for
some reason. The resulting pointer has to be stored for the compiler's
use. Normally it is stored in a variable in the form:
<libraryname>Base, eg. `IntuitionBase` for the pointer to
`intuition.library`.

After opening the library, you can use its functions by just calling them like
any other function in your program. But to let your compiler know, what to do,
you have to include the library-specific header-file. This is normally called
proto/<libraryname>.h for C compilers.

When you have finished using the library you have to close it again to free the
resources used by it. This is performed with::

    #include <proto/exec.h>

    void CloseLibrary( struct Library *base );

:function:`CloseLibrary()` closes the library pointed to by `base`. This may
also be `NULL`, in which case `CloseLibrary()` does nothing.

We will demonstrate the use of libraries by creating a small graphical
hello-world program. Instead of printing ``Hello World!`` to the console, we
will display it in a requester. A function to display a requester is
:function:`EasyRequestArgs()`, being a function of `intuition.library`. We will
not discuss its usage here. For more information, see the section about
`Requesters`.

Example usage of libraries::

    #include <proto/exec.h>          /* OpenLibrary() and CloseLibrary() */
    #include <exec/libraries.h>      /* struct Library */
    #include <dos/dos.h>             /* RETURN_OK and RETURN_FAIL */
    #include <proto/intuition.h>     /* EasyRequestArgs() */
    #include <intuition/intuition.h> /* struct EasyStruct */

    /* This variable will store the pointer to intuition.library */
    struct Library *IntuitionBase;

    int main(int argc, char *argv[])
    {
        /* Needed for EasyRequestArgs(). Just ignore. */
        struct EasyStruct es = {
          sizeof(struct EasyStruct), 0UL,
          "Requester", "Hello World!", "Ok"
        };

        /* First, we open intuition.library. We need version 36 or better,
           because EasyRequestArgs() was introduced in that version of
           intuition.library.
        */
        IntuitionBase = OpenLibrary("intuition.library", 36);

        /* We have to check, if intuition.library was successfully opened.
           If it was not, we must not call a function from it, so we return
           immediatly with an error.
        */
        if (!IntuitionBase)
            return RETURN_FAIL;

        /* After opening intuition.library, we can call EasyRequestArgs(). */
        EasyRequestArgs(NULL, &es, NULL, NULL);

        /* At last, we have to close intuition.library again. */
        CloseLibrary(IntuitionBase);

        return RETURN_OK;
    }

Try to compile and run this program. It should present you a
handsome hello-world requester.


Giving additional arguments with taglists
"""""""""""""""""""""""""""""""""""""""""

Every library function takes a fixed number of arguments. This poses quite
a problem with complex functions that would need a lot of arguments. To avoid
this problem, so-called taglists were introduced. In `utility/tagitem.h` we find
a structure `TagItem`, which contains the members `ti_Tag` and `ti_Data`.
A taglist contains of an array of this structure. The size of the list is not
limited. The field `ti_Tag` is an identifier (often referred to as Tag) that
declares what `ti_Data` contains. `ti_Data` is either an integer or a pointer.
It is guaranteed to be at least of the size of a long-word or a pointer
(whichever is bigger).

In every description of a function that uses a tag-list, all possible tags are
listed. Functions have to ignore unknown tags and use defaults for tags not
provided, so taglists are a very flexible way of providing arguments to
a function.

There are some special tags that all functions understand
(defined in `utility/tagitem.h`):


`TAG_DONE` and `TAG_END`
    Define the end of a taglist. Every taglist must be terminated with
    one of it. `ti_Data` must be ignored by
    the called function, so it doesn't have to exist in memory.

`TAG_IGNORE` 
    means that the contents
    of `ti_Data` is to be ignored. This tag is
    especially useful for conditional inclusion of tags.
  
`TAG_MORE`
    By using this tag, you
    can link taglists together. `ti_Data`
    points to another taglist. Processing of the current taglist will
    be stopped and instead the new one will be processed. This tag also
    terminates the current taglist.

`TAG_SKIP` 
    forces the parser to
    skip the next `ti_Data` tags. They will
    not be processed.

You may always provide `NULL` instead of a pointer to a taglist. All functions
must be able to handle `NULL` pointers. They are equal to taglists with
`TAG_DONE` as first tag.

A function that requires a taglist is::

    #include <proto/intuition.h>

    struct Window *OpenWindowTagList
    ( 
        struct NewWindow *newwin, struct TagList *taglist 
    );

This function will be discussed in detail in the `chapter about windows`_. For
now you only have to know that this function opens a new window. We set the
argument `newwin` to ``NULL``. The only tags looked at for now are: 
       
==========  ===============================  ========
Tag         Description                      Type
==========  ===============================  ========
WA_Width    Width of window in pixels        UWORD
WA_Height   Height of window in pixels       UWORD
WA_Title    Window title                     STRPTR
==========  ===============================  ========

Another function we need for our small example is::

    #include <proto/intuition.h>

    void CloseWindow( struct Window *window );

This function is used to close an opened window.

Now let's have a look at another small hello-world-program. This opens window,
which says "Hello World!" in the title-bar, for two seconds::

    #include <proto/exec.h>
    #include <exec/libraries.h>
    #include <proto/dos.h>
    #include <proto/intuition.h>
    #include <intuition/intuition.h>
    
    struct DosLibrary    *DOSBase;
    struct IntuitionBase *IntuitionBase;
    
    int main(int argc, char *argv[])
    {
        int error = RETURN_OK;

        /* We need this for Delay() later on. */
        DOSBase = (struct DosLibrary *)OpenLibrary("dos.library", 36);
        if (DOSBase)
        {
            IntuitionBase = (struct IntuitionBase *)OpenLibrary("intuition.library", 36);
            if (IntuitionBase)
            {
                struct Window *win;
                /* We set up our tags. */
                struct TagItem tags[] =
                {
                    { WA_Width, 100                  },
                    { WA_Height, 50                  },
                    { WA_Title, (IPTR)"Hello World!" },
                    { TAG_DONE, 0UL                  }
                };
    
                win = OpenWindowTagList(NULL, tags);
                if (win)
                {
                    /* Now wait for two seconds, so we can look at our nice
                       window.
                    */
                    Delay(100);
    
                    /* We close our window again. */
                    CloseWindow(win);
                }
    
                CloseLibrary((struct Library *)IntuitionBase);
            }
            else
                error = RETURN_FAIL;
    
            CloseLibrary((struct Library *)DOSBase);
        } else
            error = RETURN_FAIL;
    
        return error;
    }  
                  
Of course, this method of setting up the taglist is quite complicated. So for
most functions that use taglists short-cuts are available. The link-library
`amiga.lib` provides these short-cuts for all internal AROS functions. These
varargs versions can be used like this:
    
    #include <proto/alib.h>

    Function( arg1, ..., argn, TAG1, data1, ..., TAG_DONE );

Our example above would look like this, using the varargs version of
`OpenWindowTagList()`, called `OpenWindowTags()`::

    [...]
    
    if( IntuitionBase )
    {
        struct Window *win;

        win = OpenWindowTags
        (
            NULL, WA_Width, 100, WA_Height, 20,
            WA_Title, "Hello World!", TAG_DONE
        );
        )
        if( win )
        {
    
    [...]
          
Much easier, isn't it? In the `section about BOOPSI`_, processing of taglists
will be discussed.


Exec lists and memory management
--------------------------------

Exec lists
""""""""""

AROS implements a system of linked lists, so-called exec lists.
A linked-list consists of a number of nodes that point to each other. Two types of nodes are defined in
`exec/nodes.h`:

`struct MinNode` 
    is the basic node. You don't need to know about its structure, since every
    possible action on them is handled by some library function.
    
`struct Node` 
    extends the simple struct `MinNode`. It provides some
    additional fields:
    
    `ln_Name`
        Each `Node` contains a pointer to a string, describing that node.
    
    `ln_Type`
        A list of types is defined in `exec/nodes.h`.
    
    `ln_Pri`
        A priority, used for sorting the list.

Both structures can be embedded into other structures. For example `struct
Library`_ (defined in `exec/libraries.h`_) contains a struct `Node` at the
beginning. This way all libraries can be contained in a list. The field
`ln_Name` points to the name of the library, `ln_Type` is set to `NT_LIBRARY` to
show that this node is a library and `ln_Pri` reflects the *importance* of
a library.

Of course, we need a list containers. These are defined in `exec/lists.h`_. Like
nodes, we have two different kind of lists:

`struct MinList` 
    is the minimal list. You do not need to know about its members; look at
    it as a black-box.
    
`struct List` 
    contains an additional field `lh_Type`, which
    corresponds to `ln_Type` of
    `struct Node`.

`MinList`s take `MinNode`s as members, while `List`s use `Node`s. They are not
interchangeable. While it's technically possible to use `Node`s in `MinList`s,
you loose all their advantages.

FIXME: Macros


List Manipulating Functions
^^^^^^^^^^^^^^^^^^^^^^^^^^^

exec.library and the link-library amiga.lib contain some functions for
manipulating exec lists. Before a list can be used, it *must*
be initialized, using the amiga.lib function::

    #include <proto/alib.h>

    void NewList( struct List *list );

Nodes can be added to lists with the exec.library functions::

    #include <proto/exec.h>

    void AddHead( struct List *list, struct Node *node );
    void AddTail( struct List *list, struct Node *node );
    void Enqueue( struct List *list, struct Node *node );
    void Insert( struct List *list, struct Node *node, struct Node *pred );

With `AddHead()` and `AddTail()` ``node`` is inserted at the beginning or the
end of ``list`` respectively. `Enqueue()` inserts ``node`` according to its
``ln_Pri`` field. A node can be inserted after another by using `Insert()`.
A pointer to the node that is to predecess ``node`` must be provided as
``pred``.

Nodes can be removed using the exec.library functions::

    #include <proto/exec.h>

    void Remove( struct Node *node );
    struct Node *RemHead( sruct List *list );
    struct Node *RemTail( struct List *list );

While `RemHead()` and `RemTail()` remove the first or last node of a ``list``
respectively and return a pointer to it, `Remove()` removes ``node`` from
whatever list it is in.

Of course, all list functions (except `Enqueue()`) can process ``struct
MinList`` and ``struct MinNode``s, too.

A list can be searched for a named node, using::

#include <proto/exec.h>

struct Node *FindName( struct List *list, STRPTR name );

``name`` is a pointer to a string that is to be compared with the ``ln_Name`` of
the nodes in ``list``. The comparison is case-sensitive! If ``name`` matches any
``ln_Name`` field, a pointer to the corresponding node is returned. If no field
matches, ``NULL`` is returned.

.. Note::

    A list used with `FindName()` must not contain any ``struct MinList``
    entries. If it does, memory could get corrupted!

In the following example, we create a list, add three nodes to it, search
a named node and then remove it::

    #include <proto/alib.h>
    #include <proto/exec.h>
    #include <exec/types.h>
    #include <exec/lists.h>
    #include <exec/nodes.h>
    #include <dos/dos.h>    /* For RETURN_OK */

    struct List list;

    /* Our nodes */
    struct Node node1 =
    {
        NULL, NULL,    /* No predecessor and successor, yet */
        NT_UNKNOWN, 0, /* Unknown type, priority ignored */
        "First node"   /* Name of the node */
    };

    struct Node node2 =
    {
        NULL, NULL,
        NT_UNKNOWN, 0,
        "Second node"
    };

    struct Node node3 =
    {
        NULL, NULL,
        NT_UNKNOWN, 0,
        "Third node"
    };


    int main(int argc, char *argv[])
    {
        struct Node *node;

        /* Prepare the list for use. */
        NewList(&list);

        /* Add the first two nodes at the end of the list. */
        AddTail(&list, &node1);
        AddTail(&list, &node2);

        /* Insert the third node after the first node. */
        Insert(&list, &node3, &node1);

        /* Find the second node */
        node = FindName(&list, "Second node");

        /* 
            If the node was found (which is always the case in this example),
            remove it.
        */

        if (node)
            Remove(&node);

        return RETURN_OK;
    }


Memory Handling
"""""""""""""""

You need memory for nearly everything in a program. Many things can be done by
using the stack. But often you need larger chunks of memory or don't want to use
the stack for some reason. In these cases you have to allocate memory by
yourself. exec.library provides different methods for allocating memory. The two
most important functions are::
        
    #include <proto/exec.h>

    APTR AllocMem( ULONG size, ULONG flags );
    APTR AllocVec( ULONG size, ULONG flags );

Both functions return a pointer to a memory area of the requested ``size``
provided as argument. If not enough memory was available, ``NULL`` is returned,
instead. You must check for this condition, before using the memory. If the
memory was successfully allocated, you can do with it whatever you want to. You
can provide additional ``flags`` to get a special kind of memory. The following
flags are defined in :include:`exec/memory.h`:

MEMF_CLEAR
    The allocated memory area is initialized with zeros.
    
MEMF_LOCAL
    Get memory that will not be flushed, if the computer is reset.
    
MEMF_CHIP
    Get memory that is accessible by graphics and sound chips. This type of
    memory is required for some functions.

MEMF_FAST
    Get memory that is not accessible by graphics and sound chips. *You should
    normally not set this flag! It is needed only for some very esoteric
    functions. Many systems don't have this kind of memory.*

MEMF_PUBLIC
    This flag must be set, if the memory you allocate is to be accessible by
    other tasks. If you do not set it, the allocated memory is *private* to your
    task. This issue will be discussed in detail in the chapter about
    `inter-task communication`_.

MEMF_REVERSE    
    If this flag is set, the order of the search for empty memory blocks is
    reversed. Blocks that are at the end of the list of empty memory will be
    found first.

MEMF_NO_EXPUNGE
    Normally, if not enough free memory of the requested size is found, AROS
    tries to free unused memory, for example by flushing unused libraries out of
    the memory. If this flag is set, this behaviour is turned off.

Memory allocated with these functions *must be freed* after use with one of the
following functions. *Note well that you must not use memory that was already
freed.*

    #include <proto/exec.h>

    void FreeMem( APTR memory, ULONG size );
    void FreeVec( APTR memory, ULONG size );

Of course, `FreeMem()` must be used for memory allocated with `AllocMem()` and
`FreeVec()` for memory allocated with `AllocVec()`. The synopsis for these two
functions shows the difference between `AllocMem()` and `AllocVec()`:
`AllocVec()` remembers the size of the chunk of memory, it allocated. So, if you
use `AllocVec()`, you don't have to store the requested size, while you have to,
if you use `AllocMem()`.


Allocating Multiple Regions of Memory at once
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Sometimes you may want to make multiple memory allocations at once. The usual
way to do this is calling `AllocVec()` with the size of all memory-blocks added
and then making pointers relative to the returned pointer. But what do you do,
if you need memory of different kinds, it with different ``MEMF_`` flags set?
You could make multiple allocations or simply use the function::

    #include <proto/exec.h>

    struct MemList *AllocEntry( struct MemList *oldlist );

As you will have noticed, `AllocEntry()` uses a pointer to a ``struct MemList``
as only argument and as result. We find the definition of this structure in
:include:`exec/memory.h`::

    struct MemEntry
    {
        union
        {
            ULONG meu_Reqs;
            APTR  meu_Addr;
        } me_Un;
        ULONG me_Length;
    };
     

    struct MemList
    {
        struct Node     ml_Node;
        UWORD           ml_NumEntries;
        struct MemEntry ml_ME[1];
    };

The array ``ml_ME`` of ``struct MemList`` has a variable number of elements. The
number of its elements is set in ``ml_NumEntries``. The struct ``MemEntry``
describes one memory-entry. Stored are its size (``me_Length``), its
requirements (ie the ``MEMF_``, set in ``me_Un.meu_Reqs``) and possibly
a pointer to the memory-block (``me_Un.meu_Addr``). The struct ``MemList``, you
pass in as ``oldlist``, must have set the field ``ml_NumEntries`` to the actual
number of struct ``MemEntry``s contained in ``ml_ME``. The ``struct MemEntry``s
must have set the fields ``me_Length`` and ``me_Un.meu_Reqs``. The other fields
are ignored. The function returns a pointer to a copy of the struct
``MemEntry``, passed in as ``oldlist``, with all the relevant fields set
(especially ``me_Un.meu_Addr``). An error is indicated by setting the most
significant bit of the pointer returned. So you always have to check it, before
using the pointer returned. Memory allocated with `AllocEntry()` must be freed
using `FreeMem()`.


Memory Pools
^^^^^^^^^^^^

AROS manages different so-called memory-pools. Each memory-pool contains a list
of memory-areas. The most important memory-pool is the pool that contains all
free memory in the system. But you also can create memory-pools yourself. This
has some advantages:

+ Everytime, you allocate some memory, the memory in the system becomes more
  fragmented. This fragmentation causes the available memory chunks to become
  smaller. This way larger allocations will fail. To prevent this problem,
  memory-pools were introduced. Instead of allocating many small chunks of
  memory, the pool-management routines allocate large chunks and then return
  small chunks out of it, when memory-requests are made.
  
+ Private memory-pools have the ability to keep track of all the allocations you
  made so that all memory in a pool can be freed with one simple function-call
  (but you can also free memory individually).

Before a memory-pool can be used, it must be created. This is performed by the
function::

    #include <proto/exec.h>
    
    APTR CreatePool( ULONG flags, ULONG puddleSize, ULONG threshSize );
          
The `flags` specifies the type of memory you want to get from the
`AllocPooled()` function . All ``MEMF_`` definitions as described above are
allowed here.

`puddleSize` is the size of the chunks of memory that are allocated by the pool
functions. Usually a size about ten times bigger than the average memory-size,
you need to allocate, is a good guess. But on the other hand the `puddleSize`
should not be too large. Normally you should limit it to about ``50kb``. Note
well, though, that these are only suggestions and no real limitations.

Finally, the `threshSize` specifies, how large the memory that is to be
allocated is allowed to be so that no new chunk is allocated automatically. If,
for example, the `threshSize` is set to 25kb and you want to allocate a piece of
memory with the size of 30kb, the internal lists of chunks of that memory-pool
is not searched, but the memory is allocated directly, instead. If the memory to
be allocated was only 20kb, the chunk-list would have been searched for a piece
of free memory of that size, first. Of course, the `threshSize` *must not* be
larger than the `puddleSize` and should not be too small, either. Half the
`puddleSize` is a good guess here.

`CreatePool()` returns a private pointer to a pool-structure that must be saved
for further use. ``NULL`` is returned, if no memory for the pool-structure was
available. You have to check for this condition.

After use, all memory-pools must be destroyed by calling::

    #include <proto/exec.h>
    
    void DeletePool( APTR pool );

This function deletes the `pool` passed in. Additionally all memory that was
allocated in this pool is freed. This way, you don't need to remember every
single piece of memory, you allocated in a pool. Just call `DeletePool()` at the
end. Note that you should be careful not to use pooled memory after its pool was
deleted!

If you want to allocate memory out of a pool, you need to call::

    #include <proto/exec.h>
    
    void *AllocPooled( APTR pool, ULONG size );

Besides the `pool` to allocate memory from, the `size` of the memory to allocate
must be passed in. Returned is a pointer to a block of memory of the requested
size or ``NULL`` to indicate that not enough memory was available.

Memory allocated with `AllocPooled()` can be freed by either destroying the
whole pool with `DeletePool()` or individually by calling::

    #include <proto/exec.h>
    
    void FreePooled( APTR pool, void *memory, ULONG size );

This function frees exactly one piece of memory that was previously allocated
with `AllocPooled()`. The pointer to the `memory` pointer, returned by
`AllocPooled()`, its `size` and the pool, it is in, have to be supplied as
arguments.

.. Note::

    You may ask yourself: "If `DeletePool()` deletes all the memory of a pool, why
    should I ever use `FreePooled()`?" The answer is easy: to save memory. Normally
    it's good style to free memory as soon as you don't need it anymore. But
    sometimes it is easier just to free a memory-pool after a bunch of allocations.
    Nevertheless you should not use this feature, if you are not sure, when the
    memory-pool will be deleted. Imagine a program like this (do not try to compile
    it; it won't)::

        #define <exec/types.h>
        #define <exec/memory.h>
        #define <dos/dos.h>

        int main(int argc, char *argv[])
        {
            APTR pool;
            APTR mem;

            /* Create our memory pool and test, if it was successful. */
            pool = CreatePool(MEMF_ANY, 50*1024, 25*1024);
            if (pool)
            {

                /* Just a dummy function. Image that this function will open a window,
                   with two buttons "Do Action" and "Quit".
                */
                open_our_window();

                for(;;)
                {
                    /* Another dummy function that returns one of the definitions
                       below.
                    */
                    switch(get_action())
                    {
                    /* This is returned, if the button "Do Action" was released. */
                    case DOACTION:
                        mem = AllocPooled(pool, 10*1024);
                        if (mem)
                        {
                            /* Another dummy function that uses our memory. */
                            silly_function(mem);
                        }
                        break;
                    /* This is returned, if the button "Quit" was released. */
                    case QUIT:
                        return RETURN_OK;
                    }
                }

                /* Close the window, we have opened above. */
                close_our_window();

                /* Delete our pool. */
                DeletePool(pool);
            }
        }
         
    Each time the button ``Do Action`` is released, some memory is allocated.
    This memory is freed at the end of the program, when `DeletePool()` is
    called. Of course, the longer the program is used, the more memory will be
    in use. That is why it would be much better to free the memory after use.
    This is done by replacing the part between ``case DOACTION:`` and ``case
    QUIT:`` by::

        mem = AllocPooled(pool, 10*1024);
        if (mem)
        {
            silly_function(mem);
            FreePooled(pool, mem, 10*1024);
        }
        break;


Obsolete Memory Pool Functions
''''''''''''''''''''''''''''''

Memory-pools are managed with ``struct MemHeader``s. If you have a pointer to
such a structure, you may try to allocate some memory of its pool::

    #include <proto/exec.h>

    void *Allocate( struct MemHeader *mh, ULONG size );

Apart from the pointer to the struct ``MemHeader`` passed in as ``mh``, you have
to supply the ``size`` of the memory-block you want to allocate. This function
returns either a pointer to the first memory-block found or
<SYMBOL>NULL</SYMBOL> if no matching block was found.

You must free every memory-block allocated with `Allocate()` with::

    #include <proto/exec.h>

    void Deallocate( struct MemHeader *mh, APTR mem, ULONG size );

You have to pass the same ``mh`` and ``size`` to `Deallocate()` as you have
passed to `Allocate()` and additionally the pointer returned by it.

intuition.library provides another way to handle memory pools with the functions
`AllocRemember()` and `FreeRemember()`. Note, though, that these are obsolete.
You should use the normal pool-functions of exec.library, instead.


Allocating a specific memory address
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Under very rare circumstances you may have to allocate memory at a specific
memory address. This performed by using::

    #include <proto/exec.h>

    void *AllocAbs( ULONG size, APTR address );

This function tries to allocate `size` bytes at `address`. If this is
successful, a pointer to the requested address is returned. If some memory of
the requested block is already allocated or is not available in the system,
``NULL`` is returned, instead.

.. Warning::
    
    The beginning of the memory block requested will be used by exec to store
    its node-data (the exact size is calculated by ``(2*sizeof (void *)) )``.
    Therefore, you *must not write* to the beginning of the memory-block!
    Because of these obstacles you should not use `AllocAbs()`, except if you
    really need it.

Memory allocated with ``AllocAbs()`` must
be freed, using ``FreeMem()``.


Querying memory size and available memory
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

To get the size of available memory, use the function::

    #include <proto/exec.h>
    
    ULONG AvailMem( ULONG type );

The `type` parameter is some of the following flags (or'ed),
as defined in `exec/memory.h`:

``MEMF_ANY``              
    Return the size of all free memory in the system.
    
``MEMF_CHIP``
    Return the size of memory, which is accessible by graphics and sound chips.

``MEMF_FAST``
    Return the size of memory that is not accessible by graphics and sound
    chips.
              
``MEMF_LARGEST``
    Return only the largest block, instead of all memory of the type specified.
              
You may as well specify other ``MEMF_`` flags, they will be simply ignored.

.. Note::

    Note well that the queried memory-size does not have to reflect the real
    size of memory available, as this may always change in
    a multitasking-system, even while `AvailMem()` is executed.

Program to list memory available in the system::

    #include <stdio.h>
    #include <exec/memory.h>

    int main(int argc, char *argv[])
    {
        printf("Total free memory: %h, largest block: %h\n",
        AvailMem(MEMF_ANY), AvailMem(MEMF_ANY|MEMF_LARGEST));
        
        printf("Free chip memory:  %h, largest block: %h\n",
        AvailMem(MEMF_CHIP), AvailMem(MEMF_CHIP|MEMF_LARGEST));
        
        printf("Free fast memory:  %h, largest block: %h\n",
        AvailMem(MEMF_FAST), AvailMem(MEMF_FAST|MEMF_LARGEST));
    }
    
    
Adding memory to the system
^^^^^^^^^^^^^^^^^^^^^^^^^^^

This chapter is only of concern to you, if you want to write a hardware-driver
for a piece of hardware, which adds memory to the system::

    #include <proto/exec.h>
    
    void AddMemList
    ( 
        ULONG size, ULONG type, LONG priority,
        APTR address, STRPTR name
    );
          
adds memory to the list of free memory in the system. You have supply the
`address` and the `size` of the memory to add. `type` has to be set to at least
one of the ``MEMF_`` flags, which are defined in `exec/memory.h`:

``MEMF_FAST``
    Your memory must not be accessed by graphics or sound chips.
    
``MEMF_CHIP``
    Your memory is reachable by graphics and sound chips.

You can provide a `priority`, with which your memory will be added to the memory
list. The general rule is: The quicker your memory, the higher the priority
should be. If you don't know, what to supply here, supply ``0``. Finally, you
can provide a `name`, with which your memory can be identified by the system and
its users. You may provide ``NULL`` instead of a name, but giving your memory
a name is recommended.

Once your memory was added to the list of free memory, it can't be removed
anymore.


Low memory situations
^^^^^^^^^^^^^^^^^^^^^

FIXME: AddMemHandler()/RemMemHandler()


Files and directories
---------------------
      
Paths
"""""
     
FIXME: relative and absolute paths
     

Files
"""""

FIXME

Reading files
^^^^^^^^^^^^^

FIXME
     

Writing and creating files
^^^^^^^^^^^^^^^^^^^^^^^^^^

FIXME

      
Directories
""""""""""""

FIXME


Links
"""""
        
Links are a method to apply multiple filenames to the same physical file or
directory. This way the file can be stored in multiple directories with
different filenames. There are two different types of links: hardlinks and
softlinks. A softlink is just a reference to another file by its name. This name
may be stated as relative or absolute path. If a softlink is accessed, AROS
tries to resolve the name of the file the link points to and redirects all
actions to that file. Of course, the file pointed to does not have to exist. It
may have been deleted after the link was created. Hardlinks are another instance
of the same file. They don't just reference the file by its name, they *are* the
file. Normally, a hardlink can't be distinguished from the orginal filename;
effectively the file has been given a second name. Due to this, hardlinks can
not be created over different volumes; they must be at the same volume.

.. Note:: 

    Not all filesystems support both types of links or any links at all.


Creating Links
^^^^^^^^^^^^^^

FIXME     

Low level file access (filehandlers)
""""""""""""""""""""""""""""""""""""
    
FIXME


Tasks, Processes and the Shell
------------------------------

Tasks 
""""" 

AROS is a multitasking operating system. This essentially means that multiple
programs may be run at the same time. Every program running is called a task.
But there are also tasks that are not user-programs. There are, for example,
tasks handling the file-system and tasks watching the input devices. Every task
gets a certain amount of time, in which it is running. After this time it's the
next task's turn; the system reschedules the tasks.

Plain tasks are very limited in their capabilities. Plain tasks must not call
a function of ``dos.library`` or a function that could call a function of
``dos.library`` (this includes ``OpenLibrary()`` for most cases!). Processes_
don't have this limitation.


The Task Structure
^^^^^^^^^^^^^^^^^^

A task is described by a struct ``Task`` as defined in :include:`exec/tasks.h`.
This structure contains information about the task like the its stack, its
signals and some management data. To get the address of a task strucure, use

    #include <proto/exec.h>

    struct Task *FindTask( STRPTR name );

``name`` is a pointer to the name of the task to find. *Note that this name is
case-sensitive!* If the named task is not found, ``NULL`` is returned, otherwise
a pointer to a ``struct Task``.

To get a pointer to the current task, supply ``NULL`` as ``name``. This can
never fail.

The task structure contains a field called ``tc_UserData``. You can use it for
your own purposes. It is ignored by AROS.


States
^^^^^^

A task must be in one of following states (as set in the field
`tc_State` of the task structure):
          
TS_INVALID
    This state should never be set!
	
TS_ADDED
    FIXME
            
TS_RUN
    The task is currently running. On single processor architectures only 
    one task can be in that state.
   
TS_READY
    The task waits for its execution.
    
TS_WAIT
    The task waits for some signal_ to get activated. As long as this does not 
    happen, the program doesn't become active; it is ignored on rescheduling. 
    Most interactive programs are in this state most of the time, as they wait 
    for user input.
    
TS_EXCEPT
    The task is in an exception.

TS_REMOVED
    FIXME

.. Note:: 

    Do not set these states yourself, unless you know exactly what you are
    doing!


Priorities
^^^^^^^^^^

The field ``tc_Node.ln_Pri`` of the ``struct Node`` embedded in the task
structure (see :include:`exec/nodes.h` and the  `section about exec lists`_)
specifies the priority of the task. Possible priorities reach from ``-128`` to
``127``. The higher the priority the more processor time the task gets from the
system. To set a task's priority use the function::

    #include <proto/exec.h>

    BYTE SetTaskPri( struct Task *task, BYTE newpri );

The old priority is returned.


Stack
^^^^^

Every task has a stack. A stack is a piece of memory, in which a tasks stores
its temorary data. Compilers, for example, use the stack to store variables, you
use in your programs. On many architectures, the stack is also used to supply
library functions with parameters.

The size of the stack is limited. Therefore only a certain amount of data can be
stored in the stack. The stack-size of a task is chosen by its caller and must
be at least 4096 bytes. Tasks should generally not assume that their stack-size
is bigger. So, if a task needs more stack, the stack can be exchanged by using
the function::

    #include <proto/exec.h>

    void StackSwap( struct StackSwapStruct *sss );

The only argument, ``sss``, is a pointer to a ``struct StackSwapStruct`` as
defined in :include:`exec/tasks.h`.

``struct StackSwapStack`` must contain a pointer to the beginning of the new
stack (``strk_Lower``), to the end of the new stack (``stk_Upper``) and a new
stack-pointer (``stk_Pointer``). This stack-pointer is normally set either to
the same address as ``stk_Lower`` or to the same address as ``stk_Upper``,
depending on the kind of CPU used.

When calling `StackSwap()`, the ``StackSwapStruct`` structure supplied as
``sss`` will be filled with information about the current stack.

After finishing using the new stack, the old stack must be restored by calling
`StackSwap()` a second time with the same ``StackSwapStruct``.

.. Note:: 

    Normally, only compilers need this function. Handle it with great care as
    different architectures use the stack in different ways!


Processes
"""""""""

A process is an expanded task_. Opposed to a task, it can use functions of
dos.library, because a process structure contains some special fields,
concerning files and directories. But of course, all functions that can be used
on tasks can also be used on processes.


The Process Structure
^^^^^^^^^^^^^^^^^^^^^

A process is described by a ``struct Process`` as defined in
:include:`dos/dosextens.h`. The first field in ``struct Process`` is an embedded
``struct Task``. The extra fields include information about the file-system, the
console, the process is connected to, and miscellaneous other stuff.


The Current Directory
'''''''''''''''''''''

FIXME


Standard File Handles
'''''''''''''''''''''

FIXME


Console Related Information
'''''''''''''''''''''''''''

FIXME


Creating own Tasks and Processes
""""""""""""""""""""""""""""""""

There are mainly two methods of creating tasks and processes: you can either
call an external program (ie open an executable file and run the program
contained in it) or you can execute a piece of code, already in memory.


Starting External Programs
^^^^^^^^^^^^^^^^^^^^^^^^^^

External programs are always processes.
FIXME


Creating Tasks by Hand
^^^^^^^^^^^^^^^^^^^^^^          

FIXME


Creating Processes by Hand
^^^^^^^^^^^^^^^^^^^^^^^^^^

FIXME


Local and Global Variables
""""""""""""""""""""""""""

FIXME


Expanded Error Diagnostics
""""""""""""""""""""""""""

Most functions of `dos.library` set the secondary error-code of the process
structure on error. This way the caller can determine, why a certain system-call
failed. Imagine, the function `Open()`, which opens a named file, fails. There
can be multiple reasons for this: maybe the file named doesn't exist, maybe it
is read protected. To find this out, you can query the secondary error-code set
by the last function by using::

	#include <proto/dos.h>

    LONG IoErr() 
           
DOS-functions return one of the ``ERROR_`` definitions from
:include:`dos/dos.h`. Applications can, of course, process these error-codes by
hand (which is useful in many cases), but often we just want to inform the user
what went wrong. (Applications normally need not care, if a file could not be
opened, because it did not exist or because it was read protected.) To output
human-readable error messages, dos.library provides two functions::

    #include <proto/dos.h>

    LONG Fault( LONG code, STRPTR header, STRPTR buffer, LONG length );
    BOOL PrintFault( LONG code, STRPTR header );

While `PrintFault()` simply prints an error message to the `standard output`_,
`Fault()` fills a supplied buffer with the message. Both functions take
a ``code`` argument. This is the code to be converted into a string. You can
also supply a ``header`` string, which will prefix the error message. ``header``
may be ``NULL``, in which case nothing is prefixed.

`Fault()` also required a pointer to a ``buffer``, which is to be filled with
the converted string. The ``length`` of this buffer (in bytes) is to be passed
in as last argument. The total number of characters put into the buffer is
returned. You are on the safe side, if your buffer has a size for 83 character
plus the size of the header.

Examples for the use of these functions can be found in later chapters,
especially in the chapter about `Files and Directoriess`_.

Secondary error-codes of a program are handed back to the caller. If this is
a shell, the secondary error-code will be put into the field ``cli_Result2`` of
the shell structure (struct ``CommandLineInterface`` as defined in
:include:`dos/dosextens.h` and `discussed later`_.

You can also set the secondary error-code yourself. This way, you can either to
pass it back to another function in your program or to your caller. To set the
secondary error, use::

    #include <proto/dos.h>

    LONG SetIoErr( LONG code );

``code`` is the new secondary error-code and the old secondary error-code is
returned.

`SetIoErr()` will be used in the `chapter about object orientation`_.


Parsing Arguments
"""""""""""""""""        

FIXME: ReadArgs()


Interprocess communication
""""""""""""""""""""""""""

FIXME


Signals
^^^^^^^

FIXME


Ports
^^^^^

FIXME


Multitasking Issues
"""""""""""""""""""

``Forbid()`` and ``Permit()``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

FIXME


Semaphores
^^^^^^^^^^

FIXME


Shell
"""""

FIXME


AROS' Object Oriented System (BOOPSI), Hooks and Processing of Taglists
-----------------------------------------------------------------------

FIXME

Processing Taglists
"""""""""""""""""""

The following chapter describes, how to implement functions that process
taglists. It is written in reference to BOOPSI classes, but the usage is the
same for other uses of taglists (eg in custom libraries).

FIXME


Hooks
"""""

FIXME


Implementing Taglists
"""""""""""""""""""""

FIXME


Datatypes
---------

FIXME


Devices and Hardware Independent Device Drivers (HIDDs)
-------------------------------------------------------

FIXME


Filesystem handlers
-------------------

FIXME


Interrupts
----------

FIXME



Graphical User Interfaces (GUIs)
================================

Windows
-------

FIXME


Requesters
----------

Requesters are a special kind of windows_. They either confront the user with
some information or request some information. Requesters always interrupt the
user's normal workflow, so they should only be used either to inform him of some
important event or to request an information, without which the application
can't continue to work. This kind of requester is called modal requester.

Examples of informational requesters are requesters that report errors (like
failing to open a file) or about requesters, which show information about the
program, when requested by the user.

Like the name indicates, requesters can also request information from the user,
like a file name (using file-requesters), his name or a simple yes/no decision
("Really quit application?").

Requesters should only pop-up, if an application can't go on without knowing
that the user learned about a certain fact or without getting a certain kind of
information. Therefore, most requesters will block the application. That means
that they will not listen to any input, except that in the requester. An
exception are requesters that are explicitly requested by the user, like most
file-requesters or about-requesters. Normally, these should not block the
application.


Easy Requesters
"""""""""""""""

The so-called easy requesters are simple requesters. They can be used to either
provide an information or to ask for a choice. The number of choices is limited
to 256, but it is generally a bad idea to have more than about five different
choices. You also have to take into account that the width of the screen is
limited.

FIXME: EasyRequestArgs(), BuildEasyRequest()


Complex Requesters
""""""""""""""""""

FIXME


Asl Requesters (Font-, File- and Screenmode-)
"""""""""""""""""""""""""""""""""""""""""""""
       
FIXME


Screens
-------

FIXME


Gadgets
-------

FIXME


Painting and Drawing
--------------------

FIXME


Images
------

FIXME


Direct Hardware Access
-----------------------

FIXME



Programming of Libraries, Datatypes, HIDDs, etc
===============================================

FIXME: Some of this should go into the system development manual instead.
       (HIDDs, atleast)


Libraries
---------

FIXME

    
Datatypes
---------

FIXME


HIDDs and Devices
-----------------

FIXME

    
Filesystem handlers
-------------------

FIXME


--------------------------
Appendix: Library Overview
--------------------------

FIXME: This should be autogenerated from autodocs?


------------------
Appendix: Glossary
------------------

Absolute Path
=============

.. FIXME: Write.

See also:

+ `Relative Path`_


Current Directory
=================

:Abbreviation: CD
      
The directory, which all file-system actions are relative to, as long as no
`absolute path`s are used. Every `process` structure stores its current
directory in the field `pr_CurrentDir`.
	

Process
=======

.. FIXME: Write.

See also:

+ `Task`_


Relative Path
=============

.. FIXME: Write.

See also:

+ `Absolute Path`_


Resident List
=============

.. FIXME: Write.


Screen
======

.. FIXME: Write


  

Standard Filehandles
====================

.. FIXME: Write.


Standard Input
==============

:Abbreviation: stdin

See `Standard Filehandles`_
  

Standard Output
===============      

:Abbreviation: stdout

See `Standard Filehandles`_


Standard Error
==============

:Abbreviation: stderr

See `Standard Filehandles`_
    
   
Task
====

.. FIXME: Write.


See also:

+ `Process`_
  

Window
======

.. FIXME: Write.

See also:

+ `Screen`__


Screen
======

FIXME: Write.


-----------------------------------------
Appendix: Differences compared to AmigaOS
-----------------------------------------

Pointer/Integer conversions
===========================

If you need a variable which can store a pointers as an integer, don't use
`ULONG` but `IPTR`. AROS guarantees that `LONG` is 32bit on all systems, while
`IPTR` is always large enough to contain a pointer. Most notable things
which are affected by this: `TagItem`s (the `ti_Data` field is now an `IPTR`
instead of `ULONG`), BOOPSI classes (eg. the return value of `DoMethod()`),
`ReadArgs()`, `VPrintf()`, `VFPrintf()` and more.


64 bit variables
================

The type of 64 bit variables is `QUAD` (unsigned: `UQUAD`). This is for example
returned by the function `SMult64()` of utility.library. To access the
high- and loworder 32bit values of the 64bit variable, use `LOW32OF64()`
and `HIGH32OF64()` which are defined in `AROS/include/aros/64bit.h`.


Cloning RastPorts
=================

AROS uses an external driver to access the graphics hardware. Since the
nature of this driver is unknown to AROS, it is no longer valid to clone
a RastPort by simply copying it. To be compatible, there are two new
functions (in AROS) or macros (on Amiga): `CreateRastPort()`,
`CloneRastPort()` and `FreeRastPort()`. You must call `CloneRastPort()` to
create a copy or `CreateRastPort()` for an empty RastPort and
`FreeRastPort()` after you´ve done your work with it.

This approach produces equivalent code on the Amiga but on AROS it can slow
things down a bit. If you must preserve the original state of the RastPort,
it's more safe to create a clone, work on it and then dispose of it again. It
can also be faster if you would have to make a lot of changes to the RastPort
to create two clones and set them to the two states you need. But your code
should not depend on certain gains or losses of speed due to cloned RastPorts
since the behaviour of the underlying graphics system is undefined.


Tag values
==========

The original AmigaOS doesn't use the tags below `USER_TAG` (have a look a at 
`include:utility/tagitem.h` if you don't belive me) which means, you shouldn't use
tags at or near `USER_TAG` because then they might interfere with the OS's
own tags. To solve this, AROS *does* use the tags *below* `USER_TAG` and the
various implementators need not fear that their tags may overlap with the
ones from the system. The file `AROS/include/utility/tagitem.h` now contains the
basic offsets for the various parts of the OS. In the future, it might be
possible for users to allocate ranges of tags for specific uses.


DoMethod() or the stack is all wrong
====================================

There are CPUs around which don't care that the rest of the world have
stacks which grow from large to small adresses. HPPA is an example for
this. While it might look neat to the engineers who did it, it breaks our
code. Another thing which breaks the code are small data types (eg. `WORD`,
`UBYTE`, etc), because most systems put only integers or longs and pointers
on the stack. So if some Msg structure expects `WORD` (see
`include:intuition/gadgetclass.h`), this fails on every system but
the Amiga. Then there are rumours about CPUs which use 32bit numbers and
64bit pointers or the other way round. On these CPUs, `SetAttrs()` and all
other function which pass TagLists over the stack will fail. To overcome
this, we introduce this rule:

*If you want to pass a structure with `DoMethod()` and `DoMethodA()`
or similar functions, you must prepend `STACK` to each type, like
this: `WORD` becomes `STACKWORD`, `ULONG` becomes `STACKULONG`, etc.*

To solve special problems on certain CPUs, we try to get a compiler which
gets it right or, if that is impossible, we write a small preprocessor
which replaces the dubious code by calls to the array versions.


Include files
=============

Due to some weird reason the include files for workbench.library are called
clib/wb_protos.h, defines/wb.h, inline/wb.h, wb_pragmas.h and proto/wb.h
in AmigaOS. AROS decided to replace "wb" by the library's name "workbench".
We provide wrapper includes for consitency to (old) AmigaOS programs, but
recommend using the new names clib/workbench_protos.h, defines/workbench.h,
inline/workbench.h, workbench_pragmas.h and proto/workbench.h instead.


Registers and CPUs
==================

AROS has put some effort in defining a way to write code which is hardware
independant. To achieve this, a couple of macros have been definied.

AROS_ASMSYMNAME(n)
    Use this macro to access the assembler symbol ``n`` from C.

AROS_CSYMNAME(n)
    Use this macro to access the C symbol ``n`` from assembler.

AROS_CDEFNAME(n) 
    Use this macro to define the assembler symbol ``n`` in such a 
    way that it can be accessed from C.

AROS_SLIB_ENTRY(n,l)
    Use this macro to get the name of a function ``n`` which is part of 
    the shared library ``l``.

AROS_UFH#(...) 
    Use this macro to declare a function which needs its arguments passed 
    in registers. ``"#"`` is the number of arguments the function
    expects. The parameters of the macro are the return type of the function,
    its name and the parameters in `AROS_UFHA()` macros. If the function is an
    assembler function, you must use the `AROS_ASMSYMNAME()` macro to get it's
    name.

AROS_UFHA(t,n,r)
    Use this macro to declare a parameter for a
    function which is declared with the AROS_UFH*() macro. It takes three
    arguments: The type of the parameter, the name of the parameter and the
    register the parameter is expected in.

AROS_UFC#(...)
    Call a function which needs its arguments in
    registers. Works the same way as AROS_UFH*().

AROS_LH#[I](...) 
    Use this macro to declare a function which is part
    of a shared library. "#" is the number of arguments the function expects.
    If the function doesn't need the library base passed, you can speed up
    things by appending "I" to the macros name. The parameters of the macro are
    the return type of the function, its name, the parameters in AROS_LHA()
    macros, the type of the library, the name of the variable the library base
    is passed in, the offset in the function table (1 is the first offset and 5
    is the first offset for a user function) and the name of the library.

AROS_LHA(t,n,r) 
    Use this macro to declare a parameter for a function
    which is declared with the AROS_LH*() macro. It takes three arguments:
    The type of the parameter, the name of the parameter and the register the
    parameter is expected in.

AROS_LC#[I](...)
    Call a function which is part of a shared library.
    Works the same way as AROS_LH*().

AROS_STACK_GROWS_DOWNWARDS 
    has the value 1 if it is true and 0 otherwise.

AROS_BIG_ENDIAN 
    has the value 1 if the machine is big endian (eg.
    Amiga) or little endian (eg. PCs). Endianess means the way a number is
    stored in memory. Amiga stores ``0x11223344`` as ``0x11 0x22 0x33 0x44`` in
    memory while a PC does it as ``0x44 0x33 0x22 0x11``.

AROS_SIZEOFULONG
    The result of ``sizeof(ULONG)``.

AROS_WORDALIGN
    The minimal alignment of 16bit numbers in the memory of computer 
    (`WORD` and `UWORD`).

AROS_LONGALIGN 
    The minimal alignment of 32bit numbers in the memory
    of computer (LONG and ULONG).

AROS_PTRALIGN 
    The minimal alignment of pointers in the memory of
    computer (eg. ``char *`` or APTR).

AROS_DOUBLEALIGN 
    The minimal alignment of 64bit IEEE floating point
    numbers in the memory of computer (``double``).

AROS_WORSTALIGN 
    The worst possible alignment of any data type in the
    memory of computer (mostly the same as `AROS_DOUBLEALIGN`).

AROS_ALIGN(x) 
    Get the next possible address where one can put any
    data type. This macro will return ``x`` if any data type can be put at ``x``.
    Most of the time, this macro is used like this: Get a buffer, put some data
    in it and then use `AROS_ALIGN()` to find out where the next data can be
    put.

AROS_SLOWSTACKTAGS
    is defined, if you must use `GetTagsFromStack()`
    and `FreeTagsFromStack()` instead of just passing the address of the tag of
    the first tagitem.

AROS_SLOWSTACKMETHODS 
    is defined, if you must use `GetMsgFromStack()` and `FreeMsgFromStack()` 
    instead of just passing the
    address of the method ID.

