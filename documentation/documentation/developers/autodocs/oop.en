===
oop
===

.. This document is automatically generated. Don't edit it!

`Index <index>`_

----------

======================================= ======================================= ======================================= ======================================= 
`OOP_AddClass()`_                       `OOP_DisposeObject()`_                  `OOP_FindClass()`_                      `OOP_GetAttr()`_                        
`OOP_GetAttrBase()`_                    `OOP_GetMethod()`_                      `OOP_GetMethodID()`_                    `OOP_NewObject()`_                      
`OOP_ObtainAttrBase()`_                 `OOP_ObtainAttrBases()`_                `OOP_ObtainAttrBasesArray()`_           `OOP_ObtainMethodBasesArray()`_         
`OOP_ParseAttrs()`_                     `OOP_ReleaseAttrBase()`_                `OOP_ReleaseAttrBases()`_               `OOP_ReleaseAttrBasesArray()`_          
`OOP_RemoveClass()`_                    `OOP_SetAttrs()`_                       
======================================= ======================================= ======================================= ======================================= 

-----------

OOP_AddClass()
==============

Synopsis
~~~~~~~~
::

 VOID OOP_AddClass(
          OOP_Class  * classPtr );

Function
~~~~~~~~
::

     Adds a class to the public list of classes.
     This means that any process can create objects of this
     class.


Inputs
~~~~~~
::

     classPtr - Pointer to the class to make public.


Result
~~~~~~
::

     None.


Bugs
~~~~
::

     Would be faster to use a hashtable to look up class IDs



See also
~~~~~~~~

`OOP_RemoveClass()`_ 

----------

OOP_DisposeObject()
===================

Synopsis
~~~~~~~~
::

 VOID OOP_DisposeObject(
          OOP_Object  * obj );

Function
~~~~~~~~
::

     Delete an object that was previously allocated with OOP_NewObject().


Inputs
~~~~~~
::

     obj     - pointer to object to dispose.


Result
~~~~~~
::

     None.



See also
~~~~~~~~

`OOP_NewObject()`_ 

----------

OOP_FindClass()
===============

Synopsis
~~~~~~~~
::

 APTR OOP_FindClass(
          CONST_STRPTR classID );

Function
~~~~~~~~
::

     Finds a class with given ID in the list of public classes.


Inputs
~~~~~~
::

     classID  - Public ID of the class to find.


Result
~~~~~~
::

     Pointer to a public class or NULL if there's no such class



See also
~~~~~~~~

`OOP_AddClass()`_ 

----------

OOP_GetAttr()
=============

Synopsis
~~~~~~~~
::

 IPTR OOP_GetAttr(
          OOP_Object             * object,
          OOP_AttrID attrID,
          IPTR           * storage );

Function
~~~~~~~~
::

     Gets the specifed attribute from the object,
     and puts it into storage.


Inputs
~~~~~~
::

     object  - pointer to object from which we want to
               get an attribute.
               
     attrID  - Attribute ID for property to get.
     
     storage - Pointer to IPTR the gitten data should be put
               into.



Result
~~~~~~
::

     Undefined.



See also
~~~~~~~~

`OOP_SetAttrs()`_ 

----------

OOP_GetAttrBase()
=================

Synopsis
~~~~~~~~
::

 OOP_AttrBase OOP_GetAttrBase(
          CONST_STRPTR interfaceID );

Function
~~~~~~~~
::

     Maps a globally unique string interface ID into
     a numeric AttrBase ID that is unique on
     pr. machine basis. IMPORTANT: You MUST
     be sure that at least one class implementing 
     specified interface is initialized at the time calling
     this function. This function is especially useful
     for a class to get AttrBases of the interfaces
     it implements.


Inputs
~~~~~~
::

     interfaceID     - globally unique interface identifier.


Result
~~~~~~
::

     Numeric AttrBase that is unique for this machine.
     There are NO error conditions.



----------

OOP_GetMethod()
===============

Synopsis
~~~~~~~~
::

 OOP_MethodFunc OOP_GetMethod(
          OOP_Object  * obj,
          OOP_MethodID mid,
          OOP_Class ** classPtr );

Function
~~~~~~~~
::

     Get a specific method function for a specific object and 
     a specific interface. This a direct pointer to the method implementation.
     The pointer should ONLY be used on the object you aquired.


Inputs
~~~~~~
::

     obj      - pointer to object to get method for.
     mid      - method id for method to get. This may be obtained with GetMethodID()
     classPtr - A pointer to a location where implementation class pointer will be stored.
                The obtained method must be called with this class pointer. This pointer
                is mandatory!


Result
~~~~~~
::

     The method asked for, or NULL if the method does not exist in
     the object's class.


Notes
~~~~~
::

     !!! Use with EXTREME CAUTION. Very few programs need the extra speed gained
         by calling a method directly 
     !!!



See also
~~~~~~~~

`OOP_GetMethodID()`_ 

----------

OOP_GetMethodID()
=================

Synopsis
~~~~~~~~
::

 OOP_MethodID OOP_GetMethodID(
          CONST_STRPTR interfaceID,
          ULONG methodOffset );

Function
~~~~~~~~
::

     Maps a globally unique full method ID
     (Interface ID + method offset) into
     a numeric method ID.


Inputs
~~~~~~
::

     interfaceID     - globally unique interface identifier.
     methodOffset    - offset to the method in this interface.
     


Result
~~~~~~
::

     Numeric method identifier that is unique for this machine.



----------

OOP_NewObject()
===============

Synopsis
~~~~~~~~
::

 APTR OOP_NewObject(
          struct OOP_IClass  * classPtr,
          CONST_STRPTR classID,
          struct TagItem * tagList );
 
 APTR OOP_NewObjectTags(
          struct OOP_IClass  * classPtr,
          CONST_STRPTR classID,
          TAG tag, ... );

Function
~~~~~~~~
::

     Creates a new object of given class based on the TagItem
     parameters passed.


Inputs
~~~~~~
::

     classPtr - pointer to a class. Use this if the class to
                create an instance of is private.
     classID  - Public ID of the class to create an instance of.
                Use this if the class is public.
     tagList  - List of TagItems (creation time attributes),
                that specifies what initial properties the new
                object should have.



Result
~~~~~~
::

     Pointer to the new object, or NULL if object creation failed.


Notes
~~~~~
::

     You should supply one of classPtr and classID, never
     both. Use NULL for the unspecified one.



See also
~~~~~~~~

`OOP_DisposeObject()`_ 

----------

OOP_ObtainAttrBase()
====================

Synopsis
~~~~~~~~
::

 OOP_AttrBase OOP_ObtainAttrBase(
          CONST_STRPTR interfaceID );

Function
~~~~~~~~
::

     Maps a globally unique string interface ID into
     a numeric AttrBase ID that is unique on a
     per machine basis. The AttrBase can be combined
     with attribute offsets to generate attribute IDs.


Inputs
~~~~~~
::

     interfaceID     - globally unique interface identifier.
                       for which to obtain an attrbase.


Result
~~~~~~
::

     Numeric AttrBase that is unique for this machine.
     A return value of 0 means that the call failed.


Example
~~~~~~~
::

     #define aTimer_CurrentTime    (__AB_Timer + aoTime_CurrentTime)
     
     ..
     __AB_Timer = OOP_ObtainAttrBase(IID_Timer);
     
     SetAttrs(timer, aTimer_CurrentTime, "10:37:00");
     


Notes
~~~~~
::

     Obtained attrbases should be released with ReleaseAttrBase().



----------

OOP_ObtainAttrBases()
=====================

Synopsis
~~~~~~~~
::

 BOOL OOP_ObtainAttrBases(
          const struct OOP_ABDescr * abd );


----------

OOP_ObtainAttrBasesArray()
==========================

Synopsis
~~~~~~~~
::

 ULONG OOP_ObtainAttrBasesArray(
          OOP_AttrBase * bases,
          CONST_STRPTR const * ids );

Function
~~~~~~~~
::

     Obtain several attribute base IDs, storing them in linear array.


Inputs
~~~~~~
::

     bases - a pointer to array to fill in
     ids   - a NULL-terminated array of interface IDs


Result
~~~~~~
::

     Zero on success or number of failed bases on failure. Failed
     entries will be set to 0.



See also
~~~~~~~~

`OOP_ReleaseAttrBasesArray()`_ 

----------

OOP_ObtainMethodBasesArray()
============================

Synopsis
~~~~~~~~
::

 ULONG OOP_ObtainMethodBasesArray(
          OOP_MethodID * bases,
          CONST_STRPTR const * ids );

Function
~~~~~~~~
::

     Obtain several method ID bases, storing them in linear array.


Inputs
~~~~~~
::

     bases - a pointer to array to fill in
     ids   - a NULL-terminated array of interface IDs


Result
~~~~~~
::

     Zero on success or number of failed bases on failure. Failed array
     entries will be set to -1.


Notes
~~~~~
::

     Method IDs are owned by particular class, and are released when
     the class is destroyed. Thus, there is no ReleaseMethodBasesArray()
     function.



----------

OOP_ParseAttrs()
================

Synopsis
~~~~~~~~
::

 LONG OOP_ParseAttrs(
          struct TagItem * tags,
          IPTR * storage,
          ULONG numattrs,
          OOP_AttrCheck * attrcheck,
          OOP_AttrBase attrbase );

Function
~~~~~~~~
::

     Parse a taglist of attributes and put the result in an array.
     It will only parse the attr from a single interface
     which is indicated by the 'attrbase' parameter.


Inputs
~~~~~~
::

     tags - tags to be parsed.
     storage - array where the tag values will be stored.
               To get the value for a certain tag just use
               ao#? attribute offset as an index into the array.
               The array must be of size 'numattrs', ie. the number
               of attributes in the interface.
               
     numattrs - number of attributes in the interface.
     attrcheck - will is a flag that where flags will be set according
                 to the attributes' offset. Since this is only 32
                 bytes you can only parse interfaces
                 with <= 32 attributes with this function.
                 If you try with more, you will get a
                 ooperr_ParseAttrs_TooManyAttrs error.
                 The flags will be set like this if an attr is found:
                 
                 attrcheck |= 1L << attribute_offset
                 
     attrbase - attrbase for the interface whise attrs we should look for.
                 


Result
~~~~~~
::

     0 for success, and an error otherwise.
     Possible values are:
             ooperr_ParseAttrs_TooManyAttrs.



----------

OOP_ReleaseAttrBase()
=====================

Synopsis
~~~~~~~~
::

 VOID OOP_ReleaseAttrBase(
          CONST_STRPTR interfaceID );

Function
~~~~~~~~
::

     Release an OOP_AttrBase previosly obtained with
     OOP_ObtainAttrBase()
     


Inputs
~~~~~~
::

     interfaceID     - globally unique interface identifier.
                       for which to release an attrbase.


Result
~~~~~~
::

     None.


Notes
~~~~~
::

     The call must be paired with OOP_ObtainAttrBase().



----------

OOP_ReleaseAttrBases()
======================

Synopsis
~~~~~~~~
::

 VOID OOP_ReleaseAttrBases(
          const struct OOP_ABDescr * abd );


----------

OOP_ReleaseAttrBasesArray()
===========================

Synopsis
~~~~~~~~
::

 void OOP_ReleaseAttrBasesArray(
          OOP_AttrBase * bases,
          CONST_STRPTR const * ids );

Function
~~~~~~~~
::

     Release several attribute ID bases, stored in linear array.


Inputs
~~~~~~
::

     bases - a pointer to array of bases
     ids   - a NULL-terminated array of corresponding interface IDs


Result
~~~~~~
::

     None


Notes
~~~~~
::

     It is legal to have some entries in the array not filled in
     (equal to 0). They will be skipped.



See also
~~~~~~~~

`OOP_ObtainAttrBasesArray()`_ 

----------

OOP_RemoveClass()
=================

Synopsis
~~~~~~~~
::

 void OOP_RemoveClass(
          OOP_Class * classPtr );

Function
~~~~~~~~
::

     Remove a class from the list of public classes.
     The class must have previously added with AddClass().
     

Inputs
~~~~~~
::

     classPtr - Pointer to class that should be removed.


Result
~~~~~~
::

     None.



See also
~~~~~~~~

`OOP_AddClass()`_ 

----------

OOP_SetAttrs()
==============

Synopsis
~~~~~~~~
::

 IPTR OOP_SetAttrs(
          OOP_Object     * object,
          struct TagItem * attrList );
 
 IPTR OOP_SetAttrsTags(
          OOP_Object     * object,
          TAG tag, ... );

Function
~~~~~~~~
::

     Sets the object's attributes as specified in the
     supplied taglist.


Inputs
~~~~~~
::

     object  - pointer to a object in whih we
               want to set attributes.
              
     tagList -  List of attributes an their new values.



Result
~~~~~~
::

     Undefined.



See also
~~~~~~~~

`OOP_DisposeObject()`_ 

