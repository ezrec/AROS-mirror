/* 
 * Copyright (C) 2002 the xine project
 * 
 * This file is part of xine, a unix video player.
 * 
 * xine is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * xine is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
 *
 * $Id$
 */

#define FAST_MC

#include <stdio.h>
#include <stdlib.h>

#if defined(__AROS__)
#include <string.h>
#endif

#include "svq1_codebooks.h"

#define MEDIAN(a,b,c)    ((a < b != b >= c) ? b : ((a < c != c > b) ? c : a))
#define be2me_32(x)      (x)

#define SVQ1_BLOCK_SKIP       0
#define SVQ1_BLOCK_INTER 1
#define SVQ1_BLOCK_INTER_4V   2
#define SVQ1_BLOCK_INTRA 3

#define SVQ1_FRAME_INTRA 0
#define SVQ1_FRAME_INTER 1
#define SVQ1_FRAME_DROPPABLE  2


#ifdef FAST_MC

#define MASK7F 0x7f7f7f7f

#define AVG2(a, b) \
  ((a) | (b)) - ((((a) ^ (b)) >> 1) & M7F)

#define AVG4(a, b, c, d) \
  AVG2((AVG2(a, b)), (AVG2(c, d)))

#define LONG(var, offset) *(unsigned long *)(var + offset)

void MC_put_8_c (uint8_t * dest, uint8_t * ref, int stride, int height)
{
    unsigned long a, b;

    do {
     a = LONG(ref,  0);
     b = LONG(ref,  4);

     LONG(dest,  0) = a;
     LONG(dest,  4) = b;

     ref += stride;
     dest += stride;
    } while (--height);
}

void MC_put_16_c (uint8_t * dest, uint8_t * ref, int stride, int height)
{
    unsigned long a, b, c, d;

    do {
     a = LONG(ref,  0);
     b = LONG(ref,  4);
     c = LONG(ref,  8);
     d = LONG(ref, 12);

     LONG(dest,  0) = a;
     LONG(dest,  4) = b;
     LONG(dest,  8) = c;
     LONG(dest, 12) = d;

     ref += stride;
     dest += stride;
    } while (--height);
}

void MC_put_x8_c (uint8_t * dest, uint8_t * ref, int stride, int height)
{
    unsigned long a, b, c, d, M7F = MASK7F;

    do {
     a = LONG(ref,  0);
     b = LONG(ref,  4);

     c = LONG(ref,  1);
     d = LONG(ref,  5);

     LONG(dest,  0) = AVG2(a, c);
     LONG(dest,  4) = AVG2(b, d);

     ref += stride;
     dest += stride;
    } while (--height);
}

void MC_put_x16_c (uint8_t * dest, uint8_t * ref, int stride, int height)
{
    unsigned long a, b, c, d, M7F = MASK7F;

    do {
     a = LONG(ref,  0);
     b = LONG(ref,  4);

     c = LONG(ref,  1);
     d = LONG(ref,  5);

     LONG(dest,  0) = AVG2(a, c);
     LONG(dest,  4) = AVG2(b, d);

     a = LONG(ref,  8);
     b = LONG(ref, 12);

     c = LONG(ref,  9);
     d = LONG(ref, 13);

     LONG(dest,  8) = AVG2(a, c);
     LONG(dest, 12) = AVG2(b, d);

     ref += stride;
     dest += stride;
    } while (--height);
}

void MC_put_y8_c (uint8_t * dest, uint8_t * ref, int stride, int height)
{
    unsigned long a, b, c, d, M7F = MASK7F;

    do {
     a = LONG(ref,  0);
     b = LONG(ref,  4);
     c = LONG(ref + stride,  0);
     d = LONG(ref + stride,  4);

     LONG(dest,  0) = AVG2(a, c);
     LONG(dest,  4) = AVG2(b, d);

     ref += stride;
     dest += stride;
    } while (--height);
}

void MC_put_y16_c (uint8_t * dest, uint8_t * ref, int stride, int height)
{
    unsigned long a, b, c, d, e, f, g, h, M7F = MASK7F;

    do {
     a = LONG(ref,  0);
     b = LONG(ref,  4);
     c = LONG(ref,  8);
     d = LONG(ref, 12);
     e = LONG(ref + stride,  0);
     f = LONG(ref + stride,  4);
     g = LONG(ref + stride,  8);
     h = LONG(ref + stride, 12);

     LONG(dest,  0) = AVG2(a, e);
     LONG(dest,  4) = AVG2(b, f);
     LONG(dest,  8) = AVG2(c, g);
     LONG(dest, 12) = AVG2(d, h);

     ref += stride;
     dest += stride;
    } while (--height);
}

void MC_put_xy8_c (uint8_t * dest, uint8_t * ref, int stride, int height)
{
    unsigned long a, b, c, d, e, f, g, h, M7F = MASK7F;

    do {
     a = LONG(ref,  0);
     b = LONG(ref,  1);
     c = LONG(ref,  4);
     d = LONG(ref,  5);

     e = LONG(ref + stride,  0);
     f = LONG(ref + stride,  1);
     g = LONG(ref + stride,  4);
     h = LONG(ref + stride,  5);

     LONG(dest,  0) = AVG4(a, b, e, f);
     LONG(dest,  4) = AVG4(c, d, g, h);

     ref += stride;
     dest += stride;
    } while (--height);
}

void MC_put_xy16_c (uint8_t * dest, uint8_t * ref, int stride, int height)
{
    unsigned long a, b, c, d, e, f, g, h, M7F = MASK7F;

    do {
     a = LONG(ref,  0);
     b = LONG(ref,  1);
     c = LONG(ref,  4);
     d = LONG(ref,  5);

     e = LONG(ref + stride,  0);
     f = LONG(ref + stride,  1);
     g = LONG(ref + stride,  4);
     h = LONG(ref + stride,  5);

     LONG(dest,  0) = AVG4(a, b, e, f);
     LONG(dest,  4) = AVG4(c, d, g, h);

     a = LONG(ref,  8);
     b = LONG(ref,  9);
     c = LONG(ref, 12);
     d = LONG(ref, 13);

     e = LONG(ref + stride,  8);
     f = LONG(ref + stride,  9);
     g = LONG(ref + stride, 12);
     h = LONG(ref + stride, 13);

     LONG(dest,  8) = AVG4(a, b, e, f);
     LONG(dest, 12) = AVG4(c, d, g, h);

     ref += stride;
     dest += stride;
    } while (--height);
}

static void (*motion_put[8]) (uint8_t *dst, uint8_t *, int32_t, int32_t) = {
  MC_put_16_c, MC_put_x16_c, MC_put_y16_c, MC_put_xy16_c,
  MC_put_8_c,  MC_put_x8_c,  MC_put_y8_c,  MC_put_xy8_c,
};

#endif


/* memory bit stream */
typedef struct bit_buffer_s {
  uint8_t *buffer;
  uint32_t      bitpos;
} bit_buffer_t;

/* variable length (bit) code */
typedef struct vlc_code_s {
  int16_t  value    :10,
           length   :6;
} vlc_code_t;

/* motion vector (prediction) */
typedef struct svq1_pmv_s {
  int           x;
  int           y;
} svq1_pmv_t;

typedef struct svq1_s {
  int           frame_code;
  int           frame_type;
  int           frame_width;
  int           frame_height;
  int           luma_width;
  int           luma_height;
  int           chroma_width;
  int           chroma_height;
  svq1_pmv_t   *motion;
  uint8_t *current;
  uint8_t *previous;
  int           offsets[3];
  int           reference_frame;
 
  uint8_t *base[3];
  int           width;
  int           height;
} svq1_t;


/* standard video sizes */
static struct { int width; int height; } frame_size_table[8] = {
  { 160, 120 }, { 128,  96 }, { 176, 144 }, { 352, 288 },
  { 704, 576 }, { 240, 180 }, { 320, 240 }, {  -1,  -1 }
};

/* block type, codes 000 .. 1xx */
static vlc_code_t block_type_table[8] = {
  { SVQ1_BLOCK_INTRA, 3 }, { SVQ1_BLOCK_INTER_4V, 3 },
  { SVQ1_BLOCK_INTER, 2 }, { SVQ1_BLOCK_INTER,    2 },
  { SVQ1_BLOCK_SKIP,  1 }, { SVQ1_BLOCK_SKIP,     1 },
  { SVQ1_BLOCK_SKIP,  1 }, { SVQ1_BLOCK_SKIP,     1 }
};

/* motion vector, codes 0000011 .. 011xxxx */
static vlc_code_t motion_table_0[61] = {
  { 7, 8 }, { 6, 8 }, { 5, 8 }, { 4, 7 }, { 4, 7 },
  { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 },
  { 2, 4 }, { 2, 4 }, { 2, 4 }, { 2, 4 }, { 2, 4 }, { 2, 4 }, { 2, 4 }, { 2, 4 },
  { 2, 4 }, { 2, 4 }, { 2, 4 }, { 2, 4 }, { 2, 4 }, { 2, 4 }, { 2, 4 }, { 2, 4 },
  { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 },
  { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 },
  { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 },
  { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }
};

/* motion vector, codes 000000000010 ... 0000010111xx */
static vlc_code_t motion_table_1[94] = {
  {32, 13}, {31, 13}, {30, 12}, {30, 12}, {29, 12}, {29, 12},
  {28, 12}, {28, 12}, {27, 12}, {27, 12}, {26, 12}, {26, 12}, {25, 12}, {25, 12},
  {24, 11}, {24, 11}, {24, 11}, {24, 11}, {23, 11}, {23, 11}, {23, 11}, {23, 11},
  {22, 11}, {22, 11}, {22, 11}, {22, 11}, {21, 11}, {21, 11}, {21, 11}, {21, 11},
  {20, 11}, {20, 11}, {20, 11}, {20, 11}, {19, 11}, {19, 11}, {19, 11}, {19, 11},
  {18, 11}, {18, 11}, {18, 11}, {18, 11}, {17, 11}, {17, 11}, {17, 11}, {17, 11},
  {16, 11}, {16, 11}, {16, 11}, {16, 11}, {15, 11}, {15, 11}, {15, 11}, {15, 11},
  {14, 11}, {14, 11}, {14, 11}, {14, 11}, {13, 11}, {13, 11}, {13, 11}, {13, 11},
  {12, 11}, {12, 11}, {12, 11}, {12, 11}, {11, 11}, {11, 11}, {11, 11}, {11, 11},
  {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10},
  { 9, 10}, { 9, 10}, { 9, 10}, { 9, 10}, { 9, 10}, { 9, 10}, { 9, 10}, { 9, 10},
  { 8, 10}, { 8, 10}, { 8, 10}, { 8, 10}, { 8, 10}, { 8, 10}, { 8, 10}, { 8, 10},
};

/* inter-coded vector codebook count tables, codes 000000 ... 111111 */
static vlc_code_t inter_vector_tables[6][64] = {
  /* 4x2 vector, codes 0000xxx ... 11xxxxx */
  { { 6, 4 }, { 6, 4 }, { 6, 4 }, { 6, 4 }, { 5, 4 }, { 5, 4 }, { 5, 4 }, { 5, 4 },
    { 4, 3 }, { 4, 3 }, { 4, 3 }, { 4, 3 }, { 4, 3 }, { 4, 3 }, { 4, 3 }, { 4, 3 },
    { 3, 3 }, { 3, 3 }, { 3, 3 }, { 3, 3 }, { 3, 3 }, { 3, 3 }, { 3, 3 }, { 3, 3 },
    { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 },
    { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 },
    { 0, 3 }, { 0, 3 }, { 0, 3 }, { 0, 3 }, { 0, 3 }, { 0, 3 }, { 0, 3 }, { 0, 3 },
    {-1, 2 }, {-1, 2 }, {-1, 2 }, {-1, 2 }, {-1, 2 }, {-1, 2 }, {-1, 2 }, {-1, 2 },
    {-1, 2 }, {-1, 2 }, {-1, 2 }, {-1, 2 }, {-1, 2 }, {-1, 2 }, {-1, 2 }, {-1, 2 } },

  /* 4x4 vector, codes 0000xxx ... 11xxxxx */
  { { 6, 4 }, { 6, 4 }, { 6, 4 }, { 6, 4 }, { 5, 4 }, { 5, 4 }, { 5, 4 }, { 5, 4 },
    { 4, 3 }, { 4, 3 }, { 4, 3 }, { 4, 3 }, { 4, 3 }, { 4, 3 }, { 4, 3 }, { 4, 3 },
    { 3, 3 }, { 3, 3 }, { 3, 3 }, { 3, 3 }, { 3, 3 }, { 3, 3 }, { 3, 3 }, { 3, 3 },
    { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 },
    { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 },
    { 0, 3 }, { 0, 3 }, { 0, 3 }, { 0, 3 }, { 0, 3 }, { 0, 3 }, { 0, 3 }, { 0, 3 },
    {-1, 2 }, {-1, 2 }, {-1, 2 }, {-1, 2 }, {-1, 2 }, {-1, 2 }, {-1, 2 }, {-1, 2 },
    {-1, 2 }, {-1, 2 }, {-1, 2 }, {-1, 2 }, {-1, 2 }, {-1, 2 }, {-1, 2 }, {-1, 2 } },

  /* 8x4 vector, codes 00000xx ... 1xxxxxx */
  { { 6, 5 }, { 6, 5 }, { 5, 5 }, { 5, 5 }, { 4, 4 }, { 4, 4 }, { 4, 4 }, { 4, 4 },
    { 3, 4 }, { 3, 4 }, { 3, 4 }, { 3, 4 }, { 2, 4 }, { 2, 4 }, { 2, 4 }, { 2, 4 },
    { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 },
    { 0, 3 }, { 0, 3 }, { 0, 3 }, { 0, 3 }, { 0, 3 }, { 0, 3 }, { 0, 3 }, { 0, 3 },
    {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 },
    {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 },
    {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 },
    {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 } },

  /* 8x8 vector, codes 00000xx ... 1xxxxxx */
  { { 6, 5 }, { 6, 5 }, { 5, 5 }, { 5, 5 }, { 4, 4 }, { 4, 4 }, { 4, 4 }, { 4, 4 },
    { 3, 4 }, { 3, 4 }, { 3, 4 }, { 3, 4 }, { 2, 4 }, { 2, 4 }, { 2, 4 }, { 2, 4 },
    { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 },
    { 0, 3 }, { 0, 3 }, { 0, 3 }, { 0, 3 }, { 0, 3 }, { 0, 3 }, { 0, 3 }, { 0, 3 },
    {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 },
    {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 },
    {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 },
    {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 } },

  /* 16x8 vector, codes 00000xx ... 1xxxxxx */
  { { 6, 5 }, { 6, 5 }, { 5, 5 }, { 5, 5 }, { 4, 4 }, { 4, 4 }, { 4, 4 }, { 4, 4 },
    { 3, 4 }, { 3, 4 }, { 3, 4 }, { 3, 4 }, { 2, 4 }, { 2, 4 }, { 2, 4 }, { 2, 4 },
    { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 },
    { 0, 3 }, { 0, 3 }, { 0, 3 }, { 0, 3 }, { 0, 3 }, { 0, 3 }, { 0, 3 }, { 0, 3 },
    {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 },
    {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 },
    {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 },
    {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 } },

  /* 16x16 vector, codes 000000x ... 1xxxxxx */
  { { 6, 6 }, { 5, 6 }, { 4, 5 }, { 4, 5 }, { 3, 5 }, { 3, 5 }, { 2, 5 }, { 2, 5 },
    { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 },
    { 0, 2 }, { 0, 2 }, { 0, 2 }, { 0, 2 }, { 0, 2 }, { 0, 2 }, { 0, 2 }, { 0, 2 },
    { 0, 2 }, { 0, 2 }, { 0, 2 }, { 0, 2 }, { 0, 2 }, { 0, 2 }, { 0, 2 }, { 0, 2 },
    {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 },
    {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 },
    {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 },
    {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 }, {-1, 1 } }
};

/* vector codebook count tables, codes 0000000 ... 1111111 */
static vlc_code_t intra_vector_tables[6][128] = {
  /* 4x2 vector, codes 00000xx ... 1xxxxxx */
  { { 5, 5 }, { 5, 5 }, { 5, 5 }, { 5, 5 }, {-1, 5 }, {-1, 5 }, {-1, 5 }, {-1, 5 },
    { 6, 4 }, { 6, 4 }, { 6, 4 }, { 6, 4 }, { 6, 4 }, { 6, 4 }, { 6, 4 }, { 6, 4 },
    { 4, 4 }, { 4, 4 }, { 4, 4 }, { 4, 4 }, { 4, 4 }, { 4, 4 }, { 4, 4 }, { 4, 4 },
    { 3, 4 }, { 3, 4 }, { 3, 4 }, { 3, 4 }, { 3, 4 }, { 3, 4 }, { 3, 4 }, { 3, 4 },
    { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 },
    { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 },
    { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 },
    { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 } },

  /* 4x4 vector, codes 0000xxx ... 11xxxxx */
  { { 5, 4 }, { 5, 4 }, { 5, 4 }, { 5, 4 }, { 5, 4 }, { 5, 4 }, { 5, 4 }, { 5, 4 },
    {-1, 4 }, {-1, 4 }, {-1, 4 }, {-1, 4 }, {-1, 4 }, {-1, 4 }, {-1, 4 }, {-1, 4 },
    { 6, 3 }, { 6, 3 }, { 6, 3 }, { 6, 3 }, { 6, 3 }, { 6, 3 }, { 6, 3 }, { 6, 3 },
    { 6, 3 }, { 6, 3 }, { 6, 3 }, { 6, 3 }, { 6, 3 }, { 6, 3 }, { 6, 3 }, { 6, 3 },
    { 4, 3 }, { 4, 3 }, { 4, 3 }, { 4, 3 }, { 4, 3 }, { 4, 3 }, { 4, 3 }, { 4, 3 },
    { 4, 3 }, { 4, 3 }, { 4, 3 }, { 4, 3 }, { 4, 3 }, { 4, 3 }, { 4, 3 }, { 4, 3 },
    { 3, 3 }, { 3, 3 }, { 3, 3 }, { 3, 3 }, { 3, 3 }, { 3, 3 }, { 3, 3 }, { 3, 3 },
    { 3, 3 }, { 3, 3 }, { 3, 3 }, { 3, 3 }, { 3, 3 }, { 3, 3 }, { 3, 3 }, { 3, 3 },
    { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 },
    { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 },
    { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 },
    { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 },
    { 0, 2 }, { 0, 2 }, { 0, 2 }, { 0, 2 }, { 0, 2 }, { 0, 2 }, { 0, 2 }, { 0, 2 },
    { 0, 2 }, { 0, 2 }, { 0, 2 }, { 0, 2 }, { 0, 2 }, { 0, 2 }, { 0, 2 }, { 0, 2 },
    { 0, 2 }, { 0, 2 }, { 0, 2 }, { 0, 2 }, { 0, 2 }, { 0, 2 }, { 0, 2 }, { 0, 2 },
    { 0, 2 }, { 0, 2 }, { 0, 2 }, { 0, 2 }, { 0, 2 }, { 0, 2 }, { 0, 2 }, { 0, 2 } },

  /* 8x4 vector, codes 00000xx ... 1xxxxxx */
  { { 2, 5 }, { 2, 5 }, { 2, 5 }, { 2, 5 }, {-1, 5 }, {-1, 5 }, {-1, 5 }, {-1, 5 },
    { 6, 4 }, { 6, 4 }, { 6, 4 }, { 6, 4 }, { 6, 4 }, { 6, 4 }, { 6, 4 }, { 6, 4 },
    { 5, 4 }, { 5, 4 }, { 5, 4 }, { 5, 4 }, { 5, 4 }, { 5, 4 }, { 5, 4 }, { 5, 4 },
    { 3, 4 }, { 3, 4 }, { 3, 4 }, { 3, 4 }, { 3, 4 }, { 3, 4 }, { 3, 4 }, { 3, 4 },
    { 4, 3 }, { 4, 3 }, { 4, 3 }, { 4, 3 }, { 4, 3 }, { 4, 3 }, { 4, 3 }, { 4, 3 },
    { 4, 3 }, { 4, 3 }, { 4, 3 }, { 4, 3 }, { 4, 3 }, { 4, 3 }, { 4, 3 }, { 4, 3 },
    { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 },
    { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 }, { 1, 3 },  
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 } },

  /* 8x8 vector, codes 000000x ... 1xxxxxx */
  { { 2, 6 }, { 2, 6 }, {-1, 6 }, {-1, 6 }, { 5, 5 }, { 5, 5 }, { 5, 5 }, { 5, 5 },
    { 6, 4 }, { 6, 4 }, { 6, 4 }, { 6, 4 }, { 6, 4 }, { 6, 4 }, { 6, 4 }, { 6, 4 },
    { 4, 4 }, { 4, 4 }, { 4, 4 }, { 4, 4 }, { 4, 4 }, { 4, 4 }, { 4, 4 }, { 4, 4 },
    { 3, 4 }, { 3, 4 }, { 3, 4 }, { 3, 4 }, { 3, 4 }, { 3, 4 }, { 3, 4 }, { 3, 4 },
    { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 },
    { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 },
    { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 },
    { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 } },

  /* 16x8 vector, codes 000000x ... 1xxxxxx */
  { { 4, 6 }, { 4, 6 }, {-1, 6 }, {-1, 6 }, { 5, 5 }, { 5, 5 }, { 5, 5 }, { 5, 5 },
    { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 2, 5 }, { 2, 5 }, { 2, 5 }, { 2, 5 },
    { 6, 3 }, { 6, 3 }, { 6, 3 }, { 6, 3 }, { 6, 3 }, { 6, 3 }, { 6, 3 }, { 6, 3 },
    { 6, 3 }, { 6, 3 }, { 6, 3 }, { 6, 3 }, { 6, 3 }, { 6, 3 }, { 6, 3 }, { 6, 3 },
    { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 },
    { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 },
    { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 },
    { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 } },

  /* 16x16 vector, codes 0000000 ... 1xxxxxx */
  { { 5, 7 }, {-1, 7 }, { 4, 6 }, { 4, 6 }, { 6, 5 }, { 6, 5 }, { 6, 5 }, { 6, 5 },
    { 3, 4 }, { 3, 4 }, { 3, 4 }, { 3, 4 }, { 3, 4 }, { 3, 4 }, { 3, 4 }, { 3, 4 },
    { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 },
    { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 }, { 2, 3 },
    { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 },
    { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 },
    { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 },
    { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 }, { 1, 2 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 },
    { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 } }
};

/* intra mean value, codes 00100101 ... 1111xxxx */
static vlc_code_t intra_mean_table_0[219] = {
  {135, 8 }, {136, 8 }, {165, 8 },
  {134, 8 }, {129, 8 }, {164, 8 }, {163, 8 }, {133, 8 }, {162, 8 }, {174, 8 }, {175, 8 },
  {161, 8 }, {160, 8 }, {159, 8 }, {158, 8 }, {157, 8 }, {156, 8 }, {155, 8 }, {154, 8 },
  {153, 8 }, {151, 8 }, {152, 8 }, {132, 8 }, {110, 8 }, {131, 8 }, {108, 8 }, {130, 8 },
  {166, 8 }, {105, 8 }, {104, 8 }, {103, 8 }, {127, 8 }, {101, 8 }, {167, 8 }, {168, 8 },
  { 98, 8 }, {128, 8 }, { 48, 8 }, { 95, 8 }, { 62, 8 }, { 93, 8 }, { 92, 8 }, { 91, 8 },
  { 90, 8 }, { 89, 8 }, { 60, 8 }, { 87, 8 }, { 86, 8 }, { 57, 8 }, { 84, 8 }, { 83, 8 },
  { 82, 8 }, { 81, 8 }, { 80, 8 }, { 79, 8 }, { 78, 8 }, { 77, 8 }, { 76, 8 }, { 75, 8 },
  { 74, 8 }, { 73, 8 }, { 72, 8 }, { 71, 8 }, { 70, 8 }, { 69, 8 }, { 68, 8 }, { 67, 8 },
  { 66, 8 }, { 65, 8 }, { 56, 8 }, { 63, 8 }, { 23, 8 }, { 61, 8 }, { 30, 8 }, { 59, 8 },
  { 58, 8 }, { 52, 8 }, { 29, 8 }, { 55, 8 }, { 54, 8 }, { 53, 8 }, { 50, 8 }, { 51, 8 },
  { 22, 8 }, { 49, 8 }, { 85, 7 }, { 85, 7 }, { 97, 7 }, { 97, 7 }, { 88, 7 }, { 88, 7 },
  { 64, 7 }, { 64, 7 }, { 94, 7 }, { 94, 7 }, {106, 7 }, {106, 7 }, {107, 7 }, {107, 7 },
  {109, 7 }, {109, 7 }, {111, 7 }, {111, 7 }, {112, 7 }, {112, 7 }, {113, 7 }, {113, 7 },
  {114, 7 }, {114, 7 }, {115, 7 }, {115, 7 }, {116, 7 }, {116, 7 }, {117, 7 }, {117, 7 },
  {118, 7 }, {118, 7 }, {119, 7 }, {119, 7 }, {120, 7 }, {120, 7 }, { 99, 7 }, { 99, 7 },
  {102, 7 }, {102, 7 }, { 28, 7 }, { 28, 7 }, {100, 7 }, {100, 7 }, { 96, 7 }, { 96, 7 },
  {139, 7 }, {139, 7 }, { 24, 7 }, { 24, 7 }, {  1, 7 }, {  1, 7 }, {138, 7 }, {138, 7 },
  {121, 7 }, {121, 7 }, {122, 7 }, {122, 7 }, {123, 7 }, {123, 7 }, {124, 7 }, {124, 7 },
  {125, 7 }, {125, 7 }, {126, 7 }, {126, 7 }, {137, 7 }, {137, 7 }, {140, 7 }, {140, 7 },
  {150, 7 }, {150, 7 }, {144, 7 }, {144, 7 }, {141, 7 }, {141, 7 }, {142, 7 }, {142, 7 },
  {143, 7 }, {143, 7 }, {145, 7 }, {145, 7 }, {147, 7 }, {147, 7 }, {146, 7 }, {146, 7 },
  { 27, 6 }, { 27, 6 }, { 27, 6 }, { 27, 6 }, {148, 6 }, {148, 6 }, {148, 6 }, {148, 6 },
  {149, 6 }, {149, 6 }, {149, 6 }, {149, 6 }, {  0, 6 }, {  0, 6 }, {  0, 6 }, {  0, 6 },
  { 26, 4 }, { 26, 4 }, { 26, 4 }, { 26, 4 }, { 26, 4 }, { 26, 4 }, { 26, 4 }, { 26, 4 },
  { 26, 4 }, { 26, 4 }, { 26, 4 }, { 26, 4 }, { 26, 4 }, { 26, 4 }, { 26, 4 }, { 26, 4 },
  { 25, 4 }, { 25, 4 }, { 25, 4 }, { 25, 4 }, { 25, 4 }, { 25, 4 }, { 25, 4 }, { 25, 4 },
  { 25, 4 }, { 25, 4 }, { 25, 4 }, { 25, 4 }, { 25, 4 }, { 25, 4 }, { 25, 4 }, { 25, 4 }
};

/* intra mean value, codes 0000001101 ... 001001001x */
static vlc_code_t intra_mean_table_1[135] = {
  {218, 10}, {219, 10}, {220, 10},
  {221, 10}, {222, 10}, {217, 10}, {230, 10}, {215, 10}, {208, 10}, {207, 10}, {206, 10},
  {214, 10}, {204, 10}, {223, 10}, {224, 10}, {225, 10}, {226, 10}, {227, 10}, {228, 10},
  {229, 10}, {213, 10}, {212, 10}, {231, 10}, {232, 10}, {211, 10}, {210, 10}, {236, 10},
  {209, 10}, {216, 10}, {205, 10}, { 18, 10}, {186, 9 }, {186, 9 }, {185, 9 }, {185, 9 },
  {184, 9 }, {184, 9 }, {182, 9 }, {182, 9 }, {183, 9 }, {183, 9 }, {180, 9 }, {180, 9 },
  {181, 9 }, {181, 9 }, {178, 9 }, {178, 9 }, {187, 9 }, {187, 9 }, {176, 9 }, {176, 9 },
  {188, 9 }, {188, 9 }, {179, 9 }, {179, 9 }, {173, 9 }, {173, 9 }, {172, 9 }, {172, 9 },
  {171, 9 }, {171, 9 }, {170, 9 }, {170, 9 }, {169, 9 }, {169, 9 }, {189, 9 }, {189, 9 },
  {190, 9 }, {190, 9 }, {191, 9 }, {191, 9 }, {192, 9 }, {192, 9 }, {193, 9 }, {193, 9 },
  {194, 9 }, {194, 9 }, {195, 9 }, {195, 9 }, {196, 9 }, {196, 9 }, {197, 9 }, {197, 9 },
  {198, 9 }, {198, 9 }, {200, 9 }, {200, 9 }, {201, 9 }, {201, 9 }, {202, 9 }, {202, 9 },
  {203, 9 }, {203, 9 }, {199, 9 }, {199, 9 }, {177, 9 }, {177, 9 }, { 40, 9 }, { 40, 9 },
  { 39, 9 }, { 39, 9 }, { 38, 9 }, { 38, 9 }, { 37, 9 }, { 37, 9 }, { 36, 9 }, { 36, 9 },
  { 35, 9 }, { 35, 9 }, { 34, 9 }, { 34, 9 }, { 33, 9 }, { 33, 9 }, { 32, 9 }, { 32, 9 },
  { 31, 9 }, { 31, 9 }, { 21, 9 }, { 21, 9 }, { 11, 9 }, { 11, 9 }, { 41, 9 }, { 41, 9 },
  { 45, 9 }, { 45, 9 }, { 44, 9 }, { 44, 9 }, { 42, 9 }, { 42, 9 }, { 43, 9 }, { 43, 9 },
  { 47, 9 }, { 47, 9 }, { 46, 9 }, { 46, 9 }
};

/* intra mean value, codes 00000000000001 ... 00000011001xxx */
static vlc_code_t intra_mean_table_2[207] = {
  {255, 14}, { 14, 14}, { 13, 14}, { 17, 12}, { 17, 12}, { 17, 12}, { 17, 12},
  {243, 11}, {243, 11}, {243, 11}, {243, 11}, {243, 11}, {243, 11}, {243, 11}, {243, 11},
  {242, 11}, {242, 11}, {242, 11}, {242, 11}, {242, 11}, {242, 11}, {242, 11}, {242, 11},
  {241, 11}, {241, 11}, {241, 11}, {241, 11}, {241, 11}, {241, 11}, {241, 11}, {241, 11},
  {240, 11}, {240, 11}, {240, 11}, {240, 11}, {240, 11}, {240, 11}, {240, 11}, {240, 11},
  {237, 11}, {237, 11}, {237, 11}, {237, 11}, {237, 11}, {237, 11}, {237, 11}, {237, 11},
  {239, 11}, {239, 11}, {239, 11}, {239, 11}, {239, 11}, {239, 11}, {239, 11}, {239, 11},
  {235, 11}, {235, 11}, {235, 11}, {235, 11}, {235, 11}, {235, 11}, {235, 11}, {235, 11},
  {234, 11}, {234, 11}, {234, 11}, {234, 11}, {234, 11}, {234, 11}, {234, 11}, {234, 11},
  {233, 11}, {233, 11}, {233, 11}, {233, 11}, {233, 11}, {233, 11}, {233, 11}, {233, 11},
  {244, 11}, {244, 11}, {244, 11}, {244, 11}, {244, 11}, {244, 11}, {244, 11}, {244, 11},
  {238, 11}, {238, 11}, {238, 11}, {238, 11}, {238, 11}, {238, 11}, {238, 11}, {238, 11},
  { 20, 11}, { 20, 11}, { 20, 11}, { 20, 11}, { 20, 11}, { 20, 11}, { 20, 11}, { 20, 11},
  {248, 11}, {248, 11}, {248, 11}, {248, 11}, {248, 11}, {248, 11}, {248, 11}, {248, 11},
  {249, 11}, {249, 11}, {249, 11}, {249, 11}, {249, 11}, {249, 11}, {249, 11}, {249, 11},
  {250, 11}, {250, 11}, {250, 11}, {250, 11}, {250, 11}, {250, 11}, {250, 11}, {250, 11},
  {251, 11}, {251, 11}, {251, 11}, {251, 11}, {251, 11}, {251, 11}, {251, 11}, {251, 11},
  {252, 11}, {252, 11}, {252, 11}, {252, 11}, {252, 11}, {252, 11}, {252, 11}, {252, 11},
  {253, 11}, {253, 11}, {253, 11}, {253, 11}, {253, 11}, {253, 11}, {253, 11}, {253, 11},
  {254, 11}, {254, 11}, {254, 11}, {254, 11}, {254, 11}, {254, 11}, {254, 11}, {254, 11},
  { 12, 11}, { 12, 11}, { 12, 11}, { 12, 11}, { 12, 11}, { 12, 11}, { 12, 11}, { 12, 11},
  { 10, 11}, { 10, 11}, { 10, 11}, { 10, 11}, { 10, 11}, { 10, 11}, { 10, 11}, { 10, 11},
  {245, 11}, {245, 11}, {245, 11}, {245, 11}, {245, 11}, {245, 11}, {245, 11}, {245, 11},
  {247, 11}, {247, 11}, {247, 11}, {247, 11}, {247, 11}, {247, 11}, {247, 11}, {247, 11},
  { 19, 11}, { 19, 11}, { 19, 11}, { 19, 11}, { 19, 11}, { 19, 11}, { 19, 11}, { 19, 11},
  {246, 11}, {246, 11}, {246, 11}, {246, 11}, {246, 11}, {246, 11}, {246, 11}, {246, 11}
};

/* intra mean value, codes 00000000000000000000 ... 000000000000001xxxxx */
static vlc_code_t intra_mean_table_3[64] = {
  {  6, 20}, {  3, 20}, {  4, 20}, {  5, 20}, {  7, 20}, {  8, 20}, {  9, 19}, {  9, 19},
  {  2, 17}, {  2, 17}, {  2, 17}, {  2, 17}, {  2, 17}, {  2, 17}, {  2, 17}, {  2, 17},
  { 16, 16}, { 16, 16}, { 16, 16}, { 16, 16}, { 16, 16}, { 16, 16}, { 16, 16}, { 16, 16},
  { 16, 16}, { 16, 16}, { 16, 16}, { 16, 16}, { 16, 16}, { 16, 16}, { 16, 16}, { 16, 16},
  { 15, 15}, { 15, 15}, { 15, 15}, { 15, 15}, { 15, 15}, { 15, 15}, { 15, 15}, { 15, 15},
  { 15, 15}, { 15, 15}, { 15, 15}, { 15, 15}, { 15, 15}, { 15, 15}, { 15, 15}, { 15, 15},
  { 15, 15}, { 15, 15}, { 15, 15}, { 15, 15}, { 15, 15}, { 15, 15}, { 15, 15}, { 15, 15},
  { 15, 15}, { 15, 15}, { 15, 15}, { 15, 15}, { 15, 15}, { 15, 15}, { 15, 15}, { 15, 15}
};

/* inter mean value, codes 00001011 ... 1xxxxxxx */
static vlc_code_t inter_mean_table_0[245] = {
  { 10, 8 }, { 12, 8 }, { 11, 8 }, {-11, 8 }, {-12, 8 },
  {-10, 8 }, { -9, 8 }, { -7, 7 }, { -7, 7 }, { -6, 7 }, { -6, 7 }, {  8, 7 }, {  8, 7 },
  { -8, 7 }, { -8, 7 }, {  9, 7 }, {  9, 7 }, {  6, 7 }, {  6, 7 }, {  7, 7 }, {  7, 7 },
  { -5, 6 }, { -5, 6 }, { -5, 6 }, { -5, 6 }, { -4, 6 }, { -4, 6 }, { -4, 6 }, { -4, 6 },
  {  5, 6 }, {  5, 6 }, {  5, 6 }, {  5, 6 }, {  4, 6 }, {  4, 6 }, {  4, 6 }, {  4, 6 },
  {  3, 5 }, {  3, 5 }, {  3, 5 }, {  3, 5 }, {  3, 5 }, {  3, 5 }, {  3, 5 }, {  3, 5 },
  {  2, 5 }, {  2, 5 }, {  2, 5 }, {  2, 5 }, {  2, 5 }, {  2, 5 }, {  2, 5 }, {  2, 5 },
  { -2, 5 }, { -2, 5 }, { -2, 5 }, { -2, 5 }, { -2, 5 }, { -2, 5 }, { -2, 5 }, { -2, 5 },
  { -3, 5 }, { -3, 5 }, { -3, 5 }, { -3, 5 }, { -3, 5 }, { -3, 5 }, { -3, 5 }, { -3, 5 },
  { -1, 4 }, { -1, 4 }, { -1, 4 }, { -1, 4 }, { -1, 4 }, { -1, 4 }, { -1, 4 }, { -1, 4 },
  { -1, 4 }, { -1, 4 }, { -1, 4 }, { -1, 4 }, { -1, 4 }, { -1, 4 }, { -1, 4 }, { -1, 4 },
  {  1, 3 }, {  1, 3 }, {  1, 3 }, {  1, 3 }, {  1, 3 }, {  1, 3 }, {  1, 3 }, {  1, 3 },
  {  1, 3 }, {  1, 3 }, {  1, 3 }, {  1, 3 }, {  1, 3 }, {  1, 3 }, {  1, 3 }, {  1, 3 },
  {  1, 3 }, {  1, 3 }, {  1, 3 }, {  1, 3 }, {  1, 3 }, {  1, 3 }, {  1, 3 }, {  1, 3 },
  {  1, 3 }, {  1, 3 }, {  1, 3 }, {  1, 3 }, {  1, 3 }, {  1, 3 }, {  1, 3 }, {  1, 3 },
  {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 },
  {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 },
  {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 },
  {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 },
  {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 },
  {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 },
  {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 },
  {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 },
  {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 },
  {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 },
  {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 },
  {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 },
  {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 },
  {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 },
  {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 },
  {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }, {  0, 1 }
};

/* inter mean value, codes 000000010010 ... 00001011xxxx */
static vlc_code_t inter_mean_table_1[158] = {
  {-30, 12}, {-31, 12}, {-32, 12}, {-33, 12}, { 31, 12}, {-34, 12},
  {-35, 12}, { 29, 12}, { 30, 12}, { 33, 12}, { 34, 12}, { 32, 12}, {-29, 11}, {-29, 11},
  {-28, 11}, {-28, 11}, { 28, 11}, { 28, 11}, {-27, 11}, {-27, 11}, {-26, 11}, {-26, 11},
  { 27, 11}, { 27, 11}, { 26, 11}, { 26, 11}, { 25, 11}, { 25, 11}, { 24, 11}, { 24, 11},
  { 23, 11}, { 23, 11}, { 22, 11}, { 22, 11}, {-24, 11}, {-24, 11}, {-25, 11}, {-25, 11},
  {-23, 10}, {-23, 10}, {-23, 10}, {-23, 10}, {-21, 10}, {-21, 10}, {-21, 10}, {-21, 10},
  {-20, 10}, {-20, 10}, {-20, 10}, {-20, 10}, {-19, 10}, {-19, 10}, {-19, 10}, {-19, 10},
  {-18, 10}, {-18, 10}, {-18, 10}, {-18, 10}, {-22, 10}, {-22, 10}, {-22, 10}, {-22, 10},
  { 19, 10}, { 19, 10}, { 19, 10}, { 19, 10}, { 21, 10}, { 21, 10}, { 21, 10}, { 21, 10},
  { 20, 10}, { 20, 10}, { 20, 10}, { 20, 10}, { 18, 10}, { 18, 10}, { 18, 10}, { 18, 10},
  {-14, 9 }, {-14, 9 }, {-14, 9 }, {-14, 9 }, {-14, 9 }, {-14, 9 }, {-14, 9 }, {-14, 9 },
  {-17, 9 }, {-17, 9 }, {-17, 9 }, {-17, 9 }, {-17, 9 }, {-17, 9 }, {-17, 9 }, {-17, 9 },
  { 16, 9 }, { 16, 9 }, { 16, 9 }, { 16, 9 }, { 16, 9 }, { 16, 9 }, { 16, 9 }, { 16, 9 },
  { 13, 9 }, { 13, 9 }, { 13, 9 }, { 13, 9 }, { 13, 9 }, { 13, 9 }, { 13, 9 }, { 13, 9 },
  { 14, 9 }, { 14, 9 }, { 14, 9 }, { 14, 9 }, { 14, 9 }, { 14, 9 }, { 14, 9 }, { 14, 9 },
  { 15, 9 }, { 15, 9 }, { 15, 9 }, { 15, 9 }, { 15, 9 }, { 15, 9 }, { 15, 9 }, { 15, 9 },
  { 17, 9 }, { 17, 9 }, { 17, 9 }, { 17, 9 }, { 17, 9 }, { 17, 9 }, { 17, 9 }, { 17, 9 },
  {-13, 9 }, {-13, 9 }, {-13, 9 }, {-13, 9 }, {-13, 9 }, {-13, 9 }, {-13, 9 }, {-13, 9 },
  {-16, 9 }, {-16, 9 }, {-16, 9 }, {-16, 9 }, {-16, 9 }, {-16, 9 }, {-16, 9 }, {-16, 9 },
  {-15, 9 }, {-15, 9 }, {-15, 9 }, {-15, 9 }, {-15, 9 }, {-15, 9 }, {-15, 9 }, {-15, 9 }
};

/* inter mean value, codes 000000000010111 ... 0000000100011xx */
static vlc_code_t inter_mean_table_2[121] = {
  { 61, 15},
  { 52, 15}, { 58, 15}, {-56, 15}, {-57, 15}, { 59, 15}, {-55, 15}, { 60, 15}, {-54, 15},
  { 53, 15}, {-62, 15}, {-60, 15}, {-59, 15}, {-58, 15}, { 57, 15}, { 56, 15}, {-53, 15},
  { 55, 15}, { 54, 15}, { 50, 14}, { 50, 14}, { 45, 14}, { 45, 14}, {-52, 14}, {-52, 14},
  {-51, 14}, {-51, 14}, {-50, 14}, {-50, 14}, { 46, 14}, { 46, 14}, {-49, 14}, {-49, 14},
  {-48, 14}, {-48, 14}, { 48, 14}, { 48, 14}, {-47, 14}, {-47, 14}, { 49, 14}, { 49, 14},
  {-45, 14}, {-45, 14}, {-44, 14}, {-44, 14}, { 47, 14}, { 47, 14}, { 51, 14}, { 51, 14},
  { 44, 14}, { 44, 14}, {-46, 14}, {-46, 14}, {-43, 13}, {-43, 13}, {-43, 13}, {-43, 13},
  {-42, 13}, {-42, 13}, {-42, 13}, {-42, 13}, {-41, 13}, {-41, 13}, {-41, 13}, {-41, 13},
  {-40, 13}, {-40, 13}, {-40, 13}, {-40, 13}, {-39, 13}, {-39, 13}, {-39, 13}, {-39, 13},
  {-38, 13}, {-38, 13}, {-38, 13}, {-38, 13}, {-37, 13}, {-37, 13}, {-37, 13}, {-37, 13},
  {-36, 13}, {-36, 13}, {-36, 13}, {-36, 13}, { 42, 13}, { 42, 13}, { 42, 13}, { 42, 13},
  { 36, 13}, { 36, 13}, { 36, 13}, { 36, 13}, { 43, 13}, { 43, 13}, { 43, 13}, { 43, 13},
  { 41, 13}, { 41, 13}, { 41, 13}, { 41, 13}, { 40, 13}, { 40, 13}, { 40, 13}, { 40, 13},
  { 35, 13}, { 35, 13}, { 35, 13}, { 35, 13}, { 39, 13}, { 39, 13}, { 39, 13}, { 39, 13},
  { 38, 13}, { 38, 13}, { 38, 13}, { 38, 13}, { 37, 13}, { 37, 13}, { 37, 13}, { 37, 13}
};

/* inter mean value, codes 000000000000100101 ... 0000000000101101xx */
static vlc_code_t inter_mean_table_3[147] = {
  {111, 18}, {102, 18}, { 99, 18},
  {-86, 18}, { 97, 18}, {-97, 18}, { 96, 18}, {-95, 18}, {-76, 18}, {-77, 18}, {-78, 18},
  {-85, 18}, {-80, 18}, {-81, 18}, { 89, 18}, { 90, 18}, {-84, 18}, {-89, 18}, { 80, 18},  
  {-90, 18}, {-88, 18}, { 92, 18}, { 93, 18}, { 95, 18}, {-109,18}, {-79, 17}, {-79, 17},
  {-83, 17}, {-83, 17}, {-75, 17}, {-75, 17}, {-74, 17}, {-74, 17}, {-73, 17}, {-73, 17},
  {-72, 17}, {-72, 17}, { 87, 17}, { 87, 17}, { 86, 17}, { 86, 17}, { 75, 17}, { 75, 17},
  { 85, 17}, { 85, 17}, { 84, 17}, { 84, 17}, { 81, 17}, { 81, 17}, { 79, 17}, { 79, 17},
  { 74, 17}, { 74, 17}, { 72, 17}, { 72, 17}, { 82, 17}, { 82, 17}, { 78, 17}, { 78, 17},
  { 83, 17}, { 83, 17}, { 76, 17}, { 76, 17}, { 73, 17}, { 73, 17}, { 77, 17}, { 77, 17},
  { 70, 16}, { 70, 16}, { 70, 16}, { 70, 16}, { 69, 16}, { 69, 16}, { 69, 16}, { 69, 16},
  { 64, 16}, { 64, 16}, { 64, 16}, { 64, 16}, {-68, 16}, {-68, 16}, {-68, 16}, {-68, 16},
  {-66, 16}, {-66, 16}, {-66, 16}, {-66, 16}, { 68, 16}, { 68, 16}, { 68, 16}, { 68, 16},
  {-69, 16}, {-69, 16}, {-69, 16}, {-69, 16}, { 65, 16}, { 65, 16}, { 65, 16}, { 65, 16},
  { 71, 16}, { 71, 16}, { 71, 16}, { 71, 16}, {-70, 16}, {-70, 16}, {-70, 16}, {-70, 16},
  {-65, 16}, {-65, 16}, {-65, 16}, {-65, 16}, {-67, 16}, {-67, 16}, {-67, 16}, {-67, 16},
  {-63, 16}, {-63, 16}, {-63, 16}, {-63, 16}, {-71, 16}, {-71, 16}, {-71, 16}, {-71, 16},
  { 67, 16}, { 67, 16}, { 67, 16}, { 67, 16}, {-61, 16}, {-61, 16}, {-61, 16}, {-61, 16},
  {-64, 16}, {-64, 16}, {-64, 16}, {-64, 16}, { 63, 16}, { 63, 16}, { 63, 16}, { 63, 16},
  { 62, 16}, { 62, 16}, { 62, 16}, { 62, 16}, { 66, 16}, { 66, 16}, { 66, 16}, { 66, 16}
};

/* inter mean value, codes 00000000000001001001 ... 0000000000001001001x */
static vlc_code_t inter_mean_table_4[75] = {
  {142, 20}, {135, 20}, {125, 20}, {123, 20}, {122, 20}, {119, 20}, {117, 20},
  {113, 20}, {104, 20}, {103, 20}, {-120,20}, {-114,20}, {-108,20}, {-104,20}, {-102,20},
  {-101,20}, {-93, 20}, {-91, 19}, {-91, 19}, {-96, 19}, {-96, 19}, { 88, 19}, { 88, 19},
  { 91, 19}, { 91, 19}, { 94, 19}, { 94, 19}, {121, 19}, {121, 19}, {120, 19}, {120, 19},
  {-110,19}, {-110,19}, {118, 19}, {118, 19}, {115, 19}, {115, 19}, {114, 19}, {114, 19},
  {112, 19}, {112, 19}, {107, 19}, {107, 19}, {110, 19}, {110, 19}, {109, 19}, {109, 19},
  {108, 19}, {108, 19}, {-103,19}, {-103,19}, {106, 19}, {106, 19}, {105, 19}, {105, 19},
  {-100,19}, {-100,19}, {101, 19}, {101, 19}, {100, 19}, {100, 19}, {-99, 19}, {-99, 19},
  {-82, 19}, {-82, 19}, {-87, 19}, {-87, 19}, {-94, 19}, {-94, 19}, {-98, 19}, {-98, 19},
  { 98, 19}, { 98, 19}, {-92, 19}, {-92, 19}
};

/* inter mean value, codes 0000000000000000000000 ... 000000000000010010001x */
static vlc_code_t inter_mean_table_5[292] = {
  {255, 22}, {254, 22}, {253, 22}, {252, 22}, {251, 22}, {250, 22}, {249, 22}, {248, 22},
  {247, 22}, {246, 22}, {245, 22}, {244, 22}, {243, 22}, {242, 22}, {241, 22}, {240, 22},
  {239, 22}, {238, 22}, {237, 22}, {236, 22}, {235, 22}, {234, 22}, {233, 22}, {232, 22},
  {231, 22}, {230, 22}, {229, 22}, {228, 22}, {227, 22}, {226, 22}, {225, 22}, {224, 22},
  {223, 22}, {222, 22}, {221, 22}, {220, 22}, {219, 22}, {218, 22}, {217, 22}, {216, 22},
  {215, 22}, {214, 22}, {213, 22}, {212, 22}, {211, 22}, {210, 22}, {209, 22}, {208, 22},
  {207, 22}, {206, 22}, {205, 22}, {204, 22}, {203, 22}, {202, 22}, {201, 22}, {200, 22},
  {199, 22}, {198, 22}, {197, 22}, {196, 22}, {195, 22}, {194, 22}, {193, 22}, {192, 22},
  {191, 22}, {190, 22}, {189, 22}, {188, 22}, {187, 22}, {186, 22}, {185, 22}, {184, 22},
  {183, 22}, {182, 22}, {181, 22}, {180, 22}, {179, 22}, {178, 22}, {177, 22}, {176, 22},
  {175, 22}, {174, 22}, {173, 22}, {172, 22}, {171, 22}, {170, 22}, {169, 22}, {168, 22},
  {167, 22}, {166, 22}, {-256,22}, {164, 22}, {-211,22}, {162, 22}, {161, 22}, {160, 22},
  {-210,22}, {-168,22}, {157, 22}, {156, 22}, {155, 22}, {154, 22}, {153, 22}, {152, 22},
  {151, 22}, {150, 22}, {149, 22}, {148, 22}, {147, 22}, {146, 22}, {145, 22}, {144, 22},
  {143, 22}, {-208,22}, {141, 22}, {140, 22}, {139, 22}, {-200,22}, {137, 22}, {136, 22},
  {-198,22}, {134, 22}, {133, 22}, {-196,22}, {-201,22}, {130, 22}, {129, 22}, {128, 22},
  {127, 22}, {126, 22}, {-195,22}, {124, 22}, {-167,22}, {-166,22}, {-165,22}, {-164,22},
  {-163,22}, {-162,22}, {-161,22}, {-180,22}, {-160,22}, {-159,22}, {-158,22}, {-157,22},
  {-156,22}, {-155,22}, {-154,22}, {-153,22}, {-152,22}, {-151,22}, {-150,22}, {-149,22},
  {-148,22}, {-147,22}, {-146,22}, {-145,22}, {-144,22}, {-143,22}, {-142,22}, {-141,22},
  {-140,22}, {-139,22}, {-138,22}, {-137,22}, {-136,22}, {-135,22}, {-134,22}, {-133,22},
  {-132,22}, {-131,22}, {-130,22}, {-129,22}, {-126,22}, {-125,22}, {-124,22}, {-123,22},
  {-122,22}, {-121,22}, {-118,22}, {-116,22}, {-115,22}, {-113,22}, {-112,22}, {-107,22},
  {-106,22}, {-169,22}, {-170,22}, {-171,22}, {-172,22}, {-173,22}, {-174,22}, {-175,22},
  {-176,22}, {-177,22}, {-178,22}, {-187,22}, {-179,22}, {-181,22}, {-182,22}, {-183,22},
  {-184,22}, {-185,22}, {-186,22}, {-235,22}, {-188,22}, {-189,22}, {-190,22}, {-191,22},
  {-192,22}, {-193,22}, {-194,22}, {-197,22}, {-255,22}, {-254,22}, {-253,22}, {-252,22},
  {-251,22}, {-250,22}, {-249,22}, {-248,22}, {-247,22}, {-246,22}, {-245,22}, {-244,22},
  {-243,22}, {-242,22}, {-241,22}, {-240,22}, {-239,22}, {-238,22}, {-237,22}, {-232,22},
  {-236,22}, {-234,22}, {-233,22}, {-217,22}, {-231,22}, {-230,22}, {-229,22}, {-228,22},
  {-227,22}, {-226,22}, {-225,22}, {-224,22}, {-223,22}, {-222,22}, {-221,22}, {-220,22},
  {-219,22}, {-216,22}, {-202,22}, {-205,22}, {-215,22}, {-214,22}, {-213,22}, {-204,22},
  {-212,22}, {-209,22}, {-218,22}, {-199,22}, {-207,22}, {-206,22}, {165, 21}, {165, 21},
  {131, 21}, {131, 21}, {163, 21}, {163, 21}, {-203,21}, {-203,21}, {116, 21}, {116, 21},
  {159, 21}, {159, 21}, {138, 21}, {138, 21}, {158, 21}, {158, 21}, {-105,21}, {-105,21},
  {-111,21}, {-111,21}, {132, 21}, {132, 21}, {128, 21}, {128, 21}, {-127,21}, {-127,21},
  {-119,21}, {-119,21}, {-117,21}, {-117,21}
};


static uint32_t get_bits (bit_buffer_t *bitbuf, int count) {
  uint32_t result;

  /* load 32 bits of data (byte-aligned) */
  result   = be2me_32 (*((uint32_t *) &bitbuf->buffer[bitbuf->bitpos >> 3]));

  /* compensate for sub-byte offset */
  result <<= (bitbuf->bitpos & 0x7);

  /* flush num bits */
  bitbuf->bitpos += count;

  /* return num bits */
  return result >> (32 - count);
}

/*
 * Return next 32 bits (left aligned).
 */
static uint32_t get_bit_cache(bit_buffer_t *bitbuf) {
  uint32_t result;

  /* load 32 bits of data (byte-aligned) */
  result   = be2me_32 (*((uint32_t *) &bitbuf->buffer[bitbuf->bitpos >> 3]));

  /* compensate for sub-byte offset */
  result <<= (bitbuf->bitpos & 0x7);

  return result;
}

static int decode_svq1_block (bit_buffer_t *bitbuf, uint8_t *pixels, int pitch, int intra) {
  uint32_t    bit_cache;
  vlc_code_t *vlc;
  uint8_t    *list[63];
  uint32_t   *dst;
  uint32_t   *codebook;
  int           entries[6];
  int           i, j, m, n;
  int           mean, stages;
  int           x, y, width, height, level;
  uint32_t    n1, n2, n3, n4;

  /* initialize list for breadth first processing of vectors */
  list[0] = pixels;

  /* recursively process vector */
  for (i=0, m=1, n=1, level=5; i < n; i++) {
    for (; level > 0; i++) {

      /* process next depth */
      if (i == m) {
     m = n;

     if (--level == 0)
       break;
      }

      /* divide block if next bit set */
      if (get_bits (bitbuf, 1) == 0)
     break;

      /* add child nodes */
      list[n++] = list[i];
      list[n++] = list[i] + (((level & 1) ? pitch : 1) << ((level / 2) + 1));
    }

    /* destination address and vector size */
    dst = (uint32_t *) list[i];
    width = 1 << ((4 + level) /2);
    height = 1 << ((3 + level) /2);

    /* get number of stages (-1 skips vector, 0 for mean only) */
    bit_cache = get_bit_cache (bitbuf);

    if (intra)
      vlc = &intra_vector_tables[level][bit_cache >> (32 - 7)];
    else
      vlc = &inter_vector_tables[level][bit_cache >> (32 - 6)];

    /* flush bits */
    stages         = vlc->value;
    bitbuf->bitpos += vlc->length;

    if (stages == -1) {
      if (intra) {
     for (y=0; y < height; y++) {
       memset (&dst[y*(pitch / 4)], 0, width);
     }
      }
      continue;          /* skip vector */
    }

    if ((stages > 0) && (level >= 4)) {
      return -1;    /* invalid vector */
    }

    /* get mean value for vector */
    bit_cache = get_bit_cache (bitbuf);

    if (intra) {
      if (bit_cache >= 0x25000000)
     vlc = &intra_mean_table_0[(bit_cache >> (32 - 8)) - 37];
      else if (bit_cache >= 0x03400000)
     vlc = &intra_mean_table_1[(bit_cache >> (32 - 10)) - 13];
      else if (bit_cache >= 0x00040000) 
     vlc = &intra_mean_table_2[(bit_cache >> (32 - 14)) - 1];
      else
     vlc = &intra_mean_table_3[bit_cache >> (32 - 20)];
    } else {
      if (bit_cache >= 0x0B000000)
     vlc = &inter_mean_table_0[(bit_cache >> (32 - 8)) - 11];
      else if (bit_cache >= 0x01200000)
     vlc = &inter_mean_table_1[(bit_cache >> (32 - 12)) - 18];
      else if (bit_cache >= 0x002E0000) 
     vlc = &inter_mean_table_2[(bit_cache >> (32 - 15)) - 23];
      else if (bit_cache >= 0x00094000)
     vlc = &inter_mean_table_3[(bit_cache >> (32 - 18)) - 37];
      else if (bit_cache >= 0x00049000)
     vlc = &inter_mean_table_4[(bit_cache >> (32 - 20)) - 73];
      else
     vlc = &inter_mean_table_5[bit_cache >> (32 - 22)];
    }

    /* flush bits */
    mean      = vlc->value;
    bitbuf->bitpos += vlc->length;

    if (intra && stages == 0) {
      for (y=0; y < height; y++) {
     memset (&dst[y*(pitch / 4)], mean, width);
      }
    } else {
      codebook = (uint32_t *) (intra ? intra_codebooks[level] : inter_codebooks[level]);
      bit_cache = get_bits (bitbuf, 4*stages);

      /* calculate codebook entries for this vector */
      for (j=0; j < stages; j++) {
     entries[j] = (((bit_cache >> (4*(stages - j - 1))) & 0xF) + 16*j) << (level + 1);
      }

      mean -= (stages * 128);
      n4    = ((mean + (mean >> 31)) << 16) | (mean & 0xFFFF);

      for (y=0; y < height; y++) {
     for (x=0; x < (width / 4); x++, codebook++) {
       if (intra) {
         n1 = n4;
         n2 = n4;
       } else {
         n3 = dst[x];

         /* add mean value to vector */
         n1 = ((n3 & 0xFF00FF00) >> 8) + n4;
         n2 =  (n3 & 0x00FF00FF)     + n4;
       }

       /* add codebook entries to vector */
       for (j=0; j < stages; j++) {
         n3  = codebook[entries[j]] ^ 0x80808080;
         n1 += ((n3 & 0xFF00FF00) >> 8);
         n2 +=  (n3 & 0x00FF00FF);
       }

       /* clip to [0..255] */
       if (n1 & 0xFF00FF00) {
         n3  = ((( n1 >> 15) & 0x00010001) | 0x01000100) - 0x00010001;
         n1 += 0x7F007F00;
         n1 |= (((~n1 >> 15) & 0x00010001) | 0x01000100) - 0x00010001;
         n1 &= (n3 & 0x00FF00FF);
       }

       if (n2 & 0xFF00FF00) {
         n3  = ((( n2 >> 15) & 0x00010001) | 0x01000100) - 0x00010001;
         n2 += 0x7F007F00;
         n2 |= (((~n2 >> 15) & 0x00010001) | 0x01000100) - 0x00010001;
         n2 &= (n3 & 0x00FF00FF);
       }

       /* store result */
       dst[x] = (n1 << 8) | n2;
        }

        dst += (pitch / 4);
      }
    }
  }

  return 0;
}

static int decode_motion_vector (bit_buffer_t *bitbuf, svq1_pmv_t *mv, svq1_pmv_t **pmv) {
  uint32_t    bit_cache;
  vlc_code_t *vlc;
  int           diff, sign;
  int           i;

  for (i=0; i < 2; i++) {

    /* get motion code */
    bit_cache = get_bit_cache (bitbuf);

    if (!(bit_cache & 0xFFE00000))
      return -1;    /* invalid vlc code */

    if (bit_cache & 0x80000000) {
      diff = 0;

      /* flush bit */
      bitbuf->bitpos++;

    } else {
      if (bit_cache >= 0x06000000) {
        vlc = &motion_table_0[(bit_cache >> (32 - 7)) - 3];
      } else {
        vlc = &motion_table_1[(bit_cache >> (32 - 12)) - 2];
      }

      /* decode motion vector differential */
      sign = (int) (bit_cache << (vlc->length - 1)) >> 31;
      diff = (vlc->value ^ sign) - sign;

      /* flush bits */
      bitbuf->bitpos += vlc->length;
    }

    /* add median of motion vector predictors and clip result */
    if (i == 1)
      mv->y = ((diff + MEDIAN(pmv[0]->y, pmv[1]->y, pmv[2]->y)) << 26) >> 26;
    else
      mv->x = ((diff + MEDIAN(pmv[0]->x, pmv[1]->x, pmv[2]->x)) << 26) >> 26;
  }

  return 0;
}

static void skip_block (uint8_t *current, uint8_t *previous, int pitch, int x, int y) {
  uint8_t *src;
  uint8_t *dst;
  int        i;

  src = &previous[x + y*pitch];
  dst = current;

  for (i=0; i < 16; i++) {
    memcpy (dst, src, 16);
    src += pitch;
    dst += pitch;
  }
}

static int motion_inter_block (bit_buffer_t *bitbuf,
                      uint8_t *current, uint8_t *previous, int pitch,
                      svq1_pmv_t *motion, int x, int y) {
  uint8_t    *src;
  uint8_t    *dst;
  svq1_pmv_t  mv;
  svq1_pmv_t *pmv[3];
#ifndef FAST_MC
  int           sx, sy;
#endif
  int           result;

  /* predict and decode motion vector */
  pmv[0] = &motion[0];
  pmv[1] = &motion[(x / 8) + 2];
  pmv[2] = &motion[(x / 8) + 4];

  if (y == 0) {
    pmv[1] = pmv[0];
    pmv[2] = pmv[0];
  }

  result = decode_motion_vector (bitbuf, &mv, pmv);

  if (result != 0)
    return result;

  motion[0].x       = mv.x;
  motion[0].y       = mv.y;
  motion[(x / 8) + 2].x  = mv.x;
  motion[(x / 8) + 2].y  = mv.y;
  motion[(x / 8) + 3].x  = mv.x;
  motion[(x / 8) + 3].y  = mv.y;

  src = &previous[(x + (mv.x >> 1)) + (y + (mv.y >> 1))*pitch];
  dst = current;

#ifdef FAST_MC
  motion_put[((mv.y & 1) << 1) | (mv.x & 1)] (dst, src, pitch, 16);
#else
  /* form prediction */
  if (mv.y & 0x1) {
    if (mv.x & 0x1) {
      for (sy=0; sy < 16; sy++) {
     for (sx=0; sx < 16; sx++) {
       dst[sx] = (src[sx] + src[sx + 1] + src[sx + pitch] + src[sx + pitch + 1] + 2) >> 2;
     }
     src += pitch;
     dst += pitch;
      }
    } else {
      for (sy=0; sy < 16; sy++) {
     for (sx=0; sx < 16; sx++) {
       dst[sx] = (src[sx] + src[sx + pitch] + 1) >> 1;
     }
     src += pitch;
     dst += pitch;
      }
    }
  } else {
    if (mv.x & 0x1) {
      for (sy=0; sy < 16; sy++) {
     for (sx=0; sx < 16; sx++) {
       dst[sx] = (src[sx] + src[sx + 1] + 1) >> 1;
     }
     src += pitch;
     dst += pitch;
      }
    } else {
      for (sy=0; sy < 16; sy++) {
     memcpy (dst, src, 16);
     src += pitch;
     dst += pitch;
      }
    }
  }
#endif /* FAST_MC */

  return 0;
}

static int motion_inter_4v_block (bit_buffer_t *bitbuf,
                      uint8_t *current, uint8_t *previous, int pitch,
                      svq1_pmv_t *motion,int x, int y) {
  uint8_t    *src;
  uint8_t    *dst;
  svq1_pmv_t  mv;
  svq1_pmv_t *pmv[4];
#ifndef FAST_MC
  int           sx, sy;
#endif
  int           i, result;

  /* predict and decode motion vector (0) */
  pmv[0] = &motion[0];
  pmv[1] = &motion[(x / 8) + 2];
  pmv[2] = &motion[(x / 8) + 4];

  if (y == 0) {
    pmv[1] = pmv[0];
    pmv[2] = pmv[0];
  }

  result = decode_motion_vector (bitbuf, &mv, pmv);

  if (result != 0)
    return result;

  /* predict and decode motion vector (1) */
  pmv[0] = &mv;
  pmv[1] = &motion[(x / 8) + 3];

  if (y == 0) {
    pmv[1] = pmv[0];
    pmv[2] = pmv[0];
  }

  result = decode_motion_vector (bitbuf, &motion[0], pmv);

  if (result != 0)
    return result;

  /* predict and decode motion vector (2) */
  pmv[1] = &motion[0];
  pmv[2] = &motion[(x / 8) + 1];

  result = decode_motion_vector (bitbuf, &motion[(x / 8) + 2], pmv);

  if (result != 0)
    return result;

  /* predict and decode motion vector (3) */
  pmv[2] = &motion[(x / 8) + 2];
  pmv[3] = &motion[(x / 8) + 3];

  result = decode_motion_vector (bitbuf, pmv[3], pmv);

  if (result != 0)
    return result;

  /* form predictions */
  for (i=0; i < 4; i++) {
    src = &previous[(x + (pmv[i]->x >> 1)) + (y + (pmv[i]->y >> 1))*pitch];
    dst = current;

#ifdef FAST_MC
    motion_put[4 | ((pmv[i]->y & 1) << 1) | (pmv[i]->x & 1)] (dst, src, pitch, 8);
#else
    if (pmv[i]->y & 0x1) {
      if (pmv[i]->x & 0x1) {
     for (sy=0; sy < 8; sy++) {
       for (sx=0; sx < 8; sx++) { 
         dst[sx] = (src[sx] + src[sx + 1] + src[sx + pitch] + src[sx + pitch + 1] + 2) >> 2;
       }
       src += pitch;
       dst += pitch;
     }
      } else {
     for (sy=0; sy < 8; sy++) {
       for (sx=0; sx < 8; sx++) {
         dst[sx] = (src[sx] + src[sx + pitch] + 1) >> 1;
       }
       src += pitch;
       dst += pitch;
     }
      }
    } else {
      if (pmv[i]->x & 0x1) {
     for (sy=0; sy < 8; sy++) {
       for (sx=0; sx < 8; sx++) {
         dst[sx] = (src[sx] + src[sx + 1] + 1) >> 1;
       }
       src += pitch;
       dst += pitch;
     }
      } else {
     for (sy=0; sy < 8; sy++) {
       memcpy (dst, src, 8);
       src += pitch;
       dst += pitch;
     }
      }
    }
#endif /* FAST_MC */

    /* select next block */
    if (i & 1) {
      current  += 8*(pitch - 1);
      previous += 8*(pitch - 1);
    } else {
      current  += 8;
      previous += 8;
    }
  }

  return 0;
}

static int decode_delta_block (bit_buffer_t *bitbuf,
               uint8_t *current, uint8_t *previous, int pitch,
               svq1_pmv_t *motion, int x, int y) {
  uint32_t bit_cache;
  uint32_t block_type;
  int        result = 0;

  /* get block type */
  bit_cache = get_bit_cache (bitbuf);

  bit_cache    >>= (32 - 3);
  block_type     = block_type_table[bit_cache].value;
  bitbuf->bitpos += block_type_table[bit_cache].length;

  /* reset motion vectors */
  if (block_type == SVQ1_BLOCK_SKIP || block_type == SVQ1_BLOCK_INTRA) {
    motion[0].x            = 0;
    motion[0].y            = 0;
    motion[(x / 8) + 2].x = 0;
    motion[(x / 8) + 2].y = 0;
    motion[(x / 8) + 3].x = 0;
    motion[(x / 8) + 3].y = 0;
  }

  switch (block_type) {
  case SVQ1_BLOCK_SKIP:
    skip_block (current, previous, pitch, x, y);
    break;

  case SVQ1_BLOCK_INTER:
    result = motion_inter_block (bitbuf, current, previous, pitch, motion, x, y);

    if (result != 0)
      break;

    result = decode_svq1_block (bitbuf, current, pitch, 0);
    break;

  case SVQ1_BLOCK_INTER_4V:
    result = motion_inter_4v_block (bitbuf, current, previous, pitch, motion, x, y);

    if (result != 0)
      break;

    result = decode_svq1_block (bitbuf, current, pitch, 0);
    break;

  case SVQ1_BLOCK_INTRA:
    result = decode_svq1_block (bitbuf, current, pitch, 1);
    break;
  }

  return result;
}

static int decode_frame_header (bit_buffer_t *bitbuf, svq1_t *svq1) {
  int frame_size_code;

  /* unknown field */
  get_bits (bitbuf, 8);

  /* frame type */
  svq1->frame_type = get_bits (bitbuf, 2);

  if (svq1->frame_type == 3)
    return -1;

  if (svq1->frame_type == SVQ1_FRAME_INTRA) {

    /* unknown fields */
    if (svq1->frame_code == 0x50 || svq1->frame_code == 0x60) {
      get_bits (bitbuf, 16);
    }

    if ((svq1->frame_code ^ 0x10) >= 0x50) {
      bitbuf->bitpos += 8*get_bits (bitbuf, 8);
    }

    get_bits (bitbuf, 2);
    get_bits (bitbuf, 2);
    get_bits (bitbuf, 1);

    /* load frame size */
    frame_size_code = get_bits (bitbuf, 3);

    if (frame_size_code == 7) {
      /* load width, height (12 bits each) */
      svq1->frame_width = get_bits (bitbuf, 12);
      svq1->frame_height = get_bits (bitbuf, 12);

      if (!svq1->frame_width || !svq1->frame_height)
        return -1;
    } else {
      /* get width, height from table */
      svq1->frame_width = frame_size_table[frame_size_code].width;
      svq1->frame_height = frame_size_table[frame_size_code].height;
    }
  }

  /* unknown fields */
  if (get_bits (bitbuf, 1) == 1) {
    get_bits (bitbuf, 1);
    get_bits (bitbuf, 1);

    if (get_bits (bitbuf, 2) != 0)
      return -1;
  }

  if (get_bits (bitbuf, 1) == 1) {
    get_bits (bitbuf, 1);
    get_bits (bitbuf, 4);
    get_bits (bitbuf, 1);
    get_bits (bitbuf, 2);

    while (get_bits (bitbuf, 1) == 1) {
      get_bits (bitbuf, 8);
    }
  }
  
  return 0;
}

static int svq1_decode_frame (svq1_t *svq1, uint8_t *buffer, int gray) {
  bit_buffer_t bitbuf;
  uint8_t      *current, *previous;
  int          result, i, x, y, width, height;
  int          luma_size, chroma_size;

  /* initialize bit buffer */
  bitbuf.buffer     = buffer;
  bitbuf.bitpos     = 0;

  /* decode frame header */
  svq1->frame_code = get_bits (&bitbuf, 22);

  if ((svq1->frame_code & ~0x70) || !(svq1->frame_code & 0x60))
    return -1;

  /* swap some header bytes (why?) */
  if (svq1->frame_code != 0x20) {
    uint32_t *src = (uint32_t *) (buffer + 4);

    for (i=0; i < 4; i++) {
      src[i] = ((src[i] << 16) | (src[i] >> 16)) ^ src[7 - i];
    }
  }

  result = decode_frame_header (&bitbuf, svq1);

/* FIXME: Find such stream and test this!

  if ((svq1->frame_type == SVQ1_FRAME_DROPPABLE) && (drop) {
    return -1;
  }

*/

  if (result != 0)
    return result;

  /* check frame size (changed?) */
  if (((svq1->frame_width + 3) & ~0x3) != svq1->width ||
      ((svq1->frame_height + 3) & ~0x3) != svq1->height) {

    /* free current buffers */
    free (svq1->current);
    free (svq1->previous);
    free (svq1->motion);

    svq1->width          = (svq1->frame_width + 3) & ~0x3;
    svq1->height    = (svq1->frame_height + 3) & ~0x3;
    svq1->luma_width     = (svq1->width + 15) & ~0xF;
    svq1->luma_height    = (svq1->height + 15) & ~0xF;
    svq1->chroma_width   = ((svq1->width / 4) + 15) & ~0xF;
    svq1->chroma_height  = ((svq1->height / 4) + 15) & ~0xF;

    /* allocate new pixel and motion buffers for updated frame size */
    luma_size       = svq1->luma_width * svq1->luma_height;
    chroma_size          = svq1->chroma_width * svq1->chroma_height;

    svq1->motion    = (svq1_pmv_t *) malloc (((svq1->luma_width / 8) + 3) * sizeof(svq1_pmv_t));
    svq1->current   = (uint8_t *) malloc (luma_size + 2*chroma_size);
    svq1->previous  = (uint8_t *) malloc (luma_size + 2*chroma_size);
    svq1->offsets[0]     = 0;
    svq1->offsets[1]     = luma_size;
    svq1->offsets[2]     = luma_size + chroma_size;

    for (i=0; i < 3; i++) {
      svq1->base[i] = svq1->current + svq1->offsets[i];
    }

    svq1->reference_frame = 0;
  }

  /* delta frame requires reference frame */
  if (svq1->frame_type != SVQ1_FRAME_INTRA && !svq1->reference_frame)
    return -1;

  /* only decode y for grayscale playback */
  if (gray) {
    gray = 1;
  } else {
    gray = 3;
  }

  /* decode y, u and v components */
  for (i=0; i < gray; i++) {
    if (i == 0) {
      width  = svq1->luma_width;
      height = svq1->luma_height;
    } else {
      width  = svq1->chroma_width;
      height = svq1->chroma_height;
    }

    current  = svq1->current + svq1->offsets[i];
    previous = svq1->previous + svq1->offsets[i];

    if (svq1->frame_type == SVQ1_FRAME_INTRA) {
      /* keyframe */
      for (y=0; y < height; y+=16) {
     for (x=0; x < width; x+=16) {
       result = decode_svq1_block (&bitbuf, &current[x], width, 1);

       if (result != 0)
         return result;
     }

     current += 16*width;
      }
    } else {
      /* delta frame */
      memset (svq1->motion, 0, ((width / 8) + 3) * sizeof(svq1_pmv_t));

      for (y=0; y < height; y+=16) {
     for (x=0; x < width; x+=16) {
       result = decode_delta_block (&bitbuf, &current[x], previous,
                           width, svq1->motion, x, y);

       if (result != 0)
         return result;
     }

     svq1->motion[0].x = 0;
     svq1->motion[0].y = 0;

     current += 16*width;
      }
    }
  }

  /* update pixel buffers for frame copy */
  for (i=0; i < 3; i++) {
    svq1->base[i] = svq1->current + svq1->offsets[i];
  }

  /* update backward reference frame */
  if (svq1->frame_type != SVQ1_FRAME_DROPPABLE) {
    uint8_t *tmp = svq1->previous;
    svq1->previous = svq1->current;
    svq1->current = tmp;
    svq1->reference_frame = 1;    
  }

  return 0;
}

static void hscale_chroma_line (uint8_t *dst, uint8_t *src, int width) {
  uint32_t  n1, n2;
  int         x;

  n1    = *src;
  *(dst++) = n1;

  for (x=0; x < (width - 1); x++) {
    n2         = *(++src);
    *(dst++) = (3*n1 + n2 + 2) >> 2;
    *(dst++) = (n1 + 3*n2 + 2) >> 2;
    n1         = n2;
  }

  *dst = n1;
}

static void vscale_chroma_line (uint8_t *dst, int pitch, uint8_t *src1, uint8_t *src2, int width) {
  uint32_t  t1, t2;
  uint32_t  n1, n2, n3, n4;
  uint32_t *dst1, *dst2;
  int         x;

  dst1 = (uint32_t *) dst;
  dst2 = (uint32_t *) (dst + pitch);

  /* process blocks of 4 pixels */
  for (x=0; x < (width / 4); x++) {
    n1  = *(((uint32_t *) src1)++);
    n2  = *(((uint32_t *) src2)++);
    n3  = (n1 & 0xFF00FF00) >> 8;
    n4  = (n2 & 0xFF00FF00) >> 8;
    n1 &= 0x00FF00FF;
    n2 &= 0x00FF00FF;

    t1 = (2*n1 + 2*n2 + 0x20002);
    t2 = (n1 - n2);
    n1 = (t1 + t2);
    n2 = (t1 - t2);
    t1 = (2*n3 + 2*n4 + 0x20002);
    t2 = (n3 - n4);
    n3 = (t1 + t2);
    n4 = (t1 - t2);

    *(dst1++) = ((n1 >> 2) & 0x00FF00FF) | ((n3 << 6) & 0xFF00FF00);
    *(dst2++) = ((n2 >> 2) & 0x00FF00FF) | ((n4 << 6) & 0xFF00FF00);
  }

  /* process remaining pixels */
  for (x=(width & ~0x3); x < width; x++) {
    n1 = src1[x];
    n2 = src2[x];

    dst[x]      = (3*n1 + n2 + 2) >> 2;
    dst[x+pitch] = (n1 + 3*n2 + 2) >> 2;
  }
}

static void svq1_copy_frame (svq1_t *svq1, uint8_t *base[3], int pitch) {
  uint8_t *src;
  uint8_t *dst;
  uint8_t *cr1, *cr2, *tmp;
  int        y, i;

  src = svq1->base[0];
  dst = base[0];

/* what a waste, isn't it ? / AmiDog
  for (y=0; y < svq1->height; y++) {
    memcpy (dst, src, svq1->width);
    src += svq1->luma_width;
    dst += pitch;
  }
*/

  for (i=1; i < 3; i++) {
    src = svq1->base[i];
    dst = base[i];
    cr1 = &dst[(pitch / 2) * ((svq1->height / 2) - 1)];
    cr2 = &dst[(pitch / 2) * ((svq1->height / 2) - 2)];

    /* horizontally upscale first line */
    hscale_chroma_line (cr1, src, (svq1->width / 4));
    src += svq1->chroma_width;

    /* store first line */
    memcpy (dst, cr1, (svq1->width / 2));
    dst += (pitch / 2);

    for (y=0; y < (svq1->height / 4) - 1; y++) {
      hscale_chroma_line (cr2, src, (svq1->width / 4));
      src += svq1->chroma_width;

      /* interpolate and store two lines */
      vscale_chroma_line (dst, (pitch / 2), cr1, cr2, (svq1->width / 2));
      dst += pitch;

      /* swap buffers */
      tmp = cr2;
      cr2 = cr1;
      cr1 = tmp;
    }

    /* horizontally upscale and store last line */
    src -= svq1->chroma_width;
    hscale_chroma_line (dst, src, (svq1->width / 4));
  }
}

#if 0

static int svq1dec_can_handle (video_decoder_t *this_gen, int buf_type) {
  return ((buf_type & 0xFFFF0000) == BUF_VIDEO_SORENSON_V1);
}

static void svq1dec_init (video_decoder_t *this_gen, vo_instance_t *video_out) {
  svq1dec_decoder_t *this = (svq1dec_decoder_t *) this_gen;

  this->video_out  = video_out;
  this->decoder_ok = 0;
  this->svq1      = (svq1_t *) xine_xmalloc (sizeof(svq1_t));
}

static void svq1dec_decode_data (video_decoder_t *this_gen, buf_element_t *buf) {
  svq1dec_decoder_t *this = (svq1dec_decoder_t *) this_gen;

  if (buf->decoder_flags & BUF_FLAG_PREVIEW)
    return;

  if (buf->decoder_flags & BUF_FLAG_HEADER) {
    this->video_step = buf->decoder_info[1];

    if (this->buf)
      free (this->buf);
    this->bufsize = VIDEOBUFSIZE;
    this->buf = malloc(this->bufsize);
    this->size = 0;

    this->video_out->open (this->video_out);
    this->decoder_ok = 1;

  } else if (this->decoder_ok) {
    
    if (this->size + buf->size > this->bufsize) {
      this->bufsize = this->size + 2 * buf->size;
      this->buf = realloc (this->buf, this->bufsize);
    }

    xine_fast_memcpy (&this->buf[this->size], buf->content, buf->size);

    this->size += buf->size;

    if (buf->decoder_flags & BUF_FLAG_FRAMERATE)
      this->video_step = buf->decoder_info[0];

    if (buf->decoder_flags & BUF_FLAG_FRAME_END) {

      vo_frame_t *img;
      int   result;

      result = svq1_decode_frame (this->svq1, this->buf);

      if (this->svq1->width > 0 && this->svq1->height > 0) {

     img = this->video_out->get_frame (this->video_out,
                           this->svq1->width,
                           this->svq1->height,
                           42, IMGFMT_YV12, VO_BOTH_FIELDS);

     img->duration  = this->video_step;
     img->pts  = buf->pts;
     img->bad_frame = (result != 0);

     if (result == 0) {
       svq1_copy_frame (this->svq1, img->base, img->width);
     }

     if (img->copy) {
       int height = img->height;
       int stride = img->width;
       uint8_t *src[3];

       src[0] = img->base[0];
       src[1] = img->base[1];
       src[2] = img->base[2];

       while ((height -= 16) >= 0) {
         img->copy(img, src);
         src[0] += 16 * stride;
         src[1] +=  4 * stride;
         src[2] +=  4 * stride;
       }
     }

     img->draw(img);
     img->free(img);
      }

      this->size = 0;
    }
  }
}

static void svq1dec_flush (video_decoder_t *this_gen) {
}

static void svq1dec_reset (video_decoder_t *this_gen) {
  svq1dec_decoder_t *this = (svq1dec_decoder_t *) this_gen;

  if (this->svq1) {
    this->svq1->reference_frame = 0;
  }

  this->size = 0;
}

static void svq1dec_close (video_decoder_t *this_gen) {
  svq1dec_decoder_t *this = (svq1dec_decoder_t *) this_gen;

  if (this->svq1) {
    free (this->svq1->current);
    free (this->svq1->previous);
    free (this->svq1->motion);
    free (this->svq1);
    this->svq1 = NULL;
  }

  if (this->buf) {
    free (this->buf);
    this->buf = NULL;
  }

  if (this->decoder_ok) {  
    this->decoder_ok = 0;
    this->video_out->close(this->video_out);
  }
}

static char *svq1dec_get_id(void) {
  return "svq1";
}

static void svq1dec_dispose (video_decoder_t *this_gen) {
  free (this_gen);
}

video_decoder_t *init_video_decoder_plugin (int iface_version, xine_t *xine) {

  svq1dec_decoder_t *this ;

  if (iface_version != 9) {
    printf( "svq1: plugin doesn't support plugin API version %d.\n"
         "svq1: this means there's a version mismatch between xine and this "
         "svq1: decoder plugin.\nInstalling current plugins should help.\n",
         iface_version);
    return NULL;
  }

  this = (svq1dec_decoder_t *) xine_xmalloc (sizeof (svq1dec_decoder_t));

  this->video_decoder.interface_version   = iface_version;
  this->video_decoder.can_handle          = svq1dec_can_handle;
  this->video_decoder.init                = svq1dec_init;
  this->video_decoder.decode_data         = svq1dec_decode_data;
  this->video_decoder.flush               = svq1dec_flush;
  this->video_decoder.reset               = svq1dec_reset;
  this->video_decoder.close               = svq1dec_close;
  this->video_decoder.get_identifier      = svq1dec_get_id;
  this->video_decoder.dispose             = svq1dec_dispose;
  this->video_decoder.priority            = 5;

  return (video_decoder_t *) this;
}

#endif

#include <plugin.h>

static svq1_t *svq1 = NULL;

static int video_w, video_h, video_gray;
static int svq1_error = 0;

static double current_time = 0.0;
static double current_frame_time = 0.0;
static double current_video_time = 0.0;

static unsigned char *yuv[3] = { NULL, NULL, NULL };

int decode_svq1(unsigned char *buf, unsigned long length, double sync_time)
{
  if (svq1_error != 0) {
    return PLUGIN_FAIL;
  }

  if (length > 0) {
    int result;

    result = svq1_decode_frame (svq1, buf, video_gray);

    if (sync_time > 0.0) {
      current_time = sync_time;
    }

    if ((svq1->width > 0) && (svq1->height > 0)) {
      if (result == 0) {
        if (video_gray) {
          amp->video_refresh(svq1->base, current_time, current_video_time);
        } else {
          unsigned char *base[3];
          svq1_copy_frame (svq1, yuv, video_w);
          base[0] = svq1->base[0];
          base[1] = yuv[1];
          base[2] = yuv[2];
          amp->video_refresh(base, current_time, current_video_time);
        }
      }
    }

    amp->total_frames++;

    current_time += current_frame_time;
    current_video_time += current_frame_time;
  }

  return PLUGIN_OK;
}

int init_svq1(unsigned long type, unsigned long fourcc)
{
  int width, height;

  svq1 = (svq1_t *)malloc(sizeof(svq1_t));
  memset(svq1, 0, sizeof(svq1_t));

  width = (amp->width + 3) & ~3;
  height = (amp->height + 3) & ~3;

  yuv[0] = malloc(width * height);
  yuv[1] = malloc(width * height / 4);
  yuv[2] = malloc(width * height / 4);

  video_w = width;
  video_h = height;
  video_gray = amp->gray;

  amp->total_frames = 0;
  amp->skiped_frames = 0;

  svq1_error = 0;

  current_time = 0.0;
  current_frame_time = 1.0 / amp->framerate;
  current_video_time = 0.0;

  /* FIXME: Is this correct ? */
  amp->video_refresh_yuv2rgb(6694222, -1643170, -3409833, 8460885, 4883779, -617108528, 0x80808080);

  if (amp->video_init(width, height, width, CMODE_YUV420) != PLUGIN_OK) {
    svq1_error = 1;
    return PLUGIN_FAIL;
  }

  return PLUGIN_OK;
}

int exit_svq1(void)
{
  int i;

  for (i=0; i<3; i++) {
    if (yuv[i] != NULL) {
      free(yuv[i]);
      yuv[i] = NULL;
    }
  }

  if (svq1 != NULL) {
    free(svq1);
    svq1 = NULL;
  }

  return PLUGIN_OK;
}

VERSION("SVQ1 v1.00 (020701)");

IDENT_INIT
IDENT_ADD((TYPE_VIDEO | SUBTYPE_NONE | FEATURE_GRAY), FOURCC_SVQ1, init_svq1, decode_svq1, exit_svq1)
IDENT_ADD((TYPE_VIDEO | SUBTYPE_NONE | FEATURE_GRAY), FOURCC_svq1, init_svq1, decode_svq1, exit_svq1)
IDENT_EXIT

